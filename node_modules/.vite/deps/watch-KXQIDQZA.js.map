{
  "version": 3,
  "sources": ["browser-external:util", "../../rollup/dist/es/shared/watch.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"util\" has been externalized for browser compatibility. Cannot access \"util.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "/*\r\n  @license\r\n\tRollup.js v4.52.5\r\n\tSat, 18 Oct 2025 06:53:02 GMT - commit 55a8fd5a70820f274921edf394efbbaa620f0962\r\n\r\n\thttps://github.com/rollup/rollup\r\n\r\n\tReleased under the MIT License.\r\n*/\r\nimport { getAugmentedNamespace, fseventsImporter, getDefaultExportFromCjs, createFilter, rollupInternal } from './node-entry.js';\r\nimport path from 'node:path';\r\nimport process$1 from 'node:process';\r\nimport require$$0$1 from 'path';\r\nimport require$$2 from 'util';\r\nimport require$$0$2 from 'fs';\r\nimport require$$1 from 'stream';\r\nimport require$$2$1 from 'os';\r\nimport require$$0$3 from 'events';\r\nimport { platform } from 'node:os';\r\nimport './parseAst.js';\r\nimport '../../native.js';\r\nimport 'node:perf_hooks';\r\nimport 'node:fs/promises';\r\n\r\nvar chokidar$1 = {};\r\n\r\nvar utils$2 = {};\r\n\r\nvar constants$3;\r\nvar hasRequiredConstants$3;\r\n\r\nfunction requireConstants$3 () {\r\n\tif (hasRequiredConstants$3) return constants$3;\r\n\thasRequiredConstants$3 = 1;\r\n\r\n\tconst path = require$$0$1;\r\n\tconst WIN_SLASH = '\\\\\\\\/';\r\n\tconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\r\n\r\n\t/**\r\n\t * Posix glob regex\r\n\t */\r\n\r\n\tconst DOT_LITERAL = '\\\\.';\r\n\tconst PLUS_LITERAL = '\\\\+';\r\n\tconst QMARK_LITERAL = '\\\\?';\r\n\tconst SLASH_LITERAL = '\\\\/';\r\n\tconst ONE_CHAR = '(?=.)';\r\n\tconst QMARK = '[^/]';\r\n\tconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\r\n\tconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\r\n\tconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\r\n\tconst NO_DOT = `(?!${DOT_LITERAL})`;\r\n\tconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\r\n\tconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\r\n\tconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\r\n\tconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\r\n\tconst STAR = `${QMARK}*?`;\r\n\r\n\tconst POSIX_CHARS = {\r\n\t  DOT_LITERAL,\r\n\t  PLUS_LITERAL,\r\n\t  QMARK_LITERAL,\r\n\t  SLASH_LITERAL,\r\n\t  ONE_CHAR,\r\n\t  QMARK,\r\n\t  END_ANCHOR,\r\n\t  DOTS_SLASH,\r\n\t  NO_DOT,\r\n\t  NO_DOTS,\r\n\t  NO_DOT_SLASH,\r\n\t  NO_DOTS_SLASH,\r\n\t  QMARK_NO_DOT,\r\n\t  STAR,\r\n\t  START_ANCHOR\r\n\t};\r\n\r\n\t/**\r\n\t * Windows glob regex\r\n\t */\r\n\r\n\tconst WINDOWS_CHARS = {\r\n\t  ...POSIX_CHARS,\r\n\r\n\t  SLASH_LITERAL: `[${WIN_SLASH}]`,\r\n\t  QMARK: WIN_NO_SLASH,\r\n\t  STAR: `${WIN_NO_SLASH}*?`,\r\n\t  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\r\n\t  NO_DOT: `(?!${DOT_LITERAL})`,\r\n\t  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\r\n\t  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\r\n\t  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\r\n\t  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\r\n\t  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\r\n\t  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\r\n\t};\r\n\r\n\t/**\r\n\t * POSIX Bracket Regex\r\n\t */\r\n\r\n\tconst POSIX_REGEX_SOURCE = {\r\n\t  alnum: 'a-zA-Z0-9',\r\n\t  alpha: 'a-zA-Z',\r\n\t  ascii: '\\\\x00-\\\\x7F',\r\n\t  blank: ' \\\\t',\r\n\t  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\r\n\t  digit: '0-9',\r\n\t  graph: '\\\\x21-\\\\x7E',\r\n\t  lower: 'a-z',\r\n\t  print: '\\\\x20-\\\\x7E ',\r\n\t  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\r\n\t  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\r\n\t  upper: 'A-Z',\r\n\t  word: 'A-Za-z0-9_',\r\n\t  xdigit: 'A-Fa-f0-9'\r\n\t};\r\n\r\n\tconstants$3 = {\r\n\t  MAX_LENGTH: 1024 * 64,\r\n\t  POSIX_REGEX_SOURCE,\r\n\r\n\t  // regular expressions\r\n\t  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\r\n\t  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\r\n\t  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\r\n\t  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\r\n\t  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\r\n\t  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\r\n\r\n\t  // Replace globs with equivalent patterns to reduce parsing time.\r\n\t  REPLACEMENTS: {\r\n\t    '***': '*',\r\n\t    '**/**': '**',\r\n\t    '**/**/**': '**'\r\n\t  },\r\n\r\n\t  // Digits\r\n\t  CHAR_0: 48, /* 0 */\r\n\t  CHAR_9: 57, /* 9 */\r\n\r\n\t  // Alphabet chars.\r\n\t  CHAR_UPPERCASE_A: 65, /* A */\r\n\t  CHAR_LOWERCASE_A: 97, /* a */\r\n\t  CHAR_UPPERCASE_Z: 90, /* Z */\r\n\t  CHAR_LOWERCASE_Z: 122, /* z */\r\n\r\n\t  CHAR_LEFT_PARENTHESES: 40, /* ( */\r\n\t  CHAR_RIGHT_PARENTHESES: 41, /* ) */\r\n\r\n\t  CHAR_ASTERISK: 42, /* * */\r\n\r\n\t  // Non-alphabetic chars.\r\n\t  CHAR_AMPERSAND: 38, /* & */\r\n\t  CHAR_AT: 64, /* @ */\r\n\t  CHAR_BACKWARD_SLASH: 92, /* \\ */\r\n\t  CHAR_CARRIAGE_RETURN: 13, /* \\r */\r\n\t  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\r\n\t  CHAR_COLON: 58, /* : */\r\n\t  CHAR_COMMA: 44, /* , */\r\n\t  CHAR_DOT: 46, /* . */\r\n\t  CHAR_DOUBLE_QUOTE: 34, /* \" */\r\n\t  CHAR_EQUAL: 61, /* = */\r\n\t  CHAR_EXCLAMATION_MARK: 33, /* ! */\r\n\t  CHAR_FORM_FEED: 12, /* \\f */\r\n\t  CHAR_FORWARD_SLASH: 47, /* / */\r\n\t  CHAR_GRAVE_ACCENT: 96, /* ` */\r\n\t  CHAR_HASH: 35, /* # */\r\n\t  CHAR_HYPHEN_MINUS: 45, /* - */\r\n\t  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\r\n\t  CHAR_LEFT_CURLY_BRACE: 123, /* { */\r\n\t  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\r\n\t  CHAR_LINE_FEED: 10, /* \\n */\r\n\t  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\r\n\t  CHAR_PERCENT: 37, /* % */\r\n\t  CHAR_PLUS: 43, /* + */\r\n\t  CHAR_QUESTION_MARK: 63, /* ? */\r\n\t  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\r\n\t  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\r\n\t  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\r\n\t  CHAR_SEMICOLON: 59, /* ; */\r\n\t  CHAR_SINGLE_QUOTE: 39, /* ' */\r\n\t  CHAR_SPACE: 32, /*   */\r\n\t  CHAR_TAB: 9, /* \\t */\r\n\t  CHAR_UNDERSCORE: 95, /* _ */\r\n\t  CHAR_VERTICAL_LINE: 124, /* | */\r\n\t  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\r\n\r\n\t  SEP: path.sep,\r\n\r\n\t  /**\r\n\t   * Create EXTGLOB_CHARS\r\n\t   */\r\n\r\n\t  extglobChars(chars) {\r\n\t    return {\r\n\t      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\r\n\t      '?': { type: 'qmark', open: '(?:', close: ')?' },\r\n\t      '+': { type: 'plus', open: '(?:', close: ')+' },\r\n\t      '*': { type: 'star', open: '(?:', close: ')*' },\r\n\t      '@': { type: 'at', open: '(?:', close: ')' }\r\n\t    };\r\n\t  },\r\n\r\n\t  /**\r\n\t   * Create GLOB_CHARS\r\n\t   */\r\n\r\n\t  globChars(win32) {\r\n\t    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\r\n\t  }\r\n\t};\r\n\treturn constants$3;\r\n}\r\n\r\nvar hasRequiredUtils$2;\r\n\r\nfunction requireUtils$2 () {\r\n\tif (hasRequiredUtils$2) return utils$2;\r\n\thasRequiredUtils$2 = 1;\r\n\t(function (exports) {\r\n\r\n\t\tconst path = require$$0$1;\r\n\t\tconst win32 = process.platform === 'win32';\r\n\t\tconst {\r\n\t\t  REGEX_BACKSLASH,\r\n\t\t  REGEX_REMOVE_BACKSLASH,\r\n\t\t  REGEX_SPECIAL_CHARS,\r\n\t\t  REGEX_SPECIAL_CHARS_GLOBAL\r\n\t\t} = /*@__PURE__*/ requireConstants$3();\r\n\r\n\t\texports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\r\n\t\texports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\r\n\t\texports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\r\n\t\texports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\r\n\t\texports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\r\n\r\n\t\texports.removeBackslashes = str => {\r\n\t\t  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\r\n\t\t    return match === '\\\\' ? '' : match;\r\n\t\t  });\r\n\t\t};\r\n\r\n\t\texports.supportsLookbehinds = () => {\r\n\t\t  const segs = process.version.slice(1).split('.').map(Number);\r\n\t\t  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\r\n\t\t    return true;\r\n\t\t  }\r\n\t\t  return false;\r\n\t\t};\r\n\r\n\t\texports.isWindows = options => {\r\n\t\t  if (options && typeof options.windows === 'boolean') {\r\n\t\t    return options.windows;\r\n\t\t  }\r\n\t\t  return win32 === true || path.sep === '\\\\';\r\n\t\t};\r\n\r\n\t\texports.escapeLast = (input, char, lastIdx) => {\r\n\t\t  const idx = input.lastIndexOf(char, lastIdx);\r\n\t\t  if (idx === -1) return input;\r\n\t\t  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\r\n\t\t  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\r\n\t\t};\r\n\r\n\t\texports.removePrefix = (input, state = {}) => {\r\n\t\t  let output = input;\r\n\t\t  if (output.startsWith('./')) {\r\n\t\t    output = output.slice(2);\r\n\t\t    state.prefix = './';\r\n\t\t  }\r\n\t\t  return output;\r\n\t\t};\r\n\r\n\t\texports.wrapOutput = (input, state = {}, options = {}) => {\r\n\t\t  const prepend = options.contains ? '' : '^';\r\n\t\t  const append = options.contains ? '' : '$';\r\n\r\n\t\t  let output = `${prepend}(?:${input})${append}`;\r\n\t\t  if (state.negated === true) {\r\n\t\t    output = `(?:^(?!${output}).*$)`;\r\n\t\t  }\r\n\t\t  return output;\r\n\t\t}; \r\n\t} (utils$2));\r\n\treturn utils$2;\r\n}\r\n\r\nvar scan_1$1;\r\nvar hasRequiredScan$1;\r\n\r\nfunction requireScan$1 () {\r\n\tif (hasRequiredScan$1) return scan_1$1;\r\n\thasRequiredScan$1 = 1;\r\n\r\n\tconst utils = /*@__PURE__*/ requireUtils$2();\r\n\tconst {\r\n\t  CHAR_ASTERISK,             /* * */\r\n\t  CHAR_AT,                   /* @ */\r\n\t  CHAR_BACKWARD_SLASH,       /* \\ */\r\n\t  CHAR_COMMA,                /* , */\r\n\t  CHAR_DOT,                  /* . */\r\n\t  CHAR_EXCLAMATION_MARK,     /* ! */\r\n\t  CHAR_FORWARD_SLASH,        /* / */\r\n\t  CHAR_LEFT_CURLY_BRACE,     /* { */\r\n\t  CHAR_LEFT_PARENTHESES,     /* ( */\r\n\t  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\r\n\t  CHAR_PLUS,                 /* + */\r\n\t  CHAR_QUESTION_MARK,        /* ? */\r\n\t  CHAR_RIGHT_CURLY_BRACE,    /* } */\r\n\t  CHAR_RIGHT_PARENTHESES,    /* ) */\r\n\t  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\r\n\t} = /*@__PURE__*/ requireConstants$3();\r\n\r\n\tconst isPathSeparator = code => {\r\n\t  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\r\n\t};\r\n\r\n\tconst depth = token => {\r\n\t  if (token.isPrefix !== true) {\r\n\t    token.depth = token.isGlobstar ? Infinity : 1;\r\n\t  }\r\n\t};\r\n\r\n\t/**\r\n\t * Quickly scans a glob pattern and returns an object with a handful of\r\n\t * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\r\n\t * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\r\n\t * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\r\n\t *\r\n\t * ```js\r\n\t * const pm = require('picomatch');\r\n\t * console.log(pm.scan('foo/bar/*.js'));\r\n\t * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\r\n\t * ```\r\n\t * @param {String} `str`\r\n\t * @param {Object} `options`\r\n\t * @return {Object} Returns an object with tokens and regex source string.\r\n\t * @api public\r\n\t */\r\n\r\n\tconst scan = (input, options) => {\r\n\t  const opts = options || {};\r\n\r\n\t  const length = input.length - 1;\r\n\t  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\r\n\t  const slashes = [];\r\n\t  const tokens = [];\r\n\t  const parts = [];\r\n\r\n\t  let str = input;\r\n\t  let index = -1;\r\n\t  let start = 0;\r\n\t  let lastIndex = 0;\r\n\t  let isBrace = false;\r\n\t  let isBracket = false;\r\n\t  let isGlob = false;\r\n\t  let isExtglob = false;\r\n\t  let isGlobstar = false;\r\n\t  let braceEscaped = false;\r\n\t  let backslashes = false;\r\n\t  let negated = false;\r\n\t  let negatedExtglob = false;\r\n\t  let finished = false;\r\n\t  let braces = 0;\r\n\t  let prev;\r\n\t  let code;\r\n\t  let token = { value: '', depth: 0, isGlob: false };\r\n\r\n\t  const eos = () => index >= length;\r\n\t  const peek = () => str.charCodeAt(index + 1);\r\n\t  const advance = () => {\r\n\t    prev = code;\r\n\t    return str.charCodeAt(++index);\r\n\t  };\r\n\r\n\t  while (index < length) {\r\n\t    code = advance();\r\n\t    let next;\r\n\r\n\t    if (code === CHAR_BACKWARD_SLASH) {\r\n\t      backslashes = token.backslashes = true;\r\n\t      code = advance();\r\n\r\n\t      if (code === CHAR_LEFT_CURLY_BRACE) {\r\n\t        braceEscaped = true;\r\n\t      }\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\r\n\t      braces++;\r\n\r\n\t      while (eos() !== true && (code = advance())) {\r\n\t        if (code === CHAR_BACKWARD_SLASH) {\r\n\t          backslashes = token.backslashes = true;\r\n\t          advance();\r\n\t          continue;\r\n\t        }\r\n\r\n\t        if (code === CHAR_LEFT_CURLY_BRACE) {\r\n\t          braces++;\r\n\t          continue;\r\n\t        }\r\n\r\n\t        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\r\n\t          isBrace = token.isBrace = true;\r\n\t          isGlob = token.isGlob = true;\r\n\t          finished = true;\r\n\r\n\t          if (scanToEnd === true) {\r\n\t            continue;\r\n\t          }\r\n\r\n\t          break;\r\n\t        }\r\n\r\n\t        if (braceEscaped !== true && code === CHAR_COMMA) {\r\n\t          isBrace = token.isBrace = true;\r\n\t          isGlob = token.isGlob = true;\r\n\t          finished = true;\r\n\r\n\t          if (scanToEnd === true) {\r\n\t            continue;\r\n\t          }\r\n\r\n\t          break;\r\n\t        }\r\n\r\n\t        if (code === CHAR_RIGHT_CURLY_BRACE) {\r\n\t          braces--;\r\n\r\n\t          if (braces === 0) {\r\n\t            braceEscaped = false;\r\n\t            isBrace = token.isBrace = true;\r\n\t            finished = true;\r\n\t            break;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (code === CHAR_FORWARD_SLASH) {\r\n\t      slashes.push(index);\r\n\t      tokens.push(token);\r\n\t      token = { value: '', depth: 0, isGlob: false };\r\n\r\n\t      if (finished === true) continue;\r\n\t      if (prev === CHAR_DOT && index === (start + 1)) {\r\n\t        start += 2;\r\n\t        continue;\r\n\t      }\r\n\r\n\t      lastIndex = index + 1;\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (opts.noext !== true) {\r\n\t      const isExtglobChar = code === CHAR_PLUS\r\n\t        || code === CHAR_AT\r\n\t        || code === CHAR_ASTERISK\r\n\t        || code === CHAR_QUESTION_MARK\r\n\t        || code === CHAR_EXCLAMATION_MARK;\r\n\r\n\t      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\r\n\t        isGlob = token.isGlob = true;\r\n\t        isExtglob = token.isExtglob = true;\r\n\t        finished = true;\r\n\t        if (code === CHAR_EXCLAMATION_MARK && index === start) {\r\n\t          negatedExtglob = true;\r\n\t        }\r\n\r\n\t        if (scanToEnd === true) {\r\n\t          while (eos() !== true && (code = advance())) {\r\n\t            if (code === CHAR_BACKWARD_SLASH) {\r\n\t              backslashes = token.backslashes = true;\r\n\t              code = advance();\r\n\t              continue;\r\n\t            }\r\n\r\n\t            if (code === CHAR_RIGHT_PARENTHESES) {\r\n\t              isGlob = token.isGlob = true;\r\n\t              finished = true;\r\n\t              break;\r\n\t            }\r\n\t          }\r\n\t          continue;\r\n\t        }\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    if (code === CHAR_ASTERISK) {\r\n\t      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\r\n\t      isGlob = token.isGlob = true;\r\n\t      finished = true;\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (code === CHAR_QUESTION_MARK) {\r\n\t      isGlob = token.isGlob = true;\r\n\t      finished = true;\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (code === CHAR_LEFT_SQUARE_BRACKET) {\r\n\t      while (eos() !== true && (next = advance())) {\r\n\t        if (next === CHAR_BACKWARD_SLASH) {\r\n\t          backslashes = token.backslashes = true;\r\n\t          advance();\r\n\t          continue;\r\n\t        }\r\n\r\n\t        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\r\n\t          isBracket = token.isBracket = true;\r\n\t          isGlob = token.isGlob = true;\r\n\t          finished = true;\r\n\t          break;\r\n\t        }\r\n\t      }\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\r\n\t      negated = token.negated = true;\r\n\t      start++;\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\r\n\t      isGlob = token.isGlob = true;\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        while (eos() !== true && (code = advance())) {\r\n\t          if (code === CHAR_LEFT_PARENTHESES) {\r\n\t            backslashes = token.backslashes = true;\r\n\t            code = advance();\r\n\t            continue;\r\n\t          }\r\n\r\n\t          if (code === CHAR_RIGHT_PARENTHESES) {\r\n\t            finished = true;\r\n\t            break;\r\n\t          }\r\n\t        }\r\n\t        continue;\r\n\t      }\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (isGlob === true) {\r\n\t      finished = true;\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\r\n\t  if (opts.noext === true) {\r\n\t    isExtglob = false;\r\n\t    isGlob = false;\r\n\t  }\r\n\r\n\t  let base = str;\r\n\t  let prefix = '';\r\n\t  let glob = '';\r\n\r\n\t  if (start > 0) {\r\n\t    prefix = str.slice(0, start);\r\n\t    str = str.slice(start);\r\n\t    lastIndex -= start;\r\n\t  }\r\n\r\n\t  if (base && isGlob === true && lastIndex > 0) {\r\n\t    base = str.slice(0, lastIndex);\r\n\t    glob = str.slice(lastIndex);\r\n\t  } else if (isGlob === true) {\r\n\t    base = '';\r\n\t    glob = str;\r\n\t  } else {\r\n\t    base = str;\r\n\t  }\r\n\r\n\t  if (base && base !== '' && base !== '/' && base !== str) {\r\n\t    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\r\n\t      base = base.slice(0, -1);\r\n\t    }\r\n\t  }\r\n\r\n\t  if (opts.unescape === true) {\r\n\t    if (glob) glob = utils.removeBackslashes(glob);\r\n\r\n\t    if (base && backslashes === true) {\r\n\t      base = utils.removeBackslashes(base);\r\n\t    }\r\n\t  }\r\n\r\n\t  const state = {\r\n\t    prefix,\r\n\t    input,\r\n\t    start,\r\n\t    base,\r\n\t    glob,\r\n\t    isBrace,\r\n\t    isBracket,\r\n\t    isGlob,\r\n\t    isExtglob,\r\n\t    isGlobstar,\r\n\t    negated,\r\n\t    negatedExtglob\r\n\t  };\r\n\r\n\t  if (opts.tokens === true) {\r\n\t    state.maxDepth = 0;\r\n\t    if (!isPathSeparator(code)) {\r\n\t      tokens.push(token);\r\n\t    }\r\n\t    state.tokens = tokens;\r\n\t  }\r\n\r\n\t  if (opts.parts === true || opts.tokens === true) {\r\n\t    let prevIndex;\r\n\r\n\t    for (let idx = 0; idx < slashes.length; idx++) {\r\n\t      const n = prevIndex ? prevIndex + 1 : start;\r\n\t      const i = slashes[idx];\r\n\t      const value = input.slice(n, i);\r\n\t      if (opts.tokens) {\r\n\t        if (idx === 0 && start !== 0) {\r\n\t          tokens[idx].isPrefix = true;\r\n\t          tokens[idx].value = prefix;\r\n\t        } else {\r\n\t          tokens[idx].value = value;\r\n\t        }\r\n\t        depth(tokens[idx]);\r\n\t        state.maxDepth += tokens[idx].depth;\r\n\t      }\r\n\t      if (idx !== 0 || value !== '') {\r\n\t        parts.push(value);\r\n\t      }\r\n\t      prevIndex = i;\r\n\t    }\r\n\r\n\t    if (prevIndex && prevIndex + 1 < input.length) {\r\n\t      const value = input.slice(prevIndex + 1);\r\n\t      parts.push(value);\r\n\r\n\t      if (opts.tokens) {\r\n\t        tokens[tokens.length - 1].value = value;\r\n\t        depth(tokens[tokens.length - 1]);\r\n\t        state.maxDepth += tokens[tokens.length - 1].depth;\r\n\t      }\r\n\t    }\r\n\r\n\t    state.slashes = slashes;\r\n\t    state.parts = parts;\r\n\t  }\r\n\r\n\t  return state;\r\n\t};\r\n\r\n\tscan_1$1 = scan;\r\n\treturn scan_1$1;\r\n}\r\n\r\nvar parse_1$2;\r\nvar hasRequiredParse$2;\r\n\r\nfunction requireParse$2 () {\r\n\tif (hasRequiredParse$2) return parse_1$2;\r\n\thasRequiredParse$2 = 1;\r\n\r\n\tconst constants = /*@__PURE__*/ requireConstants$3();\r\n\tconst utils = /*@__PURE__*/ requireUtils$2();\r\n\r\n\t/**\r\n\t * Constants\r\n\t */\r\n\r\n\tconst {\r\n\t  MAX_LENGTH,\r\n\t  POSIX_REGEX_SOURCE,\r\n\t  REGEX_NON_SPECIAL_CHARS,\r\n\t  REGEX_SPECIAL_CHARS_BACKREF,\r\n\t  REPLACEMENTS\r\n\t} = constants;\r\n\r\n\t/**\r\n\t * Helpers\r\n\t */\r\n\r\n\tconst expandRange = (args, options) => {\r\n\t  if (typeof options.expandRange === 'function') {\r\n\t    return options.expandRange(...args, options);\r\n\t  }\r\n\r\n\t  args.sort();\r\n\t  const value = `[${args.join('-')}]`;\r\n\r\n\t  return value;\r\n\t};\r\n\r\n\t/**\r\n\t * Create the message for a syntax error\r\n\t */\r\n\r\n\tconst syntaxError = (type, char) => {\r\n\t  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\r\n\t};\r\n\r\n\t/**\r\n\t * Parse the given input string.\r\n\t * @param {String} input\r\n\t * @param {Object} options\r\n\t * @return {Object}\r\n\t */\r\n\r\n\tconst parse = (input, options) => {\r\n\t  if (typeof input !== 'string') {\r\n\t    throw new TypeError('Expected a string');\r\n\t  }\r\n\r\n\t  input = REPLACEMENTS[input] || input;\r\n\r\n\t  const opts = { ...options };\r\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\r\n\r\n\t  let len = input.length;\r\n\t  if (len > max) {\r\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\r\n\t  }\r\n\r\n\t  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\r\n\t  const tokens = [bos];\r\n\r\n\t  const capture = opts.capture ? '' : '?:';\r\n\t  const win32 = utils.isWindows(options);\r\n\r\n\t  // create constants based on platform, for windows or posix\r\n\t  const PLATFORM_CHARS = constants.globChars(win32);\r\n\t  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\r\n\r\n\t  const {\r\n\t    DOT_LITERAL,\r\n\t    PLUS_LITERAL,\r\n\t    SLASH_LITERAL,\r\n\t    ONE_CHAR,\r\n\t    DOTS_SLASH,\r\n\t    NO_DOT,\r\n\t    NO_DOT_SLASH,\r\n\t    NO_DOTS_SLASH,\r\n\t    QMARK,\r\n\t    QMARK_NO_DOT,\r\n\t    STAR,\r\n\t    START_ANCHOR\r\n\t  } = PLATFORM_CHARS;\r\n\r\n\t  const globstar = opts => {\r\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\r\n\t  };\r\n\r\n\t  const nodot = opts.dot ? '' : NO_DOT;\r\n\t  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\r\n\t  let star = opts.bash === true ? globstar(opts) : STAR;\r\n\r\n\t  if (opts.capture) {\r\n\t    star = `(${star})`;\r\n\t  }\r\n\r\n\t  // minimatch options support\r\n\t  if (typeof opts.noext === 'boolean') {\r\n\t    opts.noextglob = opts.noext;\r\n\t  }\r\n\r\n\t  const state = {\r\n\t    input,\r\n\t    index: -1,\r\n\t    start: 0,\r\n\t    dot: opts.dot === true,\r\n\t    consumed: '',\r\n\t    output: '',\r\n\t    prefix: '',\r\n\t    backtrack: false,\r\n\t    negated: false,\r\n\t    brackets: 0,\r\n\t    braces: 0,\r\n\t    parens: 0,\r\n\t    quotes: 0,\r\n\t    globstar: false,\r\n\t    tokens\r\n\t  };\r\n\r\n\t  input = utils.removePrefix(input, state);\r\n\t  len = input.length;\r\n\r\n\t  const extglobs = [];\r\n\t  const braces = [];\r\n\t  const stack = [];\r\n\t  let prev = bos;\r\n\t  let value;\r\n\r\n\t  /**\r\n\t   * Tokenizing helpers\r\n\t   */\r\n\r\n\t  const eos = () => state.index === len - 1;\r\n\t  const peek = state.peek = (n = 1) => input[state.index + n];\r\n\t  const advance = state.advance = () => input[++state.index] || '';\r\n\t  const remaining = () => input.slice(state.index + 1);\r\n\t  const consume = (value = '', num = 0) => {\r\n\t    state.consumed += value;\r\n\t    state.index += num;\r\n\t  };\r\n\r\n\t  const append = token => {\r\n\t    state.output += token.output != null ? token.output : token.value;\r\n\t    consume(token.value);\r\n\t  };\r\n\r\n\t  const negate = () => {\r\n\t    let count = 1;\r\n\r\n\t    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\r\n\t      advance();\r\n\t      state.start++;\r\n\t      count++;\r\n\t    }\r\n\r\n\t    if (count % 2 === 0) {\r\n\t      return false;\r\n\t    }\r\n\r\n\t    state.negated = true;\r\n\t    state.start++;\r\n\t    return true;\r\n\t  };\r\n\r\n\t  const increment = type => {\r\n\t    state[type]++;\r\n\t    stack.push(type);\r\n\t  };\r\n\r\n\t  const decrement = type => {\r\n\t    state[type]--;\r\n\t    stack.pop();\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Push tokens onto the tokens array. This helper speeds up\r\n\t   * tokenizing by 1) helping us avoid backtracking as much as possible,\r\n\t   * and 2) helping us avoid creating extra tokens when consecutive\r\n\t   * characters are plain text. This improves performance and simplifies\r\n\t   * lookbehinds.\r\n\t   */\r\n\r\n\t  const push = tok => {\r\n\t    if (prev.type === 'globstar') {\r\n\t      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\r\n\t      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\r\n\r\n\t      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\r\n\t        state.output = state.output.slice(0, -prev.output.length);\r\n\t        prev.type = 'star';\r\n\t        prev.value = '*';\r\n\t        prev.output = star;\r\n\t        state.output += prev.output;\r\n\t      }\r\n\t    }\r\n\r\n\t    if (extglobs.length && tok.type !== 'paren') {\r\n\t      extglobs[extglobs.length - 1].inner += tok.value;\r\n\t    }\r\n\r\n\t    if (tok.value || tok.output) append(tok);\r\n\t    if (prev && prev.type === 'text' && tok.type === 'text') {\r\n\t      prev.value += tok.value;\r\n\t      prev.output = (prev.output || '') + tok.value;\r\n\t      return;\r\n\t    }\r\n\r\n\t    tok.prev = prev;\r\n\t    tokens.push(tok);\r\n\t    prev = tok;\r\n\t  };\r\n\r\n\t  const extglobOpen = (type, value) => {\r\n\t    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\r\n\r\n\t    token.prev = prev;\r\n\t    token.parens = state.parens;\r\n\t    token.output = state.output;\r\n\t    const output = (opts.capture ? '(' : '') + token.open;\r\n\r\n\t    increment('parens');\r\n\t    push({ type, value, output: state.output ? '' : ONE_CHAR });\r\n\t    push({ type: 'paren', extglob: true, value: advance(), output });\r\n\t    extglobs.push(token);\r\n\t  };\r\n\r\n\t  const extglobClose = token => {\r\n\t    let output = token.close + (opts.capture ? ')' : '');\r\n\t    let rest;\r\n\r\n\t    if (token.type === 'negate') {\r\n\t      let extglobStar = star;\r\n\r\n\t      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\r\n\t        extglobStar = globstar(opts);\r\n\t      }\r\n\r\n\t      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\r\n\t        output = token.close = `)$))${extglobStar}`;\r\n\t      }\r\n\r\n\t      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\r\n\t        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\r\n\t        // In this case, we need to parse the string and use it in the output of the original pattern.\r\n\t        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\r\n\t        //\r\n\t        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\r\n\t        const expression = parse(rest, { ...options, fastpaths: false }).output;\r\n\r\n\t        output = token.close = `)${expression})${extglobStar})`;\r\n\t      }\r\n\r\n\t      if (token.prev.type === 'bos') {\r\n\t        state.negatedExtglob = true;\r\n\t      }\r\n\t    }\r\n\r\n\t    push({ type: 'paren', extglob: true, value, output });\r\n\t    decrement('parens');\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Fast paths\r\n\t   */\r\n\r\n\t  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\r\n\t    let backslashes = false;\r\n\r\n\t    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\r\n\t      if (first === '\\\\') {\r\n\t        backslashes = true;\r\n\t        return m;\r\n\t      }\r\n\r\n\t      if (first === '?') {\r\n\t        if (esc) {\r\n\t          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\r\n\t        }\r\n\t        if (index === 0) {\r\n\t          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\r\n\t        }\r\n\t        return QMARK.repeat(chars.length);\r\n\t      }\r\n\r\n\t      if (first === '.') {\r\n\t        return DOT_LITERAL.repeat(chars.length);\r\n\t      }\r\n\r\n\t      if (first === '*') {\r\n\t        if (esc) {\r\n\t          return esc + first + (rest ? star : '');\r\n\t        }\r\n\t        return star;\r\n\t      }\r\n\t      return esc ? m : `\\\\${m}`;\r\n\t    });\r\n\r\n\t    if (backslashes === true) {\r\n\t      if (opts.unescape === true) {\r\n\t        output = output.replace(/\\\\/g, '');\r\n\t      } else {\r\n\t        output = output.replace(/\\\\+/g, m => {\r\n\t          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\r\n\t        });\r\n\t      }\r\n\t    }\r\n\r\n\t    if (output === input && opts.contains === true) {\r\n\t      state.output = input;\r\n\t      return state;\r\n\t    }\r\n\r\n\t    state.output = utils.wrapOutput(output, state, options);\r\n\t    return state;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Tokenize input until we reach end-of-string\r\n\t   */\r\n\r\n\t  while (!eos()) {\r\n\t    value = advance();\r\n\r\n\t    if (value === '\\u0000') {\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Escaped characters\r\n\t     */\r\n\r\n\t    if (value === '\\\\') {\r\n\t      const next = peek();\r\n\r\n\t      if (next === '/' && opts.bash !== true) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (next === '.' || next === ';') {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (!next) {\r\n\t        value += '\\\\';\r\n\t        push({ type: 'text', value });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      // collapse slashes to reduce potential for exploits\r\n\t      const match = /^\\\\+/.exec(remaining());\r\n\t      let slashes = 0;\r\n\r\n\t      if (match && match[0].length > 2) {\r\n\t        slashes = match[0].length;\r\n\t        state.index += slashes;\r\n\t        if (slashes % 2 !== 0) {\r\n\t          value += '\\\\';\r\n\t        }\r\n\t      }\r\n\r\n\t      if (opts.unescape === true) {\r\n\t        value = advance();\r\n\t      } else {\r\n\t        value += advance();\r\n\t      }\r\n\r\n\t      if (state.brackets === 0) {\r\n\t        push({ type: 'text', value });\r\n\t        continue;\r\n\t      }\r\n\t    }\r\n\r\n\t    /**\r\n\t     * If we're inside a regex character class, continue\r\n\t     * until we reach the closing bracket.\r\n\t     */\r\n\r\n\t    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\r\n\t      if (opts.posix !== false && value === ':') {\r\n\t        const inner = prev.value.slice(1);\r\n\t        if (inner.includes('[')) {\r\n\t          prev.posix = true;\r\n\r\n\t          if (inner.includes(':')) {\r\n\t            const idx = prev.value.lastIndexOf('[');\r\n\t            const pre = prev.value.slice(0, idx);\r\n\t            const rest = prev.value.slice(idx + 2);\r\n\t            const posix = POSIX_REGEX_SOURCE[rest];\r\n\t            if (posix) {\r\n\t              prev.value = pre + posix;\r\n\t              state.backtrack = true;\r\n\t              advance();\r\n\r\n\t              if (!bos.output && tokens.indexOf(prev) === 1) {\r\n\t                bos.output = ONE_CHAR;\r\n\t              }\r\n\t              continue;\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\r\n\t      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\r\n\t        value = `\\\\${value}`;\r\n\t      }\r\n\r\n\t      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\r\n\t        value = `\\\\${value}`;\r\n\t      }\r\n\r\n\t      if (opts.posix === true && value === '!' && prev.value === '[') {\r\n\t        value = '^';\r\n\t      }\r\n\r\n\t      prev.value += value;\r\n\t      append({ value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * If we're inside a quoted string, continue\r\n\t     * until we reach the closing double quote.\r\n\t     */\r\n\r\n\t    if (state.quotes === 1 && value !== '\"') {\r\n\t      value = utils.escapeRegex(value);\r\n\t      prev.value += value;\r\n\t      append({ value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Double quotes\r\n\t     */\r\n\r\n\t    if (value === '\"') {\r\n\t      state.quotes = state.quotes === 1 ? 0 : 1;\r\n\t      if (opts.keepQuotes === true) {\r\n\t        push({ type: 'text', value });\r\n\t      }\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Parentheses\r\n\t     */\r\n\r\n\t    if (value === '(') {\r\n\t      increment('parens');\r\n\t      push({ type: 'paren', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (value === ')') {\r\n\t      if (state.parens === 0 && opts.strictBrackets === true) {\r\n\t        throw new SyntaxError(syntaxError('opening', '('));\r\n\t      }\r\n\r\n\t      const extglob = extglobs[extglobs.length - 1];\r\n\t      if (extglob && state.parens === extglob.parens + 1) {\r\n\t        extglobClose(extglobs.pop());\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\r\n\t      decrement('parens');\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Square brackets\r\n\t     */\r\n\r\n\t    if (value === '[') {\r\n\t      if (opts.nobracket === true || !remaining().includes(']')) {\r\n\t        if (opts.nobracket !== true && opts.strictBrackets === true) {\r\n\t          throw new SyntaxError(syntaxError('closing', ']'));\r\n\t        }\r\n\r\n\t        value = `\\\\${value}`;\r\n\t      } else {\r\n\t        increment('brackets');\r\n\t      }\r\n\r\n\t      push({ type: 'bracket', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (value === ']') {\r\n\t      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\r\n\t        push({ type: 'text', value, output: `\\\\${value}` });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (state.brackets === 0) {\r\n\t        if (opts.strictBrackets === true) {\r\n\t          throw new SyntaxError(syntaxError('opening', '['));\r\n\t        }\r\n\r\n\t        push({ type: 'text', value, output: `\\\\${value}` });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      decrement('brackets');\r\n\r\n\t      const prevValue = prev.value.slice(1);\r\n\t      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\r\n\t        value = `/${value}`;\r\n\t      }\r\n\r\n\t      prev.value += value;\r\n\t      append({ value });\r\n\r\n\t      // when literal brackets are explicitly disabled\r\n\t      // assume we should match with a regex character class\r\n\t      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      const escaped = utils.escapeRegex(prev.value);\r\n\t      state.output = state.output.slice(0, -prev.value.length);\r\n\r\n\t      // when literal brackets are explicitly enabled\r\n\t      // assume we should escape the brackets to match literal characters\r\n\t      if (opts.literalBrackets === true) {\r\n\t        state.output += escaped;\r\n\t        prev.value = escaped;\r\n\t        continue;\r\n\t      }\r\n\r\n\t      // when the user specifies nothing, try to match both\r\n\t      prev.value = `(${capture}${escaped}|${prev.value})`;\r\n\t      state.output += prev.value;\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Braces\r\n\t     */\r\n\r\n\t    if (value === '{' && opts.nobrace !== true) {\r\n\t      increment('braces');\r\n\r\n\t      const open = {\r\n\t        type: 'brace',\r\n\t        value,\r\n\t        output: '(',\r\n\t        outputIndex: state.output.length,\r\n\t        tokensIndex: state.tokens.length\r\n\t      };\r\n\r\n\t      braces.push(open);\r\n\t      push(open);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (value === '}') {\r\n\t      const brace = braces[braces.length - 1];\r\n\r\n\t      if (opts.nobrace === true || !brace) {\r\n\t        push({ type: 'text', value, output: value });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      let output = ')';\r\n\r\n\t      if (brace.dots === true) {\r\n\t        const arr = tokens.slice();\r\n\t        const range = [];\r\n\r\n\t        for (let i = arr.length - 1; i >= 0; i--) {\r\n\t          tokens.pop();\r\n\t          if (arr[i].type === 'brace') {\r\n\t            break;\r\n\t          }\r\n\t          if (arr[i].type !== 'dots') {\r\n\t            range.unshift(arr[i].value);\r\n\t          }\r\n\t        }\r\n\r\n\t        output = expandRange(range, opts);\r\n\t        state.backtrack = true;\r\n\t      }\r\n\r\n\t      if (brace.comma !== true && brace.dots !== true) {\r\n\t        const out = state.output.slice(0, brace.outputIndex);\r\n\t        const toks = state.tokens.slice(brace.tokensIndex);\r\n\t        brace.value = brace.output = '\\\\{';\r\n\t        value = output = '\\\\}';\r\n\t        state.output = out;\r\n\t        for (const t of toks) {\r\n\t          state.output += (t.output || t.value);\r\n\t        }\r\n\t      }\r\n\r\n\t      push({ type: 'brace', value, output });\r\n\t      decrement('braces');\r\n\t      braces.pop();\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Pipes\r\n\t     */\r\n\r\n\t    if (value === '|') {\r\n\t      if (extglobs.length > 0) {\r\n\t        extglobs[extglobs.length - 1].conditions++;\r\n\t      }\r\n\t      push({ type: 'text', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Commas\r\n\t     */\r\n\r\n\t    if (value === ',') {\r\n\t      let output = value;\r\n\r\n\t      const brace = braces[braces.length - 1];\r\n\t      if (brace && stack[stack.length - 1] === 'braces') {\r\n\t        brace.comma = true;\r\n\t        output = '|';\r\n\t      }\r\n\r\n\t      push({ type: 'comma', value, output });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Slashes\r\n\t     */\r\n\r\n\t    if (value === '/') {\r\n\t      // if the beginning of the glob is \"./\", advance the start\r\n\t      // to the current index, and don't add the \"./\" characters\r\n\t      // to the state. This greatly simplifies lookbehinds when\r\n\t      // checking for BOS characters like \"!\" and \".\" (not \"./\")\r\n\t      if (prev.type === 'dot' && state.index === state.start + 1) {\r\n\t        state.start = state.index + 1;\r\n\t        state.consumed = '';\r\n\t        state.output = '';\r\n\t        tokens.pop();\r\n\t        prev = bos; // reset \"prev\" to the first token\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'slash', value, output: SLASH_LITERAL });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Dots\r\n\t     */\r\n\r\n\t    if (value === '.') {\r\n\t      if (state.braces > 0 && prev.type === 'dot') {\r\n\t        if (prev.value === '.') prev.output = DOT_LITERAL;\r\n\t        const brace = braces[braces.length - 1];\r\n\t        prev.type = 'dots';\r\n\t        prev.output += value;\r\n\t        prev.value += value;\r\n\t        brace.dots = true;\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\r\n\t        push({ type: 'text', value, output: DOT_LITERAL });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'dot', value, output: DOT_LITERAL });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Question marks\r\n\t     */\r\n\r\n\t    if (value === '?') {\r\n\t      const isGroup = prev && prev.value === '(';\r\n\t      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\r\n\t        extglobOpen('qmark', value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prev && prev.type === 'paren') {\r\n\t        const next = peek();\r\n\t        let output = value;\r\n\r\n\t        if (next === '<' && !utils.supportsLookbehinds()) {\r\n\t          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\r\n\t        }\r\n\r\n\t        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\r\n\t          output = `\\\\${value}`;\r\n\t        }\r\n\r\n\t        push({ type: 'text', value, output });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\r\n\t        push({ type: 'qmark', value, output: QMARK_NO_DOT });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'qmark', value, output: QMARK });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Exclamation\r\n\t     */\r\n\r\n\t    if (value === '!') {\r\n\t      if (opts.noextglob !== true && peek() === '(') {\r\n\t        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\r\n\t          extglobOpen('negate', value);\r\n\t          continue;\r\n\t        }\r\n\t      }\r\n\r\n\t      if (opts.nonegate !== true && state.index === 0) {\r\n\t        negate();\r\n\t        continue;\r\n\t      }\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Plus\r\n\t     */\r\n\r\n\t    if (value === '+') {\r\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\r\n\t        extglobOpen('plus', value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if ((prev && prev.value === '(') || opts.regex === false) {\r\n\t        push({ type: 'plus', value, output: PLUS_LITERAL });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\r\n\t        push({ type: 'plus', value });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'plus', value: PLUS_LITERAL });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Plain text\r\n\t     */\r\n\r\n\t    if (value === '@') {\r\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\r\n\t        push({ type: 'at', extglob: true, value, output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'text', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Plain text\r\n\t     */\r\n\r\n\t    if (value !== '*') {\r\n\t      if (value === '$' || value === '^') {\r\n\t        value = `\\\\${value}`;\r\n\t      }\r\n\r\n\t      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\r\n\t      if (match) {\r\n\t        value += match[0];\r\n\t        state.index += match[0].length;\r\n\t      }\r\n\r\n\t      push({ type: 'text', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Stars\r\n\t     */\r\n\r\n\t    if (prev && (prev.type === 'globstar' || prev.star === true)) {\r\n\t      prev.type = 'star';\r\n\t      prev.star = true;\r\n\t      prev.value += value;\r\n\t      prev.output = star;\r\n\t      state.backtrack = true;\r\n\t      state.globstar = true;\r\n\t      consume(value);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    let rest = remaining();\r\n\t    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\r\n\t      extglobOpen('star', value);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (prev.type === 'star') {\r\n\t      if (opts.noglobstar === true) {\r\n\t        consume(value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      const prior = prev.prev;\r\n\t      const before = prior.prev;\r\n\t      const isStart = prior.type === 'slash' || prior.type === 'bos';\r\n\t      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\r\n\r\n\t      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\r\n\t        push({ type: 'star', value, output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\r\n\t      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\r\n\t      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\r\n\t        push({ type: 'star', value, output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      // strip consecutive `/**/`\r\n\t      while (rest.slice(0, 3) === '/**') {\r\n\t        const after = input[state.index + 4];\r\n\t        if (after && after !== '/') {\r\n\t          break;\r\n\t        }\r\n\t        rest = rest.slice(3);\r\n\t        consume('/**', 3);\r\n\t      }\r\n\r\n\t      if (prior.type === 'bos' && eos()) {\r\n\t        prev.type = 'globstar';\r\n\t        prev.value += value;\r\n\t        prev.output = globstar(opts);\r\n\t        state.output = prev.output;\r\n\t        state.globstar = true;\r\n\t        consume(value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\r\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\r\n\t        prior.output = `(?:${prior.output}`;\r\n\r\n\t        prev.type = 'globstar';\r\n\t        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\r\n\t        prev.value += value;\r\n\t        state.globstar = true;\r\n\t        state.output += prior.output + prev.output;\r\n\t        consume(value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\r\n\t        const end = rest[1] !== void 0 ? '|$' : '';\r\n\r\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\r\n\t        prior.output = `(?:${prior.output}`;\r\n\r\n\t        prev.type = 'globstar';\r\n\t        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\r\n\t        prev.value += value;\r\n\r\n\t        state.output += prior.output + prev.output;\r\n\t        state.globstar = true;\r\n\r\n\t        consume(value + advance());\r\n\r\n\t        push({ type: 'slash', value: '/', output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prior.type === 'bos' && rest[0] === '/') {\r\n\t        prev.type = 'globstar';\r\n\t        prev.value += value;\r\n\t        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\r\n\t        state.output = prev.output;\r\n\t        state.globstar = true;\r\n\t        consume(value + advance());\r\n\t        push({ type: 'slash', value: '/', output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      // remove single star from output\r\n\t      state.output = state.output.slice(0, -prev.output.length);\r\n\r\n\t      // reset previous token to globstar\r\n\t      prev.type = 'globstar';\r\n\t      prev.output = globstar(opts);\r\n\t      prev.value += value;\r\n\r\n\t      // reset output with globstar\r\n\t      state.output += prev.output;\r\n\t      state.globstar = true;\r\n\t      consume(value);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    const token = { type: 'star', value, output: star };\r\n\r\n\t    if (opts.bash === true) {\r\n\t      token.output = '.*?';\r\n\t      if (prev.type === 'bos' || prev.type === 'slash') {\r\n\t        token.output = nodot + token.output;\r\n\t      }\r\n\t      push(token);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\r\n\t      token.output = value;\r\n\t      push(token);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\r\n\t      if (prev.type === 'dot') {\r\n\t        state.output += NO_DOT_SLASH;\r\n\t        prev.output += NO_DOT_SLASH;\r\n\r\n\t      } else if (opts.dot === true) {\r\n\t        state.output += NO_DOTS_SLASH;\r\n\t        prev.output += NO_DOTS_SLASH;\r\n\r\n\t      } else {\r\n\t        state.output += nodot;\r\n\t        prev.output += nodot;\r\n\t      }\r\n\r\n\t      if (peek() !== '*') {\r\n\t        state.output += ONE_CHAR;\r\n\t        prev.output += ONE_CHAR;\r\n\t      }\r\n\t    }\r\n\r\n\t    push(token);\r\n\t  }\r\n\r\n\t  while (state.brackets > 0) {\r\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\r\n\t    state.output = utils.escapeLast(state.output, '[');\r\n\t    decrement('brackets');\r\n\t  }\r\n\r\n\t  while (state.parens > 0) {\r\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\r\n\t    state.output = utils.escapeLast(state.output, '(');\r\n\t    decrement('parens');\r\n\t  }\r\n\r\n\t  while (state.braces > 0) {\r\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\r\n\t    state.output = utils.escapeLast(state.output, '{');\r\n\t    decrement('braces');\r\n\t  }\r\n\r\n\t  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\r\n\t    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\r\n\t  }\r\n\r\n\t  // rebuild the output if we had to backtrack at any point\r\n\t  if (state.backtrack === true) {\r\n\t    state.output = '';\r\n\r\n\t    for (const token of state.tokens) {\r\n\t      state.output += token.output != null ? token.output : token.value;\r\n\r\n\t      if (token.suffix) {\r\n\t        state.output += token.suffix;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  return state;\r\n\t};\r\n\r\n\t/**\r\n\t * Fast paths for creating regular expressions for common glob patterns.\r\n\t * This can significantly speed up processing and has very little downside\r\n\t * impact when none of the fast paths match.\r\n\t */\r\n\r\n\tparse.fastpaths = (input, options) => {\r\n\t  const opts = { ...options };\r\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\r\n\t  const len = input.length;\r\n\t  if (len > max) {\r\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\r\n\t  }\r\n\r\n\t  input = REPLACEMENTS[input] || input;\r\n\t  const win32 = utils.isWindows(options);\r\n\r\n\t  // create constants based on platform, for windows or posix\r\n\t  const {\r\n\t    DOT_LITERAL,\r\n\t    SLASH_LITERAL,\r\n\t    ONE_CHAR,\r\n\t    DOTS_SLASH,\r\n\t    NO_DOT,\r\n\t    NO_DOTS,\r\n\t    NO_DOTS_SLASH,\r\n\t    STAR,\r\n\t    START_ANCHOR\r\n\t  } = constants.globChars(win32);\r\n\r\n\t  const nodot = opts.dot ? NO_DOTS : NO_DOT;\r\n\t  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\r\n\t  const capture = opts.capture ? '' : '?:';\r\n\t  const state = { negated: false, prefix: '' };\r\n\t  let star = opts.bash === true ? '.*?' : STAR;\r\n\r\n\t  if (opts.capture) {\r\n\t    star = `(${star})`;\r\n\t  }\r\n\r\n\t  const globstar = opts => {\r\n\t    if (opts.noglobstar === true) return star;\r\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\r\n\t  };\r\n\r\n\t  const create = str => {\r\n\t    switch (str) {\r\n\t      case '*':\r\n\t        return `${nodot}${ONE_CHAR}${star}`;\r\n\r\n\t      case '.*':\r\n\t        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n\t      case '*.*':\r\n\t        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n\t      case '*/*':\r\n\t        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\r\n\r\n\t      case '**':\r\n\t        return nodot + globstar(opts);\r\n\r\n\t      case '**/*':\r\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\r\n\r\n\t      case '**/*.*':\r\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n\t      case '**/.*':\r\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n\t      default: {\r\n\t        const match = /^(.*?)\\.(\\w+)$/.exec(str);\r\n\t        if (!match) return;\r\n\r\n\t        const source = create(match[1]);\r\n\t        if (!source) return;\r\n\r\n\t        return source + DOT_LITERAL + match[2];\r\n\t      }\r\n\t    }\r\n\t  };\r\n\r\n\t  const output = utils.removePrefix(input, state);\r\n\t  let source = create(output);\r\n\r\n\t  if (source && opts.strictSlashes !== true) {\r\n\t    source += `${SLASH_LITERAL}?`;\r\n\t  }\r\n\r\n\t  return source;\r\n\t};\r\n\r\n\tparse_1$2 = parse;\r\n\treturn parse_1$2;\r\n}\r\n\r\nvar picomatch_1$1;\r\nvar hasRequiredPicomatch$3;\r\n\r\nfunction requirePicomatch$3 () {\r\n\tif (hasRequiredPicomatch$3) return picomatch_1$1;\r\n\thasRequiredPicomatch$3 = 1;\r\n\r\n\tconst path = require$$0$1;\r\n\tconst scan = /*@__PURE__*/ requireScan$1();\r\n\tconst parse = /*@__PURE__*/ requireParse$2();\r\n\tconst utils = /*@__PURE__*/ requireUtils$2();\r\n\tconst constants = /*@__PURE__*/ requireConstants$3();\r\n\tconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\r\n\r\n\t/**\r\n\t * Creates a matcher function from one or more glob patterns. The\r\n\t * returned function takes a string to match as its first argument,\r\n\t * and returns true if the string is a match. The returned matcher\r\n\t * function also takes a boolean as the second argument that, when true,\r\n\t * returns an object with additional information.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch(glob[, options]);\r\n\t *\r\n\t * const isMatch = picomatch('*.!(*a)');\r\n\t * console.log(isMatch('a.a')); //=> false\r\n\t * console.log(isMatch('a.b')); //=> true\r\n\t * ```\r\n\t * @name picomatch\r\n\t * @param {String|Array} `globs` One or more glob patterns.\r\n\t * @param {Object=} `options`\r\n\t * @return {Function=} Returns a matcher function.\r\n\t * @api public\r\n\t */\r\n\r\n\tconst picomatch = (glob, options, returnState = false) => {\r\n\t  if (Array.isArray(glob)) {\r\n\t    const fns = glob.map(input => picomatch(input, options, returnState));\r\n\t    const arrayMatcher = str => {\r\n\t      for (const isMatch of fns) {\r\n\t        const state = isMatch(str);\r\n\t        if (state) return state;\r\n\t      }\r\n\t      return false;\r\n\t    };\r\n\t    return arrayMatcher;\r\n\t  }\r\n\r\n\t  const isState = isObject(glob) && glob.tokens && glob.input;\r\n\r\n\t  if (glob === '' || (typeof glob !== 'string' && !isState)) {\r\n\t    throw new TypeError('Expected pattern to be a non-empty string');\r\n\t  }\r\n\r\n\t  const opts = options || {};\r\n\t  const posix = utils.isWindows(options);\r\n\t  const regex = isState\r\n\t    ? picomatch.compileRe(glob, options)\r\n\t    : picomatch.makeRe(glob, options, false, true);\r\n\r\n\t  const state = regex.state;\r\n\t  delete regex.state;\r\n\r\n\t  let isIgnored = () => false;\r\n\t  if (opts.ignore) {\r\n\t    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\r\n\t    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\r\n\t  }\r\n\r\n\t  const matcher = (input, returnObject = false) => {\r\n\t    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\r\n\t    const result = { glob, state, regex, posix, input, output, match, isMatch };\r\n\r\n\t    if (typeof opts.onResult === 'function') {\r\n\t      opts.onResult(result);\r\n\t    }\r\n\r\n\t    if (isMatch === false) {\r\n\t      result.isMatch = false;\r\n\t      return returnObject ? result : false;\r\n\t    }\r\n\r\n\t    if (isIgnored(input)) {\r\n\t      if (typeof opts.onIgnore === 'function') {\r\n\t        opts.onIgnore(result);\r\n\t      }\r\n\t      result.isMatch = false;\r\n\t      return returnObject ? result : false;\r\n\t    }\r\n\r\n\t    if (typeof opts.onMatch === 'function') {\r\n\t      opts.onMatch(result);\r\n\t    }\r\n\t    return returnObject ? result : true;\r\n\t  };\r\n\r\n\t  if (returnState) {\r\n\t    matcher.state = state;\r\n\t  }\r\n\r\n\t  return matcher;\r\n\t};\r\n\r\n\t/**\r\n\t * Test `input` with the given `regex`. This is used by the main\r\n\t * `picomatch()` function to test the input string.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.test(input, regex[, options]);\r\n\t *\r\n\t * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\r\n\t * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\r\n\t * ```\r\n\t * @param {String} `input` String to test.\r\n\t * @param {RegExp} `regex`\r\n\t * @return {Object} Returns an object with matching info.\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.test = (input, regex, options, { glob, posix } = {}) => {\r\n\t  if (typeof input !== 'string') {\r\n\t    throw new TypeError('Expected input to be a string');\r\n\t  }\r\n\r\n\t  if (input === '') {\r\n\t    return { isMatch: false, output: '' };\r\n\t  }\r\n\r\n\t  const opts = options || {};\r\n\t  const format = opts.format || (posix ? utils.toPosixSlashes : null);\r\n\t  let match = input === glob;\r\n\t  let output = (match && format) ? format(input) : input;\r\n\r\n\t  if (match === false) {\r\n\t    output = format ? format(input) : input;\r\n\t    match = output === glob;\r\n\t  }\r\n\r\n\t  if (match === false || opts.capture === true) {\r\n\t    if (opts.matchBase === true || opts.basename === true) {\r\n\t      match = picomatch.matchBase(input, regex, options, posix);\r\n\t    } else {\r\n\t      match = regex.exec(output);\r\n\t    }\r\n\t  }\r\n\r\n\t  return { isMatch: Boolean(match), match, output };\r\n\t};\r\n\r\n\t/**\r\n\t * Match the basename of a filepath.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.matchBase(input, glob[, options]);\r\n\t * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\r\n\t * ```\r\n\t * @param {String} `input` String to test.\r\n\t * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\r\n\t * @return {Boolean}\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\r\n\t  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\r\n\t  return regex.test(path.basename(input));\r\n\t};\r\n\r\n\t/**\r\n\t * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.isMatch(string, patterns[, options]);\r\n\t *\r\n\t * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n\t * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\r\n\t * ```\r\n\t * @param {String|Array} str The string to test.\r\n\t * @param {String|Array} patterns One or more glob patterns to use for matching.\r\n\t * @param {Object} [options] See available [options](#options).\r\n\t * @return {Boolean} Returns true if any patterns match `str`\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\r\n\r\n\t/**\r\n\t * Parse a glob pattern to create the source string for a regular\r\n\t * expression.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * const result = picomatch.parse(pattern[, options]);\r\n\t * ```\r\n\t * @param {String} `pattern`\r\n\t * @param {Object} `options`\r\n\t * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.parse = (pattern, options) => {\r\n\t  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\r\n\t  return parse(pattern, { ...options, fastpaths: false });\r\n\t};\r\n\r\n\t/**\r\n\t * Scan a glob pattern to separate the pattern into segments.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.scan(input[, options]);\r\n\t *\r\n\t * const result = picomatch.scan('!./foo/*.js');\r\n\t * console.log(result);\r\n\t * { prefix: '!./',\r\n\t *   input: '!./foo/*.js',\r\n\t *   start: 3,\r\n\t *   base: 'foo',\r\n\t *   glob: '*.js',\r\n\t *   isBrace: false,\r\n\t *   isBracket: false,\r\n\t *   isGlob: true,\r\n\t *   isExtglob: false,\r\n\t *   isGlobstar: false,\r\n\t *   negated: true }\r\n\t * ```\r\n\t * @param {String} `input` Glob pattern to scan.\r\n\t * @param {Object} `options`\r\n\t * @return {Object} Returns an object with\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.scan = (input, options) => scan(input, options);\r\n\r\n\t/**\r\n\t * Compile a regular expression from the `state` object returned by the\r\n\t * [parse()](#parse) method.\r\n\t *\r\n\t * @param {Object} `state`\r\n\t * @param {Object} `options`\r\n\t * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\r\n\t * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\r\n\t * @return {RegExp}\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\r\n\t  if (returnOutput === true) {\r\n\t    return state.output;\r\n\t  }\r\n\r\n\t  const opts = options || {};\r\n\t  const prepend = opts.contains ? '' : '^';\r\n\t  const append = opts.contains ? '' : '$';\r\n\r\n\t  let source = `${prepend}(?:${state.output})${append}`;\r\n\t  if (state && state.negated === true) {\r\n\t    source = `^(?!${source}).*$`;\r\n\t  }\r\n\r\n\t  const regex = picomatch.toRegex(source, options);\r\n\t  if (returnState === true) {\r\n\t    regex.state = state;\r\n\t  }\r\n\r\n\t  return regex;\r\n\t};\r\n\r\n\t/**\r\n\t * Create a regular expression from a parsed glob pattern.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * const state = picomatch.parse('*.js');\r\n\t * // picomatch.compileRe(state[, options]);\r\n\t *\r\n\t * console.log(picomatch.compileRe(state));\r\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n\t * ```\r\n\t * @param {String} `state` The object returned from the `.parse` method.\r\n\t * @param {Object} `options`\r\n\t * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\r\n\t * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\r\n\t * @return {RegExp} Returns a regex created from the given pattern.\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\r\n\t  if (!input || typeof input !== 'string') {\r\n\t    throw new TypeError('Expected a non-empty string');\r\n\t  }\r\n\r\n\t  let parsed = { negated: false, fastpaths: true };\r\n\r\n\t  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\r\n\t    parsed.output = parse.fastpaths(input, options);\r\n\t  }\r\n\r\n\t  if (!parsed.output) {\r\n\t    parsed = parse(input, options);\r\n\t  }\r\n\r\n\t  return picomatch.compileRe(parsed, options, returnOutput, returnState);\r\n\t};\r\n\r\n\t/**\r\n\t * Create a regular expression from the given regex source string.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.toRegex(source[, options]);\r\n\t *\r\n\t * const { output } = picomatch.parse('*.js');\r\n\t * console.log(picomatch.toRegex(output));\r\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n\t * ```\r\n\t * @param {String} `source` Regular expression source string.\r\n\t * @param {Object} `options`\r\n\t * @return {RegExp}\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.toRegex = (source, options) => {\r\n\t  try {\r\n\t    const opts = options || {};\r\n\t    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\r\n\t  } catch (err) {\r\n\t    if (options && options.debug === true) throw err;\r\n\t    return /$^/;\r\n\t  }\r\n\t};\r\n\r\n\t/**\r\n\t * Picomatch constants.\r\n\t * @return {Object}\r\n\t */\r\n\r\n\tpicomatch.constants = constants;\r\n\r\n\t/**\r\n\t * Expose \"picomatch\"\r\n\t */\r\n\r\n\tpicomatch_1$1 = picomatch;\r\n\treturn picomatch_1$1;\r\n}\r\n\r\nvar picomatch$1;\r\nvar hasRequiredPicomatch$2;\r\n\r\nfunction requirePicomatch$2 () {\r\n\tif (hasRequiredPicomatch$2) return picomatch$1;\r\n\thasRequiredPicomatch$2 = 1;\r\n\r\n\tpicomatch$1 = /*@__PURE__*/ requirePicomatch$3();\r\n\treturn picomatch$1;\r\n}\r\n\r\nvar readdirp_1;\r\nvar hasRequiredReaddirp;\r\n\r\nfunction requireReaddirp () {\r\n\tif (hasRequiredReaddirp) return readdirp_1;\r\n\thasRequiredReaddirp = 1;\r\n\r\n\tconst fs = require$$0$2;\r\n\tconst { Readable } = require$$1;\r\n\tconst sysPath = require$$0$1;\r\n\tconst { promisify } = require$$2;\r\n\tconst picomatch = /*@__PURE__*/ requirePicomatch$2();\r\n\r\n\tconst readdir = promisify(fs.readdir);\r\n\tconst stat = promisify(fs.stat);\r\n\tconst lstat = promisify(fs.lstat);\r\n\tconst realpath = promisify(fs.realpath);\r\n\r\n\t/**\r\n\t * @typedef {Object} EntryInfo\r\n\t * @property {String} path\r\n\t * @property {String} fullPath\r\n\t * @property {fs.Stats=} stats\r\n\t * @property {fs.Dirent=} dirent\r\n\t * @property {String} basename\r\n\t */\r\n\r\n\tconst BANG = '!';\r\n\tconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\r\n\tconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\r\n\tconst FILE_TYPE = 'files';\r\n\tconst DIR_TYPE = 'directories';\r\n\tconst FILE_DIR_TYPE = 'files_directories';\r\n\tconst EVERYTHING_TYPE = 'all';\r\n\tconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\r\n\r\n\tconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\r\n\tconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\r\n\tconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\r\n\r\n\tconst normalizeFilter = filter => {\r\n\t  if (filter === undefined) return;\r\n\t  if (typeof filter === 'function') return filter;\r\n\r\n\t  if (typeof filter === 'string') {\r\n\t    const glob = picomatch(filter.trim());\r\n\t    return entry => glob(entry.basename);\r\n\t  }\r\n\r\n\t  if (Array.isArray(filter)) {\r\n\t    const positive = [];\r\n\t    const negative = [];\r\n\t    for (const item of filter) {\r\n\t      const trimmed = item.trim();\r\n\t      if (trimmed.charAt(0) === BANG) {\r\n\t        negative.push(picomatch(trimmed.slice(1)));\r\n\t      } else {\r\n\t        positive.push(picomatch(trimmed));\r\n\t      }\r\n\t    }\r\n\r\n\t    if (negative.length > 0) {\r\n\t      if (positive.length > 0) {\r\n\t        return entry =>\r\n\t          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\r\n\t      }\r\n\t      return entry => !negative.some(f => f(entry.basename));\r\n\t    }\r\n\t    return entry => positive.some(f => f(entry.basename));\r\n\t  }\r\n\t};\r\n\r\n\tclass ReaddirpStream extends Readable {\r\n\t  static get defaultOptions() {\r\n\t    return {\r\n\t      root: '.',\r\n\t      /* eslint-disable no-unused-vars */\r\n\t      fileFilter: (path) => true,\r\n\t      directoryFilter: (path) => true,\r\n\t      /* eslint-enable no-unused-vars */\r\n\t      type: FILE_TYPE,\r\n\t      lstat: false,\r\n\t      depth: 2147483648,\r\n\t      alwaysStat: false\r\n\t    };\r\n\t  }\r\n\r\n\t  constructor(options = {}) {\r\n\t    super({\r\n\t      objectMode: true,\r\n\t      autoDestroy: true,\r\n\t      highWaterMark: options.highWaterMark || 4096\r\n\t    });\r\n\t    const opts = { ...ReaddirpStream.defaultOptions, ...options };\r\n\t    const { root, type } = opts;\r\n\r\n\t    this._fileFilter = normalizeFilter(opts.fileFilter);\r\n\t    this._directoryFilter = normalizeFilter(opts.directoryFilter);\r\n\r\n\t    const statMethod = opts.lstat ? lstat : stat;\r\n\t    // Use bigint stats if it's windows and stat() supports options (node 10+).\r\n\t    if (wantBigintFsStats) {\r\n\t      this._stat = path => statMethod(path, { bigint: true });\r\n\t    } else {\r\n\t      this._stat = statMethod;\r\n\t    }\r\n\r\n\t    this._maxDepth = opts.depth;\r\n\t    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\r\n\t    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\r\n\t    this._wantsEverything = type === EVERYTHING_TYPE;\r\n\t    this._root = sysPath.resolve(root);\r\n\t    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\r\n\t    this._statsProp = this._isDirent ? 'dirent' : 'stats';\r\n\t    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\r\n\r\n\t    // Launch stream with one parent, the root dir.\r\n\t    this.parents = [this._exploreDir(root, 1)];\r\n\t    this.reading = false;\r\n\t    this.parent = undefined;\r\n\t  }\r\n\r\n\t  async _read(batch) {\r\n\t    if (this.reading) return;\r\n\t    this.reading = true;\r\n\r\n\t    try {\r\n\t      while (!this.destroyed && batch > 0) {\r\n\t        const { path, depth, files = [] } = this.parent || {};\r\n\r\n\t        if (files.length > 0) {\r\n\t          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\r\n\t          for (const entry of await Promise.all(slice)) {\r\n\t            if (this.destroyed) return;\r\n\r\n\t            const entryType = await this._getEntryType(entry);\r\n\t            if (entryType === 'directory' && this._directoryFilter(entry)) {\r\n\t              if (depth <= this._maxDepth) {\r\n\t                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\r\n\t              }\r\n\r\n\t              if (this._wantsDir) {\r\n\t                this.push(entry);\r\n\t                batch--;\r\n\t              }\r\n\t            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\r\n\t              if (this._wantsFile) {\r\n\t                this.push(entry);\r\n\t                batch--;\r\n\t              }\r\n\t            }\r\n\t          }\r\n\t        } else {\r\n\t          const parent = this.parents.pop();\r\n\t          if (!parent) {\r\n\t            this.push(null);\r\n\t            break;\r\n\t          }\r\n\t          this.parent = await parent;\r\n\t          if (this.destroyed) return;\r\n\t        }\r\n\t      }\r\n\t    } catch (error) {\r\n\t      this.destroy(error);\r\n\t    } finally {\r\n\t      this.reading = false;\r\n\t    }\r\n\t  }\r\n\r\n\t  async _exploreDir(path, depth) {\r\n\t    let files;\r\n\t    try {\r\n\t      files = await readdir(path, this._rdOptions);\r\n\t    } catch (error) {\r\n\t      this._onError(error);\r\n\t    }\r\n\t    return { files, depth, path };\r\n\t  }\r\n\r\n\t  async _formatEntry(dirent, path) {\r\n\t    let entry;\r\n\t    try {\r\n\t      const basename = this._isDirent ? dirent.name : dirent;\r\n\t      const fullPath = sysPath.resolve(sysPath.join(path, basename));\r\n\t      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };\r\n\t      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\r\n\t    } catch (err) {\r\n\t      this._onError(err);\r\n\t    }\r\n\t    return entry;\r\n\t  }\r\n\r\n\t  _onError(err) {\r\n\t    if (isNormalFlowError(err) && !this.destroyed) {\r\n\t      this.emit('warn', err);\r\n\t    } else {\r\n\t      this.destroy(err);\r\n\t    }\r\n\t  }\r\n\r\n\t  async _getEntryType(entry) {\r\n\t    // entry may be undefined, because a warning or an error were emitted\r\n\t    // and the statsProp is undefined\r\n\t    const stats = entry && entry[this._statsProp];\r\n\t    if (!stats) {\r\n\t      return;\r\n\t    }\r\n\t    if (stats.isFile()) {\r\n\t      return 'file';\r\n\t    }\r\n\t    if (stats.isDirectory()) {\r\n\t      return 'directory';\r\n\t    }\r\n\t    if (stats && stats.isSymbolicLink()) {\r\n\t      const full = entry.fullPath;\r\n\t      try {\r\n\t        const entryRealPath = await realpath(full);\r\n\t        const entryRealPathStats = await lstat(entryRealPath);\r\n\t        if (entryRealPathStats.isFile()) {\r\n\t          return 'file';\r\n\t        }\r\n\t        if (entryRealPathStats.isDirectory()) {\r\n\t          const len = entryRealPath.length;\r\n\t          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\r\n\t            const recursiveError = new Error(\r\n\t              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\r\n\t            );\r\n\t            recursiveError.code = RECURSIVE_ERROR_CODE;\r\n\t            return this._onError(recursiveError);\r\n\t          }\r\n\t          return 'directory';\r\n\t        }\r\n\t      } catch (error) {\r\n\t        this._onError(error);\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  _includeAsFile(entry) {\r\n\t    const stats = entry && entry[this._statsProp];\r\n\r\n\t    return stats && this._wantsEverything && !stats.isDirectory();\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * @typedef {Object} ReaddirpArguments\r\n\t * @property {Function=} fileFilter\r\n\t * @property {Function=} directoryFilter\r\n\t * @property {String=} type\r\n\t * @property {Number=} depth\r\n\t * @property {String=} root\r\n\t * @property {Boolean=} lstat\r\n\t * @property {Boolean=} bigint\r\n\t */\r\n\r\n\t/**\r\n\t * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\r\n\t * @param {String} root Root directory\r\n\t * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\r\n\t */\r\n\tconst readdirp = (root, options = {}) => {\r\n\t  let type = options.entryType || options.type;\r\n\t  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\r\n\t  if (type) options.type = type;\r\n\t  if (!root) {\r\n\t    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\r\n\t  } else if (typeof root !== 'string') {\r\n\t    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\r\n\t  } else if (type && !ALL_TYPES.includes(type)) {\r\n\t    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\r\n\t  }\r\n\r\n\t  options.root = root;\r\n\t  return new ReaddirpStream(options);\r\n\t};\r\n\r\n\tconst readdirpPromise = (root, options = {}) => {\r\n\t  return new Promise((resolve, reject) => {\r\n\t    const files = [];\r\n\t    readdirp(root, options)\r\n\t      .on('data', entry => files.push(entry))\r\n\t      .on('end', () => resolve(files))\r\n\t      .on('error', error => reject(error));\r\n\t  });\r\n\t};\r\n\r\n\treaddirp.promise = readdirpPromise;\r\n\treaddirp.ReaddirpStream = ReaddirpStream;\r\n\treaddirp.default = readdirp;\r\n\r\n\treaddirp_1 = readdirp;\r\n\treturn readdirp_1;\r\n}\r\n\r\nvar anymatch = {exports: {}};\r\n\r\nvar utils$1 = {};\r\n\r\nvar constants$2;\r\nvar hasRequiredConstants$2;\r\n\r\nfunction requireConstants$2 () {\r\n\tif (hasRequiredConstants$2) return constants$2;\r\n\thasRequiredConstants$2 = 1;\r\n\r\n\tconst path = require$$0$1;\r\n\tconst WIN_SLASH = '\\\\\\\\/';\r\n\tconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\r\n\r\n\t/**\r\n\t * Posix glob regex\r\n\t */\r\n\r\n\tconst DOT_LITERAL = '\\\\.';\r\n\tconst PLUS_LITERAL = '\\\\+';\r\n\tconst QMARK_LITERAL = '\\\\?';\r\n\tconst SLASH_LITERAL = '\\\\/';\r\n\tconst ONE_CHAR = '(?=.)';\r\n\tconst QMARK = '[^/]';\r\n\tconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\r\n\tconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\r\n\tconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\r\n\tconst NO_DOT = `(?!${DOT_LITERAL})`;\r\n\tconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\r\n\tconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\r\n\tconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\r\n\tconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\r\n\tconst STAR = `${QMARK}*?`;\r\n\r\n\tconst POSIX_CHARS = {\r\n\t  DOT_LITERAL,\r\n\t  PLUS_LITERAL,\r\n\t  QMARK_LITERAL,\r\n\t  SLASH_LITERAL,\r\n\t  ONE_CHAR,\r\n\t  QMARK,\r\n\t  END_ANCHOR,\r\n\t  DOTS_SLASH,\r\n\t  NO_DOT,\r\n\t  NO_DOTS,\r\n\t  NO_DOT_SLASH,\r\n\t  NO_DOTS_SLASH,\r\n\t  QMARK_NO_DOT,\r\n\t  STAR,\r\n\t  START_ANCHOR\r\n\t};\r\n\r\n\t/**\r\n\t * Windows glob regex\r\n\t */\r\n\r\n\tconst WINDOWS_CHARS = {\r\n\t  ...POSIX_CHARS,\r\n\r\n\t  SLASH_LITERAL: `[${WIN_SLASH}]`,\r\n\t  QMARK: WIN_NO_SLASH,\r\n\t  STAR: `${WIN_NO_SLASH}*?`,\r\n\t  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\r\n\t  NO_DOT: `(?!${DOT_LITERAL})`,\r\n\t  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\r\n\t  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\r\n\t  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\r\n\t  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\r\n\t  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\r\n\t  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\r\n\t};\r\n\r\n\t/**\r\n\t * POSIX Bracket Regex\r\n\t */\r\n\r\n\tconst POSIX_REGEX_SOURCE = {\r\n\t  alnum: 'a-zA-Z0-9',\r\n\t  alpha: 'a-zA-Z',\r\n\t  ascii: '\\\\x00-\\\\x7F',\r\n\t  blank: ' \\\\t',\r\n\t  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\r\n\t  digit: '0-9',\r\n\t  graph: '\\\\x21-\\\\x7E',\r\n\t  lower: 'a-z',\r\n\t  print: '\\\\x20-\\\\x7E ',\r\n\t  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\r\n\t  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\r\n\t  upper: 'A-Z',\r\n\t  word: 'A-Za-z0-9_',\r\n\t  xdigit: 'A-Fa-f0-9'\r\n\t};\r\n\r\n\tconstants$2 = {\r\n\t  MAX_LENGTH: 1024 * 64,\r\n\t  POSIX_REGEX_SOURCE,\r\n\r\n\t  // regular expressions\r\n\t  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\r\n\t  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\r\n\t  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\r\n\t  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\r\n\t  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\r\n\t  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\r\n\r\n\t  // Replace globs with equivalent patterns to reduce parsing time.\r\n\t  REPLACEMENTS: {\r\n\t    '***': '*',\r\n\t    '**/**': '**',\r\n\t    '**/**/**': '**'\r\n\t  },\r\n\r\n\t  // Digits\r\n\t  CHAR_0: 48, /* 0 */\r\n\t  CHAR_9: 57, /* 9 */\r\n\r\n\t  // Alphabet chars.\r\n\t  CHAR_UPPERCASE_A: 65, /* A */\r\n\t  CHAR_LOWERCASE_A: 97, /* a */\r\n\t  CHAR_UPPERCASE_Z: 90, /* Z */\r\n\t  CHAR_LOWERCASE_Z: 122, /* z */\r\n\r\n\t  CHAR_LEFT_PARENTHESES: 40, /* ( */\r\n\t  CHAR_RIGHT_PARENTHESES: 41, /* ) */\r\n\r\n\t  CHAR_ASTERISK: 42, /* * */\r\n\r\n\t  // Non-alphabetic chars.\r\n\t  CHAR_AMPERSAND: 38, /* & */\r\n\t  CHAR_AT: 64, /* @ */\r\n\t  CHAR_BACKWARD_SLASH: 92, /* \\ */\r\n\t  CHAR_CARRIAGE_RETURN: 13, /* \\r */\r\n\t  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\r\n\t  CHAR_COLON: 58, /* : */\r\n\t  CHAR_COMMA: 44, /* , */\r\n\t  CHAR_DOT: 46, /* . */\r\n\t  CHAR_DOUBLE_QUOTE: 34, /* \" */\r\n\t  CHAR_EQUAL: 61, /* = */\r\n\t  CHAR_EXCLAMATION_MARK: 33, /* ! */\r\n\t  CHAR_FORM_FEED: 12, /* \\f */\r\n\t  CHAR_FORWARD_SLASH: 47, /* / */\r\n\t  CHAR_GRAVE_ACCENT: 96, /* ` */\r\n\t  CHAR_HASH: 35, /* # */\r\n\t  CHAR_HYPHEN_MINUS: 45, /* - */\r\n\t  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\r\n\t  CHAR_LEFT_CURLY_BRACE: 123, /* { */\r\n\t  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\r\n\t  CHAR_LINE_FEED: 10, /* \\n */\r\n\t  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\r\n\t  CHAR_PERCENT: 37, /* % */\r\n\t  CHAR_PLUS: 43, /* + */\r\n\t  CHAR_QUESTION_MARK: 63, /* ? */\r\n\t  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\r\n\t  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\r\n\t  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\r\n\t  CHAR_SEMICOLON: 59, /* ; */\r\n\t  CHAR_SINGLE_QUOTE: 39, /* ' */\r\n\t  CHAR_SPACE: 32, /*   */\r\n\t  CHAR_TAB: 9, /* \\t */\r\n\t  CHAR_UNDERSCORE: 95, /* _ */\r\n\t  CHAR_VERTICAL_LINE: 124, /* | */\r\n\t  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\r\n\r\n\t  SEP: path.sep,\r\n\r\n\t  /**\r\n\t   * Create EXTGLOB_CHARS\r\n\t   */\r\n\r\n\t  extglobChars(chars) {\r\n\t    return {\r\n\t      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\r\n\t      '?': { type: 'qmark', open: '(?:', close: ')?' },\r\n\t      '+': { type: 'plus', open: '(?:', close: ')+' },\r\n\t      '*': { type: 'star', open: '(?:', close: ')*' },\r\n\t      '@': { type: 'at', open: '(?:', close: ')' }\r\n\t    };\r\n\t  },\r\n\r\n\t  /**\r\n\t   * Create GLOB_CHARS\r\n\t   */\r\n\r\n\t  globChars(win32) {\r\n\t    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\r\n\t  }\r\n\t};\r\n\treturn constants$2;\r\n}\r\n\r\nvar hasRequiredUtils$1;\r\n\r\nfunction requireUtils$1 () {\r\n\tif (hasRequiredUtils$1) return utils$1;\r\n\thasRequiredUtils$1 = 1;\r\n\t(function (exports) {\r\n\r\n\t\tconst path = require$$0$1;\r\n\t\tconst win32 = process.platform === 'win32';\r\n\t\tconst {\r\n\t\t  REGEX_BACKSLASH,\r\n\t\t  REGEX_REMOVE_BACKSLASH,\r\n\t\t  REGEX_SPECIAL_CHARS,\r\n\t\t  REGEX_SPECIAL_CHARS_GLOBAL\r\n\t\t} = /*@__PURE__*/ requireConstants$2();\r\n\r\n\t\texports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\r\n\t\texports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\r\n\t\texports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\r\n\t\texports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\r\n\t\texports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\r\n\r\n\t\texports.removeBackslashes = str => {\r\n\t\t  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\r\n\t\t    return match === '\\\\' ? '' : match;\r\n\t\t  });\r\n\t\t};\r\n\r\n\t\texports.supportsLookbehinds = () => {\r\n\t\t  const segs = process.version.slice(1).split('.').map(Number);\r\n\t\t  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\r\n\t\t    return true;\r\n\t\t  }\r\n\t\t  return false;\r\n\t\t};\r\n\r\n\t\texports.isWindows = options => {\r\n\t\t  if (options && typeof options.windows === 'boolean') {\r\n\t\t    return options.windows;\r\n\t\t  }\r\n\t\t  return win32 === true || path.sep === '\\\\';\r\n\t\t};\r\n\r\n\t\texports.escapeLast = (input, char, lastIdx) => {\r\n\t\t  const idx = input.lastIndexOf(char, lastIdx);\r\n\t\t  if (idx === -1) return input;\r\n\t\t  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\r\n\t\t  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\r\n\t\t};\r\n\r\n\t\texports.removePrefix = (input, state = {}) => {\r\n\t\t  let output = input;\r\n\t\t  if (output.startsWith('./')) {\r\n\t\t    output = output.slice(2);\r\n\t\t    state.prefix = './';\r\n\t\t  }\r\n\t\t  return output;\r\n\t\t};\r\n\r\n\t\texports.wrapOutput = (input, state = {}, options = {}) => {\r\n\t\t  const prepend = options.contains ? '' : '^';\r\n\t\t  const append = options.contains ? '' : '$';\r\n\r\n\t\t  let output = `${prepend}(?:${input})${append}`;\r\n\t\t  if (state.negated === true) {\r\n\t\t    output = `(?:^(?!${output}).*$)`;\r\n\t\t  }\r\n\t\t  return output;\r\n\t\t}; \r\n\t} (utils$1));\r\n\treturn utils$1;\r\n}\r\n\r\nvar scan_1;\r\nvar hasRequiredScan;\r\n\r\nfunction requireScan () {\r\n\tif (hasRequiredScan) return scan_1;\r\n\thasRequiredScan = 1;\r\n\r\n\tconst utils = /*@__PURE__*/ requireUtils$1();\r\n\tconst {\r\n\t  CHAR_ASTERISK,             /* * */\r\n\t  CHAR_AT,                   /* @ */\r\n\t  CHAR_BACKWARD_SLASH,       /* \\ */\r\n\t  CHAR_COMMA,                /* , */\r\n\t  CHAR_DOT,                  /* . */\r\n\t  CHAR_EXCLAMATION_MARK,     /* ! */\r\n\t  CHAR_FORWARD_SLASH,        /* / */\r\n\t  CHAR_LEFT_CURLY_BRACE,     /* { */\r\n\t  CHAR_LEFT_PARENTHESES,     /* ( */\r\n\t  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\r\n\t  CHAR_PLUS,                 /* + */\r\n\t  CHAR_QUESTION_MARK,        /* ? */\r\n\t  CHAR_RIGHT_CURLY_BRACE,    /* } */\r\n\t  CHAR_RIGHT_PARENTHESES,    /* ) */\r\n\t  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\r\n\t} = /*@__PURE__*/ requireConstants$2();\r\n\r\n\tconst isPathSeparator = code => {\r\n\t  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\r\n\t};\r\n\r\n\tconst depth = token => {\r\n\t  if (token.isPrefix !== true) {\r\n\t    token.depth = token.isGlobstar ? Infinity : 1;\r\n\t  }\r\n\t};\r\n\r\n\t/**\r\n\t * Quickly scans a glob pattern and returns an object with a handful of\r\n\t * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\r\n\t * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\r\n\t * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\r\n\t *\r\n\t * ```js\r\n\t * const pm = require('picomatch');\r\n\t * console.log(pm.scan('foo/bar/*.js'));\r\n\t * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\r\n\t * ```\r\n\t * @param {String} `str`\r\n\t * @param {Object} `options`\r\n\t * @return {Object} Returns an object with tokens and regex source string.\r\n\t * @api public\r\n\t */\r\n\r\n\tconst scan = (input, options) => {\r\n\t  const opts = options || {};\r\n\r\n\t  const length = input.length - 1;\r\n\t  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\r\n\t  const slashes = [];\r\n\t  const tokens = [];\r\n\t  const parts = [];\r\n\r\n\t  let str = input;\r\n\t  let index = -1;\r\n\t  let start = 0;\r\n\t  let lastIndex = 0;\r\n\t  let isBrace = false;\r\n\t  let isBracket = false;\r\n\t  let isGlob = false;\r\n\t  let isExtglob = false;\r\n\t  let isGlobstar = false;\r\n\t  let braceEscaped = false;\r\n\t  let backslashes = false;\r\n\t  let negated = false;\r\n\t  let negatedExtglob = false;\r\n\t  let finished = false;\r\n\t  let braces = 0;\r\n\t  let prev;\r\n\t  let code;\r\n\t  let token = { value: '', depth: 0, isGlob: false };\r\n\r\n\t  const eos = () => index >= length;\r\n\t  const peek = () => str.charCodeAt(index + 1);\r\n\t  const advance = () => {\r\n\t    prev = code;\r\n\t    return str.charCodeAt(++index);\r\n\t  };\r\n\r\n\t  while (index < length) {\r\n\t    code = advance();\r\n\t    let next;\r\n\r\n\t    if (code === CHAR_BACKWARD_SLASH) {\r\n\t      backslashes = token.backslashes = true;\r\n\t      code = advance();\r\n\r\n\t      if (code === CHAR_LEFT_CURLY_BRACE) {\r\n\t        braceEscaped = true;\r\n\t      }\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\r\n\t      braces++;\r\n\r\n\t      while (eos() !== true && (code = advance())) {\r\n\t        if (code === CHAR_BACKWARD_SLASH) {\r\n\t          backslashes = token.backslashes = true;\r\n\t          advance();\r\n\t          continue;\r\n\t        }\r\n\r\n\t        if (code === CHAR_LEFT_CURLY_BRACE) {\r\n\t          braces++;\r\n\t          continue;\r\n\t        }\r\n\r\n\t        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\r\n\t          isBrace = token.isBrace = true;\r\n\t          isGlob = token.isGlob = true;\r\n\t          finished = true;\r\n\r\n\t          if (scanToEnd === true) {\r\n\t            continue;\r\n\t          }\r\n\r\n\t          break;\r\n\t        }\r\n\r\n\t        if (braceEscaped !== true && code === CHAR_COMMA) {\r\n\t          isBrace = token.isBrace = true;\r\n\t          isGlob = token.isGlob = true;\r\n\t          finished = true;\r\n\r\n\t          if (scanToEnd === true) {\r\n\t            continue;\r\n\t          }\r\n\r\n\t          break;\r\n\t        }\r\n\r\n\t        if (code === CHAR_RIGHT_CURLY_BRACE) {\r\n\t          braces--;\r\n\r\n\t          if (braces === 0) {\r\n\t            braceEscaped = false;\r\n\t            isBrace = token.isBrace = true;\r\n\t            finished = true;\r\n\t            break;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (code === CHAR_FORWARD_SLASH) {\r\n\t      slashes.push(index);\r\n\t      tokens.push(token);\r\n\t      token = { value: '', depth: 0, isGlob: false };\r\n\r\n\t      if (finished === true) continue;\r\n\t      if (prev === CHAR_DOT && index === (start + 1)) {\r\n\t        start += 2;\r\n\t        continue;\r\n\t      }\r\n\r\n\t      lastIndex = index + 1;\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (opts.noext !== true) {\r\n\t      const isExtglobChar = code === CHAR_PLUS\r\n\t        || code === CHAR_AT\r\n\t        || code === CHAR_ASTERISK\r\n\t        || code === CHAR_QUESTION_MARK\r\n\t        || code === CHAR_EXCLAMATION_MARK;\r\n\r\n\t      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\r\n\t        isGlob = token.isGlob = true;\r\n\t        isExtglob = token.isExtglob = true;\r\n\t        finished = true;\r\n\t        if (code === CHAR_EXCLAMATION_MARK && index === start) {\r\n\t          negatedExtglob = true;\r\n\t        }\r\n\r\n\t        if (scanToEnd === true) {\r\n\t          while (eos() !== true && (code = advance())) {\r\n\t            if (code === CHAR_BACKWARD_SLASH) {\r\n\t              backslashes = token.backslashes = true;\r\n\t              code = advance();\r\n\t              continue;\r\n\t            }\r\n\r\n\t            if (code === CHAR_RIGHT_PARENTHESES) {\r\n\t              isGlob = token.isGlob = true;\r\n\t              finished = true;\r\n\t              break;\r\n\t            }\r\n\t          }\r\n\t          continue;\r\n\t        }\r\n\t        break;\r\n\t      }\r\n\t    }\r\n\r\n\t    if (code === CHAR_ASTERISK) {\r\n\t      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\r\n\t      isGlob = token.isGlob = true;\r\n\t      finished = true;\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (code === CHAR_QUESTION_MARK) {\r\n\t      isGlob = token.isGlob = true;\r\n\t      finished = true;\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (code === CHAR_LEFT_SQUARE_BRACKET) {\r\n\t      while (eos() !== true && (next = advance())) {\r\n\t        if (next === CHAR_BACKWARD_SLASH) {\r\n\t          backslashes = token.backslashes = true;\r\n\t          advance();\r\n\t          continue;\r\n\t        }\r\n\r\n\t        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\r\n\t          isBracket = token.isBracket = true;\r\n\t          isGlob = token.isGlob = true;\r\n\t          finished = true;\r\n\t          break;\r\n\t        }\r\n\t      }\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\r\n\t      negated = token.negated = true;\r\n\t      start++;\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\r\n\t      isGlob = token.isGlob = true;\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        while (eos() !== true && (code = advance())) {\r\n\t          if (code === CHAR_LEFT_PARENTHESES) {\r\n\t            backslashes = token.backslashes = true;\r\n\t            code = advance();\r\n\t            continue;\r\n\t          }\r\n\r\n\t          if (code === CHAR_RIGHT_PARENTHESES) {\r\n\t            finished = true;\r\n\t            break;\r\n\t          }\r\n\t        }\r\n\t        continue;\r\n\t      }\r\n\t      break;\r\n\t    }\r\n\r\n\t    if (isGlob === true) {\r\n\t      finished = true;\r\n\r\n\t      if (scanToEnd === true) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\r\n\t  if (opts.noext === true) {\r\n\t    isExtglob = false;\r\n\t    isGlob = false;\r\n\t  }\r\n\r\n\t  let base = str;\r\n\t  let prefix = '';\r\n\t  let glob = '';\r\n\r\n\t  if (start > 0) {\r\n\t    prefix = str.slice(0, start);\r\n\t    str = str.slice(start);\r\n\t    lastIndex -= start;\r\n\t  }\r\n\r\n\t  if (base && isGlob === true && lastIndex > 0) {\r\n\t    base = str.slice(0, lastIndex);\r\n\t    glob = str.slice(lastIndex);\r\n\t  } else if (isGlob === true) {\r\n\t    base = '';\r\n\t    glob = str;\r\n\t  } else {\r\n\t    base = str;\r\n\t  }\r\n\r\n\t  if (base && base !== '' && base !== '/' && base !== str) {\r\n\t    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\r\n\t      base = base.slice(0, -1);\r\n\t    }\r\n\t  }\r\n\r\n\t  if (opts.unescape === true) {\r\n\t    if (glob) glob = utils.removeBackslashes(glob);\r\n\r\n\t    if (base && backslashes === true) {\r\n\t      base = utils.removeBackslashes(base);\r\n\t    }\r\n\t  }\r\n\r\n\t  const state = {\r\n\t    prefix,\r\n\t    input,\r\n\t    start,\r\n\t    base,\r\n\t    glob,\r\n\t    isBrace,\r\n\t    isBracket,\r\n\t    isGlob,\r\n\t    isExtglob,\r\n\t    isGlobstar,\r\n\t    negated,\r\n\t    negatedExtglob\r\n\t  };\r\n\r\n\t  if (opts.tokens === true) {\r\n\t    state.maxDepth = 0;\r\n\t    if (!isPathSeparator(code)) {\r\n\t      tokens.push(token);\r\n\t    }\r\n\t    state.tokens = tokens;\r\n\t  }\r\n\r\n\t  if (opts.parts === true || opts.tokens === true) {\r\n\t    let prevIndex;\r\n\r\n\t    for (let idx = 0; idx < slashes.length; idx++) {\r\n\t      const n = prevIndex ? prevIndex + 1 : start;\r\n\t      const i = slashes[idx];\r\n\t      const value = input.slice(n, i);\r\n\t      if (opts.tokens) {\r\n\t        if (idx === 0 && start !== 0) {\r\n\t          tokens[idx].isPrefix = true;\r\n\t          tokens[idx].value = prefix;\r\n\t        } else {\r\n\t          tokens[idx].value = value;\r\n\t        }\r\n\t        depth(tokens[idx]);\r\n\t        state.maxDepth += tokens[idx].depth;\r\n\t      }\r\n\t      if (idx !== 0 || value !== '') {\r\n\t        parts.push(value);\r\n\t      }\r\n\t      prevIndex = i;\r\n\t    }\r\n\r\n\t    if (prevIndex && prevIndex + 1 < input.length) {\r\n\t      const value = input.slice(prevIndex + 1);\r\n\t      parts.push(value);\r\n\r\n\t      if (opts.tokens) {\r\n\t        tokens[tokens.length - 1].value = value;\r\n\t        depth(tokens[tokens.length - 1]);\r\n\t        state.maxDepth += tokens[tokens.length - 1].depth;\r\n\t      }\r\n\t    }\r\n\r\n\t    state.slashes = slashes;\r\n\t    state.parts = parts;\r\n\t  }\r\n\r\n\t  return state;\r\n\t};\r\n\r\n\tscan_1 = scan;\r\n\treturn scan_1;\r\n}\r\n\r\nvar parse_1$1;\r\nvar hasRequiredParse$1;\r\n\r\nfunction requireParse$1 () {\r\n\tif (hasRequiredParse$1) return parse_1$1;\r\n\thasRequiredParse$1 = 1;\r\n\r\n\tconst constants = /*@__PURE__*/ requireConstants$2();\r\n\tconst utils = /*@__PURE__*/ requireUtils$1();\r\n\r\n\t/**\r\n\t * Constants\r\n\t */\r\n\r\n\tconst {\r\n\t  MAX_LENGTH,\r\n\t  POSIX_REGEX_SOURCE,\r\n\t  REGEX_NON_SPECIAL_CHARS,\r\n\t  REGEX_SPECIAL_CHARS_BACKREF,\r\n\t  REPLACEMENTS\r\n\t} = constants;\r\n\r\n\t/**\r\n\t * Helpers\r\n\t */\r\n\r\n\tconst expandRange = (args, options) => {\r\n\t  if (typeof options.expandRange === 'function') {\r\n\t    return options.expandRange(...args, options);\r\n\t  }\r\n\r\n\t  args.sort();\r\n\t  const value = `[${args.join('-')}]`;\r\n\r\n\t  return value;\r\n\t};\r\n\r\n\t/**\r\n\t * Create the message for a syntax error\r\n\t */\r\n\r\n\tconst syntaxError = (type, char) => {\r\n\t  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\r\n\t};\r\n\r\n\t/**\r\n\t * Parse the given input string.\r\n\t * @param {String} input\r\n\t * @param {Object} options\r\n\t * @return {Object}\r\n\t */\r\n\r\n\tconst parse = (input, options) => {\r\n\t  if (typeof input !== 'string') {\r\n\t    throw new TypeError('Expected a string');\r\n\t  }\r\n\r\n\t  input = REPLACEMENTS[input] || input;\r\n\r\n\t  const opts = { ...options };\r\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\r\n\r\n\t  let len = input.length;\r\n\t  if (len > max) {\r\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\r\n\t  }\r\n\r\n\t  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\r\n\t  const tokens = [bos];\r\n\r\n\t  const capture = opts.capture ? '' : '?:';\r\n\t  const win32 = utils.isWindows(options);\r\n\r\n\t  // create constants based on platform, for windows or posix\r\n\t  const PLATFORM_CHARS = constants.globChars(win32);\r\n\t  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\r\n\r\n\t  const {\r\n\t    DOT_LITERAL,\r\n\t    PLUS_LITERAL,\r\n\t    SLASH_LITERAL,\r\n\t    ONE_CHAR,\r\n\t    DOTS_SLASH,\r\n\t    NO_DOT,\r\n\t    NO_DOT_SLASH,\r\n\t    NO_DOTS_SLASH,\r\n\t    QMARK,\r\n\t    QMARK_NO_DOT,\r\n\t    STAR,\r\n\t    START_ANCHOR\r\n\t  } = PLATFORM_CHARS;\r\n\r\n\t  const globstar = opts => {\r\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\r\n\t  };\r\n\r\n\t  const nodot = opts.dot ? '' : NO_DOT;\r\n\t  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\r\n\t  let star = opts.bash === true ? globstar(opts) : STAR;\r\n\r\n\t  if (opts.capture) {\r\n\t    star = `(${star})`;\r\n\t  }\r\n\r\n\t  // minimatch options support\r\n\t  if (typeof opts.noext === 'boolean') {\r\n\t    opts.noextglob = opts.noext;\r\n\t  }\r\n\r\n\t  const state = {\r\n\t    input,\r\n\t    index: -1,\r\n\t    start: 0,\r\n\t    dot: opts.dot === true,\r\n\t    consumed: '',\r\n\t    output: '',\r\n\t    prefix: '',\r\n\t    backtrack: false,\r\n\t    negated: false,\r\n\t    brackets: 0,\r\n\t    braces: 0,\r\n\t    parens: 0,\r\n\t    quotes: 0,\r\n\t    globstar: false,\r\n\t    tokens\r\n\t  };\r\n\r\n\t  input = utils.removePrefix(input, state);\r\n\t  len = input.length;\r\n\r\n\t  const extglobs = [];\r\n\t  const braces = [];\r\n\t  const stack = [];\r\n\t  let prev = bos;\r\n\t  let value;\r\n\r\n\t  /**\r\n\t   * Tokenizing helpers\r\n\t   */\r\n\r\n\t  const eos = () => state.index === len - 1;\r\n\t  const peek = state.peek = (n = 1) => input[state.index + n];\r\n\t  const advance = state.advance = () => input[++state.index] || '';\r\n\t  const remaining = () => input.slice(state.index + 1);\r\n\t  const consume = (value = '', num = 0) => {\r\n\t    state.consumed += value;\r\n\t    state.index += num;\r\n\t  };\r\n\r\n\t  const append = token => {\r\n\t    state.output += token.output != null ? token.output : token.value;\r\n\t    consume(token.value);\r\n\t  };\r\n\r\n\t  const negate = () => {\r\n\t    let count = 1;\r\n\r\n\t    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\r\n\t      advance();\r\n\t      state.start++;\r\n\t      count++;\r\n\t    }\r\n\r\n\t    if (count % 2 === 0) {\r\n\t      return false;\r\n\t    }\r\n\r\n\t    state.negated = true;\r\n\t    state.start++;\r\n\t    return true;\r\n\t  };\r\n\r\n\t  const increment = type => {\r\n\t    state[type]++;\r\n\t    stack.push(type);\r\n\t  };\r\n\r\n\t  const decrement = type => {\r\n\t    state[type]--;\r\n\t    stack.pop();\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Push tokens onto the tokens array. This helper speeds up\r\n\t   * tokenizing by 1) helping us avoid backtracking as much as possible,\r\n\t   * and 2) helping us avoid creating extra tokens when consecutive\r\n\t   * characters are plain text. This improves performance and simplifies\r\n\t   * lookbehinds.\r\n\t   */\r\n\r\n\t  const push = tok => {\r\n\t    if (prev.type === 'globstar') {\r\n\t      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\r\n\t      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\r\n\r\n\t      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\r\n\t        state.output = state.output.slice(0, -prev.output.length);\r\n\t        prev.type = 'star';\r\n\t        prev.value = '*';\r\n\t        prev.output = star;\r\n\t        state.output += prev.output;\r\n\t      }\r\n\t    }\r\n\r\n\t    if (extglobs.length && tok.type !== 'paren') {\r\n\t      extglobs[extglobs.length - 1].inner += tok.value;\r\n\t    }\r\n\r\n\t    if (tok.value || tok.output) append(tok);\r\n\t    if (prev && prev.type === 'text' && tok.type === 'text') {\r\n\t      prev.value += tok.value;\r\n\t      prev.output = (prev.output || '') + tok.value;\r\n\t      return;\r\n\t    }\r\n\r\n\t    tok.prev = prev;\r\n\t    tokens.push(tok);\r\n\t    prev = tok;\r\n\t  };\r\n\r\n\t  const extglobOpen = (type, value) => {\r\n\t    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\r\n\r\n\t    token.prev = prev;\r\n\t    token.parens = state.parens;\r\n\t    token.output = state.output;\r\n\t    const output = (opts.capture ? '(' : '') + token.open;\r\n\r\n\t    increment('parens');\r\n\t    push({ type, value, output: state.output ? '' : ONE_CHAR });\r\n\t    push({ type: 'paren', extglob: true, value: advance(), output });\r\n\t    extglobs.push(token);\r\n\t  };\r\n\r\n\t  const extglobClose = token => {\r\n\t    let output = token.close + (opts.capture ? ')' : '');\r\n\t    let rest;\r\n\r\n\t    if (token.type === 'negate') {\r\n\t      let extglobStar = star;\r\n\r\n\t      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\r\n\t        extglobStar = globstar(opts);\r\n\t      }\r\n\r\n\t      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\r\n\t        output = token.close = `)$))${extglobStar}`;\r\n\t      }\r\n\r\n\t      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\r\n\t        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\r\n\t        // In this case, we need to parse the string and use it in the output of the original pattern.\r\n\t        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\r\n\t        //\r\n\t        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\r\n\t        const expression = parse(rest, { ...options, fastpaths: false }).output;\r\n\r\n\t        output = token.close = `)${expression})${extglobStar})`;\r\n\t      }\r\n\r\n\t      if (token.prev.type === 'bos') {\r\n\t        state.negatedExtglob = true;\r\n\t      }\r\n\t    }\r\n\r\n\t    push({ type: 'paren', extglob: true, value, output });\r\n\t    decrement('parens');\r\n\t  };\r\n\r\n\t  /**\r\n\t   * Fast paths\r\n\t   */\r\n\r\n\t  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\r\n\t    let backslashes = false;\r\n\r\n\t    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\r\n\t      if (first === '\\\\') {\r\n\t        backslashes = true;\r\n\t        return m;\r\n\t      }\r\n\r\n\t      if (first === '?') {\r\n\t        if (esc) {\r\n\t          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\r\n\t        }\r\n\t        if (index === 0) {\r\n\t          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\r\n\t        }\r\n\t        return QMARK.repeat(chars.length);\r\n\t      }\r\n\r\n\t      if (first === '.') {\r\n\t        return DOT_LITERAL.repeat(chars.length);\r\n\t      }\r\n\r\n\t      if (first === '*') {\r\n\t        if (esc) {\r\n\t          return esc + first + (rest ? star : '');\r\n\t        }\r\n\t        return star;\r\n\t      }\r\n\t      return esc ? m : `\\\\${m}`;\r\n\t    });\r\n\r\n\t    if (backslashes === true) {\r\n\t      if (opts.unescape === true) {\r\n\t        output = output.replace(/\\\\/g, '');\r\n\t      } else {\r\n\t        output = output.replace(/\\\\+/g, m => {\r\n\t          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\r\n\t        });\r\n\t      }\r\n\t    }\r\n\r\n\t    if (output === input && opts.contains === true) {\r\n\t      state.output = input;\r\n\t      return state;\r\n\t    }\r\n\r\n\t    state.output = utils.wrapOutput(output, state, options);\r\n\t    return state;\r\n\t  }\r\n\r\n\t  /**\r\n\t   * Tokenize input until we reach end-of-string\r\n\t   */\r\n\r\n\t  while (!eos()) {\r\n\t    value = advance();\r\n\r\n\t    if (value === '\\u0000') {\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Escaped characters\r\n\t     */\r\n\r\n\t    if (value === '\\\\') {\r\n\t      const next = peek();\r\n\r\n\t      if (next === '/' && opts.bash !== true) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (next === '.' || next === ';') {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (!next) {\r\n\t        value += '\\\\';\r\n\t        push({ type: 'text', value });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      // collapse slashes to reduce potential for exploits\r\n\t      const match = /^\\\\+/.exec(remaining());\r\n\t      let slashes = 0;\r\n\r\n\t      if (match && match[0].length > 2) {\r\n\t        slashes = match[0].length;\r\n\t        state.index += slashes;\r\n\t        if (slashes % 2 !== 0) {\r\n\t          value += '\\\\';\r\n\t        }\r\n\t      }\r\n\r\n\t      if (opts.unescape === true) {\r\n\t        value = advance();\r\n\t      } else {\r\n\t        value += advance();\r\n\t      }\r\n\r\n\t      if (state.brackets === 0) {\r\n\t        push({ type: 'text', value });\r\n\t        continue;\r\n\t      }\r\n\t    }\r\n\r\n\t    /**\r\n\t     * If we're inside a regex character class, continue\r\n\t     * until we reach the closing bracket.\r\n\t     */\r\n\r\n\t    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\r\n\t      if (opts.posix !== false && value === ':') {\r\n\t        const inner = prev.value.slice(1);\r\n\t        if (inner.includes('[')) {\r\n\t          prev.posix = true;\r\n\r\n\t          if (inner.includes(':')) {\r\n\t            const idx = prev.value.lastIndexOf('[');\r\n\t            const pre = prev.value.slice(0, idx);\r\n\t            const rest = prev.value.slice(idx + 2);\r\n\t            const posix = POSIX_REGEX_SOURCE[rest];\r\n\t            if (posix) {\r\n\t              prev.value = pre + posix;\r\n\t              state.backtrack = true;\r\n\t              advance();\r\n\r\n\t              if (!bos.output && tokens.indexOf(prev) === 1) {\r\n\t                bos.output = ONE_CHAR;\r\n\t              }\r\n\t              continue;\r\n\t            }\r\n\t          }\r\n\t        }\r\n\t      }\r\n\r\n\t      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\r\n\t        value = `\\\\${value}`;\r\n\t      }\r\n\r\n\t      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\r\n\t        value = `\\\\${value}`;\r\n\t      }\r\n\r\n\t      if (opts.posix === true && value === '!' && prev.value === '[') {\r\n\t        value = '^';\r\n\t      }\r\n\r\n\t      prev.value += value;\r\n\t      append({ value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * If we're inside a quoted string, continue\r\n\t     * until we reach the closing double quote.\r\n\t     */\r\n\r\n\t    if (state.quotes === 1 && value !== '\"') {\r\n\t      value = utils.escapeRegex(value);\r\n\t      prev.value += value;\r\n\t      append({ value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Double quotes\r\n\t     */\r\n\r\n\t    if (value === '\"') {\r\n\t      state.quotes = state.quotes === 1 ? 0 : 1;\r\n\t      if (opts.keepQuotes === true) {\r\n\t        push({ type: 'text', value });\r\n\t      }\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Parentheses\r\n\t     */\r\n\r\n\t    if (value === '(') {\r\n\t      increment('parens');\r\n\t      push({ type: 'paren', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (value === ')') {\r\n\t      if (state.parens === 0 && opts.strictBrackets === true) {\r\n\t        throw new SyntaxError(syntaxError('opening', '('));\r\n\t      }\r\n\r\n\t      const extglob = extglobs[extglobs.length - 1];\r\n\t      if (extglob && state.parens === extglob.parens + 1) {\r\n\t        extglobClose(extglobs.pop());\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\r\n\t      decrement('parens');\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Square brackets\r\n\t     */\r\n\r\n\t    if (value === '[') {\r\n\t      if (opts.nobracket === true || !remaining().includes(']')) {\r\n\t        if (opts.nobracket !== true && opts.strictBrackets === true) {\r\n\t          throw new SyntaxError(syntaxError('closing', ']'));\r\n\t        }\r\n\r\n\t        value = `\\\\${value}`;\r\n\t      } else {\r\n\t        increment('brackets');\r\n\t      }\r\n\r\n\t      push({ type: 'bracket', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (value === ']') {\r\n\t      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\r\n\t        push({ type: 'text', value, output: `\\\\${value}` });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (state.brackets === 0) {\r\n\t        if (opts.strictBrackets === true) {\r\n\t          throw new SyntaxError(syntaxError('opening', '['));\r\n\t        }\r\n\r\n\t        push({ type: 'text', value, output: `\\\\${value}` });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      decrement('brackets');\r\n\r\n\t      const prevValue = prev.value.slice(1);\r\n\t      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\r\n\t        value = `/${value}`;\r\n\t      }\r\n\r\n\t      prev.value += value;\r\n\t      append({ value });\r\n\r\n\t      // when literal brackets are explicitly disabled\r\n\t      // assume we should match with a regex character class\r\n\t      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\r\n\t        continue;\r\n\t      }\r\n\r\n\t      const escaped = utils.escapeRegex(prev.value);\r\n\t      state.output = state.output.slice(0, -prev.value.length);\r\n\r\n\t      // when literal brackets are explicitly enabled\r\n\t      // assume we should escape the brackets to match literal characters\r\n\t      if (opts.literalBrackets === true) {\r\n\t        state.output += escaped;\r\n\t        prev.value = escaped;\r\n\t        continue;\r\n\t      }\r\n\r\n\t      // when the user specifies nothing, try to match both\r\n\t      prev.value = `(${capture}${escaped}|${prev.value})`;\r\n\t      state.output += prev.value;\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Braces\r\n\t     */\r\n\r\n\t    if (value === '{' && opts.nobrace !== true) {\r\n\t      increment('braces');\r\n\r\n\t      const open = {\r\n\t        type: 'brace',\r\n\t        value,\r\n\t        output: '(',\r\n\t        outputIndex: state.output.length,\r\n\t        tokensIndex: state.tokens.length\r\n\t      };\r\n\r\n\t      braces.push(open);\r\n\t      push(open);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (value === '}') {\r\n\t      const brace = braces[braces.length - 1];\r\n\r\n\t      if (opts.nobrace === true || !brace) {\r\n\t        push({ type: 'text', value, output: value });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      let output = ')';\r\n\r\n\t      if (brace.dots === true) {\r\n\t        const arr = tokens.slice();\r\n\t        const range = [];\r\n\r\n\t        for (let i = arr.length - 1; i >= 0; i--) {\r\n\t          tokens.pop();\r\n\t          if (arr[i].type === 'brace') {\r\n\t            break;\r\n\t          }\r\n\t          if (arr[i].type !== 'dots') {\r\n\t            range.unshift(arr[i].value);\r\n\t          }\r\n\t        }\r\n\r\n\t        output = expandRange(range, opts);\r\n\t        state.backtrack = true;\r\n\t      }\r\n\r\n\t      if (brace.comma !== true && brace.dots !== true) {\r\n\t        const out = state.output.slice(0, brace.outputIndex);\r\n\t        const toks = state.tokens.slice(brace.tokensIndex);\r\n\t        brace.value = brace.output = '\\\\{';\r\n\t        value = output = '\\\\}';\r\n\t        state.output = out;\r\n\t        for (const t of toks) {\r\n\t          state.output += (t.output || t.value);\r\n\t        }\r\n\t      }\r\n\r\n\t      push({ type: 'brace', value, output });\r\n\t      decrement('braces');\r\n\t      braces.pop();\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Pipes\r\n\t     */\r\n\r\n\t    if (value === '|') {\r\n\t      if (extglobs.length > 0) {\r\n\t        extglobs[extglobs.length - 1].conditions++;\r\n\t      }\r\n\t      push({ type: 'text', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Commas\r\n\t     */\r\n\r\n\t    if (value === ',') {\r\n\t      let output = value;\r\n\r\n\t      const brace = braces[braces.length - 1];\r\n\t      if (brace && stack[stack.length - 1] === 'braces') {\r\n\t        brace.comma = true;\r\n\t        output = '|';\r\n\t      }\r\n\r\n\t      push({ type: 'comma', value, output });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Slashes\r\n\t     */\r\n\r\n\t    if (value === '/') {\r\n\t      // if the beginning of the glob is \"./\", advance the start\r\n\t      // to the current index, and don't add the \"./\" characters\r\n\t      // to the state. This greatly simplifies lookbehinds when\r\n\t      // checking for BOS characters like \"!\" and \".\" (not \"./\")\r\n\t      if (prev.type === 'dot' && state.index === state.start + 1) {\r\n\t        state.start = state.index + 1;\r\n\t        state.consumed = '';\r\n\t        state.output = '';\r\n\t        tokens.pop();\r\n\t        prev = bos; // reset \"prev\" to the first token\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'slash', value, output: SLASH_LITERAL });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Dots\r\n\t     */\r\n\r\n\t    if (value === '.') {\r\n\t      if (state.braces > 0 && prev.type === 'dot') {\r\n\t        if (prev.value === '.') prev.output = DOT_LITERAL;\r\n\t        const brace = braces[braces.length - 1];\r\n\t        prev.type = 'dots';\r\n\t        prev.output += value;\r\n\t        prev.value += value;\r\n\t        brace.dots = true;\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\r\n\t        push({ type: 'text', value, output: DOT_LITERAL });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'dot', value, output: DOT_LITERAL });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Question marks\r\n\t     */\r\n\r\n\t    if (value === '?') {\r\n\t      const isGroup = prev && prev.value === '(';\r\n\t      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\r\n\t        extglobOpen('qmark', value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prev && prev.type === 'paren') {\r\n\t        const next = peek();\r\n\t        let output = value;\r\n\r\n\t        if (next === '<' && !utils.supportsLookbehinds()) {\r\n\t          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\r\n\t        }\r\n\r\n\t        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\r\n\t          output = `\\\\${value}`;\r\n\t        }\r\n\r\n\t        push({ type: 'text', value, output });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\r\n\t        push({ type: 'qmark', value, output: QMARK_NO_DOT });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'qmark', value, output: QMARK });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Exclamation\r\n\t     */\r\n\r\n\t    if (value === '!') {\r\n\t      if (opts.noextglob !== true && peek() === '(') {\r\n\t        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\r\n\t          extglobOpen('negate', value);\r\n\t          continue;\r\n\t        }\r\n\t      }\r\n\r\n\t      if (opts.nonegate !== true && state.index === 0) {\r\n\t        negate();\r\n\t        continue;\r\n\t      }\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Plus\r\n\t     */\r\n\r\n\t    if (value === '+') {\r\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\r\n\t        extglobOpen('plus', value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if ((prev && prev.value === '(') || opts.regex === false) {\r\n\t        push({ type: 'plus', value, output: PLUS_LITERAL });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\r\n\t        push({ type: 'plus', value });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'plus', value: PLUS_LITERAL });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Plain text\r\n\t     */\r\n\r\n\t    if (value === '@') {\r\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\r\n\t        push({ type: 'at', extglob: true, value, output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'text', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Plain text\r\n\t     */\r\n\r\n\t    if (value !== '*') {\r\n\t      if (value === '$' || value === '^') {\r\n\t        value = `\\\\${value}`;\r\n\t      }\r\n\r\n\t      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\r\n\t      if (match) {\r\n\t        value += match[0];\r\n\t        state.index += match[0].length;\r\n\t      }\r\n\r\n\t      push({ type: 'text', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Stars\r\n\t     */\r\n\r\n\t    if (prev && (prev.type === 'globstar' || prev.star === true)) {\r\n\t      prev.type = 'star';\r\n\t      prev.star = true;\r\n\t      prev.value += value;\r\n\t      prev.output = star;\r\n\t      state.backtrack = true;\r\n\t      state.globstar = true;\r\n\t      consume(value);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    let rest = remaining();\r\n\t    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\r\n\t      extglobOpen('star', value);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (prev.type === 'star') {\r\n\t      if (opts.noglobstar === true) {\r\n\t        consume(value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      const prior = prev.prev;\r\n\t      const before = prior.prev;\r\n\t      const isStart = prior.type === 'slash' || prior.type === 'bos';\r\n\t      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\r\n\r\n\t      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\r\n\t        push({ type: 'star', value, output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\r\n\t      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\r\n\t      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\r\n\t        push({ type: 'star', value, output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      // strip consecutive `/**/`\r\n\t      while (rest.slice(0, 3) === '/**') {\r\n\t        const after = input[state.index + 4];\r\n\t        if (after && after !== '/') {\r\n\t          break;\r\n\t        }\r\n\t        rest = rest.slice(3);\r\n\t        consume('/**', 3);\r\n\t      }\r\n\r\n\t      if (prior.type === 'bos' && eos()) {\r\n\t        prev.type = 'globstar';\r\n\t        prev.value += value;\r\n\t        prev.output = globstar(opts);\r\n\t        state.output = prev.output;\r\n\t        state.globstar = true;\r\n\t        consume(value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\r\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\r\n\t        prior.output = `(?:${prior.output}`;\r\n\r\n\t        prev.type = 'globstar';\r\n\t        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\r\n\t        prev.value += value;\r\n\t        state.globstar = true;\r\n\t        state.output += prior.output + prev.output;\r\n\t        consume(value);\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\r\n\t        const end = rest[1] !== void 0 ? '|$' : '';\r\n\r\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\r\n\t        prior.output = `(?:${prior.output}`;\r\n\r\n\t        prev.type = 'globstar';\r\n\t        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\r\n\t        prev.value += value;\r\n\r\n\t        state.output += prior.output + prev.output;\r\n\t        state.globstar = true;\r\n\r\n\t        consume(value + advance());\r\n\r\n\t        push({ type: 'slash', value: '/', output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prior.type === 'bos' && rest[0] === '/') {\r\n\t        prev.type = 'globstar';\r\n\t        prev.value += value;\r\n\t        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\r\n\t        state.output = prev.output;\r\n\t        state.globstar = true;\r\n\t        consume(value + advance());\r\n\t        push({ type: 'slash', value: '/', output: '' });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      // remove single star from output\r\n\t      state.output = state.output.slice(0, -prev.output.length);\r\n\r\n\t      // reset previous token to globstar\r\n\t      prev.type = 'globstar';\r\n\t      prev.output = globstar(opts);\r\n\t      prev.value += value;\r\n\r\n\t      // reset output with globstar\r\n\t      state.output += prev.output;\r\n\t      state.globstar = true;\r\n\t      consume(value);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    const token = { type: 'star', value, output: star };\r\n\r\n\t    if (opts.bash === true) {\r\n\t      token.output = '.*?';\r\n\t      if (prev.type === 'bos' || prev.type === 'slash') {\r\n\t        token.output = nodot + token.output;\r\n\t      }\r\n\t      push(token);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\r\n\t      token.output = value;\r\n\t      push(token);\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\r\n\t      if (prev.type === 'dot') {\r\n\t        state.output += NO_DOT_SLASH;\r\n\t        prev.output += NO_DOT_SLASH;\r\n\r\n\t      } else if (opts.dot === true) {\r\n\t        state.output += NO_DOTS_SLASH;\r\n\t        prev.output += NO_DOTS_SLASH;\r\n\r\n\t      } else {\r\n\t        state.output += nodot;\r\n\t        prev.output += nodot;\r\n\t      }\r\n\r\n\t      if (peek() !== '*') {\r\n\t        state.output += ONE_CHAR;\r\n\t        prev.output += ONE_CHAR;\r\n\t      }\r\n\t    }\r\n\r\n\t    push(token);\r\n\t  }\r\n\r\n\t  while (state.brackets > 0) {\r\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\r\n\t    state.output = utils.escapeLast(state.output, '[');\r\n\t    decrement('brackets');\r\n\t  }\r\n\r\n\t  while (state.parens > 0) {\r\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\r\n\t    state.output = utils.escapeLast(state.output, '(');\r\n\t    decrement('parens');\r\n\t  }\r\n\r\n\t  while (state.braces > 0) {\r\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\r\n\t    state.output = utils.escapeLast(state.output, '{');\r\n\t    decrement('braces');\r\n\t  }\r\n\r\n\t  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\r\n\t    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\r\n\t  }\r\n\r\n\t  // rebuild the output if we had to backtrack at any point\r\n\t  if (state.backtrack === true) {\r\n\t    state.output = '';\r\n\r\n\t    for (const token of state.tokens) {\r\n\t      state.output += token.output != null ? token.output : token.value;\r\n\r\n\t      if (token.suffix) {\r\n\t        state.output += token.suffix;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  return state;\r\n\t};\r\n\r\n\t/**\r\n\t * Fast paths for creating regular expressions for common glob patterns.\r\n\t * This can significantly speed up processing and has very little downside\r\n\t * impact when none of the fast paths match.\r\n\t */\r\n\r\n\tparse.fastpaths = (input, options) => {\r\n\t  const opts = { ...options };\r\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\r\n\t  const len = input.length;\r\n\t  if (len > max) {\r\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\r\n\t  }\r\n\r\n\t  input = REPLACEMENTS[input] || input;\r\n\t  const win32 = utils.isWindows(options);\r\n\r\n\t  // create constants based on platform, for windows or posix\r\n\t  const {\r\n\t    DOT_LITERAL,\r\n\t    SLASH_LITERAL,\r\n\t    ONE_CHAR,\r\n\t    DOTS_SLASH,\r\n\t    NO_DOT,\r\n\t    NO_DOTS,\r\n\t    NO_DOTS_SLASH,\r\n\t    STAR,\r\n\t    START_ANCHOR\r\n\t  } = constants.globChars(win32);\r\n\r\n\t  const nodot = opts.dot ? NO_DOTS : NO_DOT;\r\n\t  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\r\n\t  const capture = opts.capture ? '' : '?:';\r\n\t  const state = { negated: false, prefix: '' };\r\n\t  let star = opts.bash === true ? '.*?' : STAR;\r\n\r\n\t  if (opts.capture) {\r\n\t    star = `(${star})`;\r\n\t  }\r\n\r\n\t  const globstar = opts => {\r\n\t    if (opts.noglobstar === true) return star;\r\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\r\n\t  };\r\n\r\n\t  const create = str => {\r\n\t    switch (str) {\r\n\t      case '*':\r\n\t        return `${nodot}${ONE_CHAR}${star}`;\r\n\r\n\t      case '.*':\r\n\t        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n\t      case '*.*':\r\n\t        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n\t      case '*/*':\r\n\t        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\r\n\r\n\t      case '**':\r\n\t        return nodot + globstar(opts);\r\n\r\n\t      case '**/*':\r\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\r\n\r\n\t      case '**/*.*':\r\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n\t      case '**/.*':\r\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\r\n\r\n\t      default: {\r\n\t        const match = /^(.*?)\\.(\\w+)$/.exec(str);\r\n\t        if (!match) return;\r\n\r\n\t        const source = create(match[1]);\r\n\t        if (!source) return;\r\n\r\n\t        return source + DOT_LITERAL + match[2];\r\n\t      }\r\n\t    }\r\n\t  };\r\n\r\n\t  const output = utils.removePrefix(input, state);\r\n\t  let source = create(output);\r\n\r\n\t  if (source && opts.strictSlashes !== true) {\r\n\t    source += `${SLASH_LITERAL}?`;\r\n\t  }\r\n\r\n\t  return source;\r\n\t};\r\n\r\n\tparse_1$1 = parse;\r\n\treturn parse_1$1;\r\n}\r\n\r\nvar picomatch_1;\r\nvar hasRequiredPicomatch$1;\r\n\r\nfunction requirePicomatch$1 () {\r\n\tif (hasRequiredPicomatch$1) return picomatch_1;\r\n\thasRequiredPicomatch$1 = 1;\r\n\r\n\tconst path = require$$0$1;\r\n\tconst scan = /*@__PURE__*/ requireScan();\r\n\tconst parse = /*@__PURE__*/ requireParse$1();\r\n\tconst utils = /*@__PURE__*/ requireUtils$1();\r\n\tconst constants = /*@__PURE__*/ requireConstants$2();\r\n\tconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\r\n\r\n\t/**\r\n\t * Creates a matcher function from one or more glob patterns. The\r\n\t * returned function takes a string to match as its first argument,\r\n\t * and returns true if the string is a match. The returned matcher\r\n\t * function also takes a boolean as the second argument that, when true,\r\n\t * returns an object with additional information.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch(glob[, options]);\r\n\t *\r\n\t * const isMatch = picomatch('*.!(*a)');\r\n\t * console.log(isMatch('a.a')); //=> false\r\n\t * console.log(isMatch('a.b')); //=> true\r\n\t * ```\r\n\t * @name picomatch\r\n\t * @param {String|Array} `globs` One or more glob patterns.\r\n\t * @param {Object=} `options`\r\n\t * @return {Function=} Returns a matcher function.\r\n\t * @api public\r\n\t */\r\n\r\n\tconst picomatch = (glob, options, returnState = false) => {\r\n\t  if (Array.isArray(glob)) {\r\n\t    const fns = glob.map(input => picomatch(input, options, returnState));\r\n\t    const arrayMatcher = str => {\r\n\t      for (const isMatch of fns) {\r\n\t        const state = isMatch(str);\r\n\t        if (state) return state;\r\n\t      }\r\n\t      return false;\r\n\t    };\r\n\t    return arrayMatcher;\r\n\t  }\r\n\r\n\t  const isState = isObject(glob) && glob.tokens && glob.input;\r\n\r\n\t  if (glob === '' || (typeof glob !== 'string' && !isState)) {\r\n\t    throw new TypeError('Expected pattern to be a non-empty string');\r\n\t  }\r\n\r\n\t  const opts = options || {};\r\n\t  const posix = utils.isWindows(options);\r\n\t  const regex = isState\r\n\t    ? picomatch.compileRe(glob, options)\r\n\t    : picomatch.makeRe(glob, options, false, true);\r\n\r\n\t  const state = regex.state;\r\n\t  delete regex.state;\r\n\r\n\t  let isIgnored = () => false;\r\n\t  if (opts.ignore) {\r\n\t    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\r\n\t    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\r\n\t  }\r\n\r\n\t  const matcher = (input, returnObject = false) => {\r\n\t    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\r\n\t    const result = { glob, state, regex, posix, input, output, match, isMatch };\r\n\r\n\t    if (typeof opts.onResult === 'function') {\r\n\t      opts.onResult(result);\r\n\t    }\r\n\r\n\t    if (isMatch === false) {\r\n\t      result.isMatch = false;\r\n\t      return returnObject ? result : false;\r\n\t    }\r\n\r\n\t    if (isIgnored(input)) {\r\n\t      if (typeof opts.onIgnore === 'function') {\r\n\t        opts.onIgnore(result);\r\n\t      }\r\n\t      result.isMatch = false;\r\n\t      return returnObject ? result : false;\r\n\t    }\r\n\r\n\t    if (typeof opts.onMatch === 'function') {\r\n\t      opts.onMatch(result);\r\n\t    }\r\n\t    return returnObject ? result : true;\r\n\t  };\r\n\r\n\t  if (returnState) {\r\n\t    matcher.state = state;\r\n\t  }\r\n\r\n\t  return matcher;\r\n\t};\r\n\r\n\t/**\r\n\t * Test `input` with the given `regex`. This is used by the main\r\n\t * `picomatch()` function to test the input string.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.test(input, regex[, options]);\r\n\t *\r\n\t * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\r\n\t * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\r\n\t * ```\r\n\t * @param {String} `input` String to test.\r\n\t * @param {RegExp} `regex`\r\n\t * @return {Object} Returns an object with matching info.\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.test = (input, regex, options, { glob, posix } = {}) => {\r\n\t  if (typeof input !== 'string') {\r\n\t    throw new TypeError('Expected input to be a string');\r\n\t  }\r\n\r\n\t  if (input === '') {\r\n\t    return { isMatch: false, output: '' };\r\n\t  }\r\n\r\n\t  const opts = options || {};\r\n\t  const format = opts.format || (posix ? utils.toPosixSlashes : null);\r\n\t  let match = input === glob;\r\n\t  let output = (match && format) ? format(input) : input;\r\n\r\n\t  if (match === false) {\r\n\t    output = format ? format(input) : input;\r\n\t    match = output === glob;\r\n\t  }\r\n\r\n\t  if (match === false || opts.capture === true) {\r\n\t    if (opts.matchBase === true || opts.basename === true) {\r\n\t      match = picomatch.matchBase(input, regex, options, posix);\r\n\t    } else {\r\n\t      match = regex.exec(output);\r\n\t    }\r\n\t  }\r\n\r\n\t  return { isMatch: Boolean(match), match, output };\r\n\t};\r\n\r\n\t/**\r\n\t * Match the basename of a filepath.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.matchBase(input, glob[, options]);\r\n\t * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\r\n\t * ```\r\n\t * @param {String} `input` String to test.\r\n\t * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\r\n\t * @return {Boolean}\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\r\n\t  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\r\n\t  return regex.test(path.basename(input));\r\n\t};\r\n\r\n\t/**\r\n\t * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.isMatch(string, patterns[, options]);\r\n\t *\r\n\t * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n\t * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\r\n\t * ```\r\n\t * @param {String|Array} str The string to test.\r\n\t * @param {String|Array} patterns One or more glob patterns to use for matching.\r\n\t * @param {Object} [options] See available [options](#options).\r\n\t * @return {Boolean} Returns true if any patterns match `str`\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\r\n\r\n\t/**\r\n\t * Parse a glob pattern to create the source string for a regular\r\n\t * expression.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * const result = picomatch.parse(pattern[, options]);\r\n\t * ```\r\n\t * @param {String} `pattern`\r\n\t * @param {Object} `options`\r\n\t * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.parse = (pattern, options) => {\r\n\t  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\r\n\t  return parse(pattern, { ...options, fastpaths: false });\r\n\t};\r\n\r\n\t/**\r\n\t * Scan a glob pattern to separate the pattern into segments.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.scan(input[, options]);\r\n\t *\r\n\t * const result = picomatch.scan('!./foo/*.js');\r\n\t * console.log(result);\r\n\t * { prefix: '!./',\r\n\t *   input: '!./foo/*.js',\r\n\t *   start: 3,\r\n\t *   base: 'foo',\r\n\t *   glob: '*.js',\r\n\t *   isBrace: false,\r\n\t *   isBracket: false,\r\n\t *   isGlob: true,\r\n\t *   isExtglob: false,\r\n\t *   isGlobstar: false,\r\n\t *   negated: true }\r\n\t * ```\r\n\t * @param {String} `input` Glob pattern to scan.\r\n\t * @param {Object} `options`\r\n\t * @return {Object} Returns an object with\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.scan = (input, options) => scan(input, options);\r\n\r\n\t/**\r\n\t * Compile a regular expression from the `state` object returned by the\r\n\t * [parse()](#parse) method.\r\n\t *\r\n\t * @param {Object} `state`\r\n\t * @param {Object} `options`\r\n\t * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\r\n\t * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\r\n\t * @return {RegExp}\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\r\n\t  if (returnOutput === true) {\r\n\t    return state.output;\r\n\t  }\r\n\r\n\t  const opts = options || {};\r\n\t  const prepend = opts.contains ? '' : '^';\r\n\t  const append = opts.contains ? '' : '$';\r\n\r\n\t  let source = `${prepend}(?:${state.output})${append}`;\r\n\t  if (state && state.negated === true) {\r\n\t    source = `^(?!${source}).*$`;\r\n\t  }\r\n\r\n\t  const regex = picomatch.toRegex(source, options);\r\n\t  if (returnState === true) {\r\n\t    regex.state = state;\r\n\t  }\r\n\r\n\t  return regex;\r\n\t};\r\n\r\n\t/**\r\n\t * Create a regular expression from a parsed glob pattern.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * const state = picomatch.parse('*.js');\r\n\t * // picomatch.compileRe(state[, options]);\r\n\t *\r\n\t * console.log(picomatch.compileRe(state));\r\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n\t * ```\r\n\t * @param {String} `state` The object returned from the `.parse` method.\r\n\t * @param {Object} `options`\r\n\t * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\r\n\t * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\r\n\t * @return {RegExp} Returns a regex created from the given pattern.\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\r\n\t  if (!input || typeof input !== 'string') {\r\n\t    throw new TypeError('Expected a non-empty string');\r\n\t  }\r\n\r\n\t  let parsed = { negated: false, fastpaths: true };\r\n\r\n\t  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\r\n\t    parsed.output = parse.fastpaths(input, options);\r\n\t  }\r\n\r\n\t  if (!parsed.output) {\r\n\t    parsed = parse(input, options);\r\n\t  }\r\n\r\n\t  return picomatch.compileRe(parsed, options, returnOutput, returnState);\r\n\t};\r\n\r\n\t/**\r\n\t * Create a regular expression from the given regex source string.\r\n\t *\r\n\t * ```js\r\n\t * const picomatch = require('picomatch');\r\n\t * // picomatch.toRegex(source[, options]);\r\n\t *\r\n\t * const { output } = picomatch.parse('*.js');\r\n\t * console.log(picomatch.toRegex(output));\r\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\r\n\t * ```\r\n\t * @param {String} `source` Regular expression source string.\r\n\t * @param {Object} `options`\r\n\t * @return {RegExp}\r\n\t * @api public\r\n\t */\r\n\r\n\tpicomatch.toRegex = (source, options) => {\r\n\t  try {\r\n\t    const opts = options || {};\r\n\t    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\r\n\t  } catch (err) {\r\n\t    if (options && options.debug === true) throw err;\r\n\t    return /$^/;\r\n\t  }\r\n\t};\r\n\r\n\t/**\r\n\t * Picomatch constants.\r\n\t * @return {Object}\r\n\t */\r\n\r\n\tpicomatch.constants = constants;\r\n\r\n\t/**\r\n\t * Expose \"picomatch\"\r\n\t */\r\n\r\n\tpicomatch_1 = picomatch;\r\n\treturn picomatch_1;\r\n}\r\n\r\nvar picomatch;\r\nvar hasRequiredPicomatch;\r\n\r\nfunction requirePicomatch () {\r\n\tif (hasRequiredPicomatch) return picomatch;\r\n\thasRequiredPicomatch = 1;\r\n\r\n\tpicomatch = /*@__PURE__*/ requirePicomatch$1();\r\n\treturn picomatch;\r\n}\r\n\r\n/*!\r\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\r\n *\r\n * Copyright (c) 2014-2018, Jon Schlinkert.\r\n * Released under the MIT License.\r\n */\r\n\r\nvar normalizePath;\r\nvar hasRequiredNormalizePath;\r\n\r\nfunction requireNormalizePath () {\r\n\tif (hasRequiredNormalizePath) return normalizePath;\r\n\thasRequiredNormalizePath = 1;\r\n\tnormalizePath = function(path, stripTrailing) {\r\n\t  if (typeof path !== 'string') {\r\n\t    throw new TypeError('expected path to be a string');\r\n\t  }\r\n\r\n\t  if (path === '\\\\' || path === '/') return '/';\r\n\r\n\t  var len = path.length;\r\n\t  if (len <= 1) return path;\r\n\r\n\t  // ensure that win32 namespaces has two leading slashes, so that the path is\r\n\t  // handled properly by the win32 version of path.parse() after being normalized\r\n\t  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\r\n\t  var prefix = '';\r\n\t  if (len > 4 && path[3] === '\\\\') {\r\n\t    var ch = path[2];\r\n\t    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\r\n\t      path = path.slice(2);\r\n\t      prefix = '//';\r\n\t    }\r\n\t  }\r\n\r\n\t  var segs = path.split(/[/\\\\]+/);\r\n\t  if (stripTrailing !== false && segs[segs.length - 1] === '') {\r\n\t    segs.pop();\r\n\t  }\r\n\t  return prefix + segs.join('/');\r\n\t};\r\n\treturn normalizePath;\r\n}\r\n\r\nvar anymatch_1 = anymatch.exports;\r\n\r\nvar hasRequiredAnymatch;\r\n\r\nfunction requireAnymatch () {\r\n\tif (hasRequiredAnymatch) return anymatch.exports;\r\n\thasRequiredAnymatch = 1;\r\n\r\n\tObject.defineProperty(anymatch_1, \"__esModule\", { value: true });\r\n\r\n\tconst picomatch = /*@__PURE__*/ requirePicomatch();\r\n\tconst normalizePath = /*@__PURE__*/ requireNormalizePath();\r\n\r\n\t/**\r\n\t * @typedef {(testString: string) => boolean} AnymatchFn\r\n\t * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\r\n\t * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\r\n\t */\r\n\tconst BANG = '!';\r\n\tconst DEFAULT_OPTIONS = {returnIndex: false};\r\n\tconst arrify = (item) => Array.isArray(item) ? item : [item];\r\n\r\n\t/**\r\n\t * @param {AnymatchPattern} matcher\r\n\t * @param {object} options\r\n\t * @returns {AnymatchFn}\r\n\t */\r\n\tconst createPattern = (matcher, options) => {\r\n\t  if (typeof matcher === 'function') {\r\n\t    return matcher;\r\n\t  }\r\n\t  if (typeof matcher === 'string') {\r\n\t    const glob = picomatch(matcher, options);\r\n\t    return (string) => matcher === string || glob(string);\r\n\t  }\r\n\t  if (matcher instanceof RegExp) {\r\n\t    return (string) => matcher.test(string);\r\n\t  }\r\n\t  return (string) => false;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {Array<Function>} patterns\r\n\t * @param {Array<Function>} negPatterns\r\n\t * @param {String|Array} args\r\n\t * @param {Boolean} returnIndex\r\n\t * @returns {boolean|number}\r\n\t */\r\n\tconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\r\n\t  const isList = Array.isArray(args);\r\n\t  const _path = isList ? args[0] : args;\r\n\t  if (!isList && typeof _path !== 'string') {\r\n\t    throw new TypeError('anymatch: second argument must be a string: got ' +\r\n\t      Object.prototype.toString.call(_path))\r\n\t  }\r\n\t  const path = normalizePath(_path, false);\r\n\r\n\t  for (let index = 0; index < negPatterns.length; index++) {\r\n\t    const nglob = negPatterns[index];\r\n\t    if (nglob(path)) {\r\n\t      return returnIndex ? -1 : false;\r\n\t    }\r\n\t  }\r\n\r\n\t  const applied = isList && [path].concat(args.slice(1));\r\n\t  for (let index = 0; index < patterns.length; index++) {\r\n\t    const pattern = patterns[index];\r\n\t    if (isList ? pattern(...applied) : pattern(path)) {\r\n\t      return returnIndex ? index : true;\r\n\t    }\r\n\t  }\r\n\r\n\t  return returnIndex ? -1 : false;\r\n\t};\r\n\r\n\t/**\r\n\t * @param {AnymatchMatcher} matchers\r\n\t * @param {Array|string} testString\r\n\t * @param {object} options\r\n\t * @returns {boolean|number|Function}\r\n\t */\r\n\tconst anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\r\n\t  if (matchers == null) {\r\n\t    throw new TypeError('anymatch: specify first argument');\r\n\t  }\r\n\t  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\r\n\t  const returnIndex = opts.returnIndex || false;\r\n\r\n\t  // Early cache for matchers.\r\n\t  const mtchers = arrify(matchers);\r\n\t  const negatedGlobs = mtchers\r\n\t    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\r\n\t    .map(item => item.slice(1))\r\n\t    .map(item => picomatch(item, opts));\r\n\t  const patterns = mtchers\r\n\t    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\r\n\t    .map(matcher => createPattern(matcher, opts));\r\n\r\n\t  if (testString == null) {\r\n\t    return (testString, ri = false) => {\r\n\t      const returnIndex = typeof ri === 'boolean' ? ri : false;\r\n\t      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\r\n\t    }\r\n\t  }\r\n\r\n\t  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\r\n\t};\r\n\r\n\tanymatch$1.default = anymatch$1;\r\n\tanymatch.exports = anymatch$1;\r\n\treturn anymatch.exports;\r\n}\r\n\r\n/*!\r\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\r\n *\r\n * Copyright (c) 2014-2016, Jon Schlinkert.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nvar isExtglob;\r\nvar hasRequiredIsExtglob;\r\n\r\nfunction requireIsExtglob () {\r\n\tif (hasRequiredIsExtglob) return isExtglob;\r\n\thasRequiredIsExtglob = 1;\r\n\tisExtglob = function isExtglob(str) {\r\n\t  if (typeof str !== 'string' || str === '') {\r\n\t    return false;\r\n\t  }\r\n\r\n\t  var match;\r\n\t  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\r\n\t    if (match[2]) return true;\r\n\t    str = str.slice(match.index + match[0].length);\r\n\t  }\r\n\r\n\t  return false;\r\n\t};\r\n\treturn isExtglob;\r\n}\r\n\r\n/*!\r\n * is-glob <https://github.com/jonschlinkert/is-glob>\r\n *\r\n * Copyright (c) 2014-2017, Jon Schlinkert.\r\n * Released under the MIT License.\r\n */\r\n\r\nvar isGlob;\r\nvar hasRequiredIsGlob;\r\n\r\nfunction requireIsGlob () {\r\n\tif (hasRequiredIsGlob) return isGlob;\r\n\thasRequiredIsGlob = 1;\r\n\tvar isExtglob = /*@__PURE__*/ requireIsExtglob();\r\n\tvar chars = { '{': '}', '(': ')', '[': ']'};\r\n\tvar strictCheck = function(str) {\r\n\t  if (str[0] === '!') {\r\n\t    return true;\r\n\t  }\r\n\t  var index = 0;\r\n\t  var pipeIndex = -2;\r\n\t  var closeSquareIndex = -2;\r\n\t  var closeCurlyIndex = -2;\r\n\t  var closeParenIndex = -2;\r\n\t  var backSlashIndex = -2;\r\n\t  while (index < str.length) {\r\n\t    if (str[index] === '*') {\r\n\t      return true;\r\n\t    }\r\n\r\n\t    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\r\n\t      return true;\r\n\t    }\r\n\r\n\t    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\r\n\t      if (closeSquareIndex < index) {\r\n\t        closeSquareIndex = str.indexOf(']', index);\r\n\t      }\r\n\t      if (closeSquareIndex > index) {\r\n\t        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\r\n\t          return true;\r\n\t        }\r\n\t        backSlashIndex = str.indexOf('\\\\', index);\r\n\t        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\r\n\t          return true;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\r\n\t    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\r\n\t      closeCurlyIndex = str.indexOf('}', index);\r\n\t      if (closeCurlyIndex > index) {\r\n\t        backSlashIndex = str.indexOf('\\\\', index);\r\n\t        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\r\n\t          return true;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\r\n\t    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\r\n\t      closeParenIndex = str.indexOf(')', index);\r\n\t      if (closeParenIndex > index) {\r\n\t        backSlashIndex = str.indexOf('\\\\', index);\r\n\t        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\r\n\t          return true;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\r\n\t    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\r\n\t      if (pipeIndex < index) {\r\n\t        pipeIndex = str.indexOf('|', index);\r\n\t      }\r\n\t      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\r\n\t        closeParenIndex = str.indexOf(')', pipeIndex);\r\n\t        if (closeParenIndex > pipeIndex) {\r\n\t          backSlashIndex = str.indexOf('\\\\', pipeIndex);\r\n\t          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\r\n\t            return true;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t    }\r\n\r\n\t    if (str[index] === '\\\\') {\r\n\t      var open = str[index + 1];\r\n\t      index += 2;\r\n\t      var close = chars[open];\r\n\r\n\t      if (close) {\r\n\t        var n = str.indexOf(close, index);\r\n\t        if (n !== -1) {\r\n\t          index = n + 1;\r\n\t        }\r\n\t      }\r\n\r\n\t      if (str[index] === '!') {\r\n\t        return true;\r\n\t      }\r\n\t    } else {\r\n\t      index++;\r\n\t    }\r\n\t  }\r\n\t  return false;\r\n\t};\r\n\r\n\tvar relaxedCheck = function(str) {\r\n\t  if (str[0] === '!') {\r\n\t    return true;\r\n\t  }\r\n\t  var index = 0;\r\n\t  while (index < str.length) {\r\n\t    if (/[*?{}()[\\]]/.test(str[index])) {\r\n\t      return true;\r\n\t    }\r\n\r\n\t    if (str[index] === '\\\\') {\r\n\t      var open = str[index + 1];\r\n\t      index += 2;\r\n\t      var close = chars[open];\r\n\r\n\t      if (close) {\r\n\t        var n = str.indexOf(close, index);\r\n\t        if (n !== -1) {\r\n\t          index = n + 1;\r\n\t        }\r\n\t      }\r\n\r\n\t      if (str[index] === '!') {\r\n\t        return true;\r\n\t      }\r\n\t    } else {\r\n\t      index++;\r\n\t    }\r\n\t  }\r\n\t  return false;\r\n\t};\r\n\r\n\tisGlob = function isGlob(str, options) {\r\n\t  if (typeof str !== 'string' || str === '') {\r\n\t    return false;\r\n\t  }\r\n\r\n\t  if (isExtglob(str)) {\r\n\t    return true;\r\n\t  }\r\n\r\n\t  var check = strictCheck;\r\n\r\n\t  // optionally relax check\r\n\t  if (options && options.strict === false) {\r\n\t    check = relaxedCheck;\r\n\t  }\r\n\r\n\t  return check(str);\r\n\t};\r\n\treturn isGlob;\r\n}\r\n\r\nvar globParent;\r\nvar hasRequiredGlobParent;\r\n\r\nfunction requireGlobParent () {\r\n\tif (hasRequiredGlobParent) return globParent;\r\n\thasRequiredGlobParent = 1;\r\n\r\n\tvar isGlob = /*@__PURE__*/ requireIsGlob();\r\n\tvar pathPosixDirname = require$$0$1.posix.dirname;\r\n\tvar isWin32 = require$$2$1.platform() === 'win32';\r\n\r\n\tvar slash = '/';\r\n\tvar backslash = /\\\\/g;\r\n\tvar enclosure = /[\\{\\[].*[\\}\\]]$/;\r\n\tvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\r\n\tvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\r\n\r\n\t/**\r\n\t * @param {string} str\r\n\t * @param {Object} opts\r\n\t * @param {boolean} [opts.flipBackslashes=true]\r\n\t * @returns {string}\r\n\t */\r\n\tglobParent = function globParent(str, opts) {\r\n\t  var options = Object.assign({ flipBackslashes: true }, opts);\r\n\r\n\t  // flip windows path separators\r\n\t  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\r\n\t    str = str.replace(backslash, slash);\r\n\t  }\r\n\r\n\t  // special case for strings ending in enclosure containing path separator\r\n\t  if (enclosure.test(str)) {\r\n\t    str += slash;\r\n\t  }\r\n\r\n\t  // preserves full path in case of trailing path separator\r\n\t  str += 'a';\r\n\r\n\t  // remove path parts that are globby\r\n\t  do {\r\n\t    str = pathPosixDirname(str);\r\n\t  } while (isGlob(str) || globby.test(str));\r\n\r\n\t  // remove escape chars and return result\r\n\t  return str.replace(escaped, '$1');\r\n\t};\r\n\treturn globParent;\r\n}\r\n\r\nvar utils = {};\r\n\r\nvar hasRequiredUtils;\r\n\r\nfunction requireUtils () {\r\n\tif (hasRequiredUtils) return utils;\r\n\thasRequiredUtils = 1;\r\n\t(function (exports) {\r\n\r\n\t\texports.isInteger = num => {\r\n\t\t  if (typeof num === 'number') {\r\n\t\t    return Number.isInteger(num);\r\n\t\t  }\r\n\t\t  if (typeof num === 'string' && num.trim() !== '') {\r\n\t\t    return Number.isInteger(Number(num));\r\n\t\t  }\r\n\t\t  return false;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Find a node of the given type\r\n\t\t */\r\n\r\n\t\texports.find = (node, type) => node.nodes.find(node => node.type === type);\r\n\r\n\t\t/**\r\n\t\t * Find a node of the given type\r\n\t\t */\r\n\r\n\t\texports.exceedsLimit = (min, max, step = 1, limit) => {\r\n\t\t  if (limit === false) return false;\r\n\t\t  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\r\n\t\t  return ((Number(max) - Number(min)) / Number(step)) >= limit;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Escape the given node with '\\\\' before node.value\r\n\t\t */\r\n\r\n\t\texports.escapeNode = (block, n = 0, type) => {\r\n\t\t  const node = block.nodes[n];\r\n\t\t  if (!node) return;\r\n\r\n\t\t  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\r\n\t\t    if (node.escaped !== true) {\r\n\t\t      node.value = '\\\\' + node.value;\r\n\t\t      node.escaped = true;\r\n\t\t    }\r\n\t\t  }\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns true if the given brace node should be enclosed in literal braces\r\n\t\t */\r\n\r\n\t\texports.encloseBrace = node => {\r\n\t\t  if (node.type !== 'brace') return false;\r\n\t\t  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\r\n\t\t    node.invalid = true;\r\n\t\t    return true;\r\n\t\t  }\r\n\t\t  return false;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns true if a brace node is invalid.\r\n\t\t */\r\n\r\n\t\texports.isInvalidBrace = block => {\r\n\t\t  if (block.type !== 'brace') return false;\r\n\t\t  if (block.invalid === true || block.dollar) return true;\r\n\t\t  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\r\n\t\t    block.invalid = true;\r\n\t\t    return true;\r\n\t\t  }\r\n\t\t  if (block.open !== true || block.close !== true) {\r\n\t\t    block.invalid = true;\r\n\t\t    return true;\r\n\t\t  }\r\n\t\t  return false;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Returns true if a node is an open or close node\r\n\t\t */\r\n\r\n\t\texports.isOpenOrClose = node => {\r\n\t\t  if (node.type === 'open' || node.type === 'close') {\r\n\t\t    return true;\r\n\t\t  }\r\n\t\t  return node.open === true || node.close === true;\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Reduce an array of text nodes.\r\n\t\t */\r\n\r\n\t\texports.reduce = nodes => nodes.reduce((acc, node) => {\r\n\t\t  if (node.type === 'text') acc.push(node.value);\r\n\t\t  if (node.type === 'range') node.type = 'text';\r\n\t\t  return acc;\r\n\t\t}, []);\r\n\r\n\t\t/**\r\n\t\t * Flatten an array\r\n\t\t */\r\n\r\n\t\texports.flatten = (...args) => {\r\n\t\t  const result = [];\r\n\r\n\t\t  const flat = arr => {\r\n\t\t    for (let i = 0; i < arr.length; i++) {\r\n\t\t      const ele = arr[i];\r\n\r\n\t\t      if (Array.isArray(ele)) {\r\n\t\t        flat(ele);\r\n\t\t        continue;\r\n\t\t      }\r\n\r\n\t\t      if (ele !== undefined) {\r\n\t\t        result.push(ele);\r\n\t\t      }\r\n\t\t    }\r\n\t\t    return result;\r\n\t\t  };\r\n\r\n\t\t  flat(args);\r\n\t\t  return result;\r\n\t\t}; \r\n\t} (utils));\r\n\treturn utils;\r\n}\r\n\r\nvar stringify;\r\nvar hasRequiredStringify;\r\n\r\nfunction requireStringify () {\r\n\tif (hasRequiredStringify) return stringify;\r\n\thasRequiredStringify = 1;\r\n\r\n\tconst utils = /*@__PURE__*/ requireUtils();\r\n\r\n\tstringify = (ast, options = {}) => {\r\n\t  const stringify = (node, parent = {}) => {\r\n\t    const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\r\n\t    const invalidNode = node.invalid === true && options.escapeInvalid === true;\r\n\t    let output = '';\r\n\r\n\t    if (node.value) {\r\n\t      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\r\n\t        return '\\\\' + node.value;\r\n\t      }\r\n\t      return node.value;\r\n\t    }\r\n\r\n\t    if (node.value) {\r\n\t      return node.value;\r\n\t    }\r\n\r\n\t    if (node.nodes) {\r\n\t      for (const child of node.nodes) {\r\n\t        output += stringify(child);\r\n\t      }\r\n\t    }\r\n\t    return output;\r\n\t  };\r\n\r\n\t  return stringify(ast);\r\n\t};\r\n\treturn stringify;\r\n}\r\n\r\n/*!\r\n * is-number <https://github.com/jonschlinkert/is-number>\r\n *\r\n * Copyright (c) 2014-present, Jon Schlinkert.\r\n * Released under the MIT License.\r\n */\r\n\r\nvar isNumber;\r\nvar hasRequiredIsNumber;\r\n\r\nfunction requireIsNumber () {\r\n\tif (hasRequiredIsNumber) return isNumber;\r\n\thasRequiredIsNumber = 1;\r\n\r\n\tisNumber = function(num) {\r\n\t  if (typeof num === 'number') {\r\n\t    return num - num === 0;\r\n\t  }\r\n\t  if (typeof num === 'string' && num.trim() !== '') {\r\n\t    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\r\n\t  }\r\n\t  return false;\r\n\t};\r\n\treturn isNumber;\r\n}\r\n\r\n/*!\r\n * to-regex-range <https://github.com/micromatch/to-regex-range>\r\n *\r\n * Copyright (c) 2015-present, Jon Schlinkert.\r\n * Released under the MIT License.\r\n */\r\n\r\nvar toRegexRange_1;\r\nvar hasRequiredToRegexRange;\r\n\r\nfunction requireToRegexRange () {\r\n\tif (hasRequiredToRegexRange) return toRegexRange_1;\r\n\thasRequiredToRegexRange = 1;\r\n\r\n\tconst isNumber = /*@__PURE__*/ requireIsNumber();\r\n\r\n\tconst toRegexRange = (min, max, options) => {\r\n\t  if (isNumber(min) === false) {\r\n\t    throw new TypeError('toRegexRange: expected the first argument to be a number');\r\n\t  }\r\n\r\n\t  if (max === void 0 || min === max) {\r\n\t    return String(min);\r\n\t  }\r\n\r\n\t  if (isNumber(max) === false) {\r\n\t    throw new TypeError('toRegexRange: expected the second argument to be a number.');\r\n\t  }\r\n\r\n\t  let opts = { relaxZeros: true, ...options };\r\n\t  if (typeof opts.strictZeros === 'boolean') {\r\n\t    opts.relaxZeros = opts.strictZeros === false;\r\n\t  }\r\n\r\n\t  let relax = String(opts.relaxZeros);\r\n\t  let shorthand = String(opts.shorthand);\r\n\t  let capture = String(opts.capture);\r\n\t  let wrap = String(opts.wrap);\r\n\t  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\r\n\r\n\t  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\r\n\t    return toRegexRange.cache[cacheKey].result;\r\n\t  }\r\n\r\n\t  let a = Math.min(min, max);\r\n\t  let b = Math.max(min, max);\r\n\r\n\t  if (Math.abs(a - b) === 1) {\r\n\t    let result = min + '|' + max;\r\n\t    if (opts.capture) {\r\n\t      return `(${result})`;\r\n\t    }\r\n\t    if (opts.wrap === false) {\r\n\t      return result;\r\n\t    }\r\n\t    return `(?:${result})`;\r\n\t  }\r\n\r\n\t  let isPadded = hasPadding(min) || hasPadding(max);\r\n\t  let state = { min, max, a, b };\r\n\t  let positives = [];\r\n\t  let negatives = [];\r\n\r\n\t  if (isPadded) {\r\n\t    state.isPadded = isPadded;\r\n\t    state.maxLen = String(state.max).length;\r\n\t  }\r\n\r\n\t  if (a < 0) {\r\n\t    let newMin = b < 0 ? Math.abs(b) : 1;\r\n\t    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\r\n\t    a = state.a = 0;\r\n\t  }\r\n\r\n\t  if (b >= 0) {\r\n\t    positives = splitToPatterns(a, b, state, opts);\r\n\t  }\r\n\r\n\t  state.negatives = negatives;\r\n\t  state.positives = positives;\r\n\t  state.result = collatePatterns(negatives, positives);\r\n\r\n\t  if (opts.capture === true) {\r\n\t    state.result = `(${state.result})`;\r\n\t  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\r\n\t    state.result = `(?:${state.result})`;\r\n\t  }\r\n\r\n\t  toRegexRange.cache[cacheKey] = state;\r\n\t  return state.result;\r\n\t};\r\n\r\n\tfunction collatePatterns(neg, pos, options) {\r\n\t  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\r\n\t  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\r\n\t  let intersected = filterPatterns(neg, pos, '-?', true) || [];\r\n\t  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\r\n\t  return subpatterns.join('|');\r\n\t}\r\n\r\n\tfunction splitToRanges(min, max) {\r\n\t  let nines = 1;\r\n\t  let zeros = 1;\r\n\r\n\t  let stop = countNines(min, nines);\r\n\t  let stops = new Set([max]);\r\n\r\n\t  while (min <= stop && stop <= max) {\r\n\t    stops.add(stop);\r\n\t    nines += 1;\r\n\t    stop = countNines(min, nines);\r\n\t  }\r\n\r\n\t  stop = countZeros(max + 1, zeros) - 1;\r\n\r\n\t  while (min < stop && stop <= max) {\r\n\t    stops.add(stop);\r\n\t    zeros += 1;\r\n\t    stop = countZeros(max + 1, zeros) - 1;\r\n\t  }\r\n\r\n\t  stops = [...stops];\r\n\t  stops.sort(compare);\r\n\t  return stops;\r\n\t}\r\n\r\n\t/**\r\n\t * Convert a range to a regex pattern\r\n\t * @param {Number} `start`\r\n\t * @param {Number} `stop`\r\n\t * @return {String}\r\n\t */\r\n\r\n\tfunction rangeToPattern(start, stop, options) {\r\n\t  if (start === stop) {\r\n\t    return { pattern: start, count: [], digits: 0 };\r\n\t  }\r\n\r\n\t  let zipped = zip(start, stop);\r\n\t  let digits = zipped.length;\r\n\t  let pattern = '';\r\n\t  let count = 0;\r\n\r\n\t  for (let i = 0; i < digits; i++) {\r\n\t    let [startDigit, stopDigit] = zipped[i];\r\n\r\n\t    if (startDigit === stopDigit) {\r\n\t      pattern += startDigit;\r\n\r\n\t    } else if (startDigit !== '0' || stopDigit !== '9') {\r\n\t      pattern += toCharacterClass(startDigit, stopDigit);\r\n\r\n\t    } else {\r\n\t      count++;\r\n\t    }\r\n\t  }\r\n\r\n\t  if (count) {\r\n\t    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\r\n\t  }\r\n\r\n\t  return { pattern, count: [count], digits };\r\n\t}\r\n\r\n\tfunction splitToPatterns(min, max, tok, options) {\r\n\t  let ranges = splitToRanges(min, max);\r\n\t  let tokens = [];\r\n\t  let start = min;\r\n\t  let prev;\r\n\r\n\t  for (let i = 0; i < ranges.length; i++) {\r\n\t    let max = ranges[i];\r\n\t    let obj = rangeToPattern(String(start), String(max), options);\r\n\t    let zeros = '';\r\n\r\n\t    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\r\n\t      if (prev.count.length > 1) {\r\n\t        prev.count.pop();\r\n\t      }\r\n\r\n\t      prev.count.push(obj.count[0]);\r\n\t      prev.string = prev.pattern + toQuantifier(prev.count);\r\n\t      start = max + 1;\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (tok.isPadded) {\r\n\t      zeros = padZeros(max, tok, options);\r\n\t    }\r\n\r\n\t    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\r\n\t    tokens.push(obj);\r\n\t    start = max + 1;\r\n\t    prev = obj;\r\n\t  }\r\n\r\n\t  return tokens;\r\n\t}\r\n\r\n\tfunction filterPatterns(arr, comparison, prefix, intersection, options) {\r\n\t  let result = [];\r\n\r\n\t  for (let ele of arr) {\r\n\t    let { string } = ele;\r\n\r\n\t    // only push if _both_ are negative...\r\n\t    if (!intersection && !contains(comparison, 'string', string)) {\r\n\t      result.push(prefix + string);\r\n\t    }\r\n\r\n\t    // or _both_ are positive\r\n\t    if (intersection && contains(comparison, 'string', string)) {\r\n\t      result.push(prefix + string);\r\n\t    }\r\n\t  }\r\n\t  return result;\r\n\t}\r\n\r\n\t/**\r\n\t * Zip strings\r\n\t */\r\n\r\n\tfunction zip(a, b) {\r\n\t  let arr = [];\r\n\t  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\r\n\t  return arr;\r\n\t}\r\n\r\n\tfunction compare(a, b) {\r\n\t  return a > b ? 1 : b > a ? -1 : 0;\r\n\t}\r\n\r\n\tfunction contains(arr, key, val) {\r\n\t  return arr.some(ele => ele[key] === val);\r\n\t}\r\n\r\n\tfunction countNines(min, len) {\r\n\t  return Number(String(min).slice(0, -len) + '9'.repeat(len));\r\n\t}\r\n\r\n\tfunction countZeros(integer, zeros) {\r\n\t  return integer - (integer % Math.pow(10, zeros));\r\n\t}\r\n\r\n\tfunction toQuantifier(digits) {\r\n\t  let [start = 0, stop = ''] = digits;\r\n\t  if (stop || start > 1) {\r\n\t    return `{${start + (stop ? ',' + stop : '')}}`;\r\n\t  }\r\n\t  return '';\r\n\t}\r\n\r\n\tfunction toCharacterClass(a, b, options) {\r\n\t  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\r\n\t}\r\n\r\n\tfunction hasPadding(str) {\r\n\t  return /^-?(0+)\\d/.test(str);\r\n\t}\r\n\r\n\tfunction padZeros(value, tok, options) {\r\n\t  if (!tok.isPadded) {\r\n\t    return value;\r\n\t  }\r\n\r\n\t  let diff = Math.abs(tok.maxLen - String(value).length);\r\n\t  let relax = options.relaxZeros !== false;\r\n\r\n\t  switch (diff) {\r\n\t    case 0:\r\n\t      return '';\r\n\t    case 1:\r\n\t      return relax ? '0?' : '0';\r\n\t    case 2:\r\n\t      return relax ? '0{0,2}' : '00';\r\n\t    default: {\r\n\t      return relax ? `0{0,${diff}}` : `0{${diff}}`;\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Cache\r\n\t */\r\n\r\n\ttoRegexRange.cache = {};\r\n\ttoRegexRange.clearCache = () => (toRegexRange.cache = {});\r\n\r\n\t/**\r\n\t * Expose `toRegexRange`\r\n\t */\r\n\r\n\ttoRegexRange_1 = toRegexRange;\r\n\treturn toRegexRange_1;\r\n}\r\n\r\n/*!\r\n * fill-range <https://github.com/jonschlinkert/fill-range>\r\n *\r\n * Copyright (c) 2014-present, Jon Schlinkert.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nvar fillRange;\r\nvar hasRequiredFillRange;\r\n\r\nfunction requireFillRange () {\r\n\tif (hasRequiredFillRange) return fillRange;\r\n\thasRequiredFillRange = 1;\r\n\r\n\tconst util = require$$2;\r\n\tconst toRegexRange = /*@__PURE__*/ requireToRegexRange();\r\n\r\n\tconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\r\n\r\n\tconst transform = toNumber => {\r\n\t  return value => toNumber === true ? Number(value) : String(value);\r\n\t};\r\n\r\n\tconst isValidValue = value => {\r\n\t  return typeof value === 'number' || (typeof value === 'string' && value !== '');\r\n\t};\r\n\r\n\tconst isNumber = num => Number.isInteger(+num);\r\n\r\n\tconst zeros = input => {\r\n\t  let value = `${input}`;\r\n\t  let index = -1;\r\n\t  if (value[0] === '-') value = value.slice(1);\r\n\t  if (value === '0') return false;\r\n\t  while (value[++index] === '0');\r\n\t  return index > 0;\r\n\t};\r\n\r\n\tconst stringify = (start, end, options) => {\r\n\t  if (typeof start === 'string' || typeof end === 'string') {\r\n\t    return true;\r\n\t  }\r\n\t  return options.stringify === true;\r\n\t};\r\n\r\n\tconst pad = (input, maxLength, toNumber) => {\r\n\t  if (maxLength > 0) {\r\n\t    let dash = input[0] === '-' ? '-' : '';\r\n\t    if (dash) input = input.slice(1);\r\n\t    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\r\n\t  }\r\n\t  if (toNumber === false) {\r\n\t    return String(input);\r\n\t  }\r\n\t  return input;\r\n\t};\r\n\r\n\tconst toMaxLen = (input, maxLength) => {\r\n\t  let negative = input[0] === '-' ? '-' : '';\r\n\t  if (negative) {\r\n\t    input = input.slice(1);\r\n\t    maxLength--;\r\n\t  }\r\n\t  while (input.length < maxLength) input = '0' + input;\r\n\t  return negative ? ('-' + input) : input;\r\n\t};\r\n\r\n\tconst toSequence = (parts, options, maxLen) => {\r\n\t  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\r\n\t  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\r\n\r\n\t  let prefix = options.capture ? '' : '?:';\r\n\t  let positives = '';\r\n\t  let negatives = '';\r\n\t  let result;\r\n\r\n\t  if (parts.positives.length) {\r\n\t    positives = parts.positives.map(v => toMaxLen(String(v), maxLen)).join('|');\r\n\t  }\r\n\r\n\t  if (parts.negatives.length) {\r\n\t    negatives = `-(${prefix}${parts.negatives.map(v => toMaxLen(String(v), maxLen)).join('|')})`;\r\n\t  }\r\n\r\n\t  if (positives && negatives) {\r\n\t    result = `${positives}|${negatives}`;\r\n\t  } else {\r\n\t    result = positives || negatives;\r\n\t  }\r\n\r\n\t  if (options.wrap) {\r\n\t    return `(${prefix}${result})`;\r\n\t  }\r\n\r\n\t  return result;\r\n\t};\r\n\r\n\tconst toRange = (a, b, isNumbers, options) => {\r\n\t  if (isNumbers) {\r\n\t    return toRegexRange(a, b, { wrap: false, ...options });\r\n\t  }\r\n\r\n\t  let start = String.fromCharCode(a);\r\n\t  if (a === b) return start;\r\n\r\n\t  let stop = String.fromCharCode(b);\r\n\t  return `[${start}-${stop}]`;\r\n\t};\r\n\r\n\tconst toRegex = (start, end, options) => {\r\n\t  if (Array.isArray(start)) {\r\n\t    let wrap = options.wrap === true;\r\n\t    let prefix = options.capture ? '' : '?:';\r\n\t    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\r\n\t  }\r\n\t  return toRegexRange(start, end, options);\r\n\t};\r\n\r\n\tconst rangeError = (...args) => {\r\n\t  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\r\n\t};\r\n\r\n\tconst invalidRange = (start, end, options) => {\r\n\t  if (options.strictRanges === true) throw rangeError([start, end]);\r\n\t  return [];\r\n\t};\r\n\r\n\tconst invalidStep = (step, options) => {\r\n\t  if (options.strictRanges === true) {\r\n\t    throw new TypeError(`Expected step \"${step}\" to be a number`);\r\n\t  }\r\n\t  return [];\r\n\t};\r\n\r\n\tconst fillNumbers = (start, end, step = 1, options = {}) => {\r\n\t  let a = Number(start);\r\n\t  let b = Number(end);\r\n\r\n\t  if (!Number.isInteger(a) || !Number.isInteger(b)) {\r\n\t    if (options.strictRanges === true) throw rangeError([start, end]);\r\n\t    return [];\r\n\t  }\r\n\r\n\t  // fix negative zero\r\n\t  if (a === 0) a = 0;\r\n\t  if (b === 0) b = 0;\r\n\r\n\t  let descending = a > b;\r\n\t  let startString = String(start);\r\n\t  let endString = String(end);\r\n\t  let stepString = String(step);\r\n\t  step = Math.max(Math.abs(step), 1);\r\n\r\n\t  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\r\n\t  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\r\n\t  let toNumber = padded === false && stringify(start, end, options) === false;\r\n\t  let format = options.transform || transform(toNumber);\r\n\r\n\t  if (options.toRegex && step === 1) {\r\n\t    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\r\n\t  }\r\n\r\n\t  let parts = { negatives: [], positives: [] };\r\n\t  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\r\n\t  let range = [];\r\n\t  let index = 0;\r\n\r\n\t  while (descending ? a >= b : a <= b) {\r\n\t    if (options.toRegex === true && step > 1) {\r\n\t      push(a);\r\n\t    } else {\r\n\t      range.push(pad(format(a, index), maxLen, toNumber));\r\n\t    }\r\n\t    a = descending ? a - step : a + step;\r\n\t    index++;\r\n\t  }\r\n\r\n\t  if (options.toRegex === true) {\r\n\t    return step > 1\r\n\t      ? toSequence(parts, options, maxLen)\r\n\t      : toRegex(range, null, { wrap: false, ...options });\r\n\t  }\r\n\r\n\t  return range;\r\n\t};\r\n\r\n\tconst fillLetters = (start, end, step = 1, options = {}) => {\r\n\t  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\r\n\t    return invalidRange(start, end, options);\r\n\t  }\r\n\r\n\t  let format = options.transform || (val => String.fromCharCode(val));\r\n\t  let a = `${start}`.charCodeAt(0);\r\n\t  let b = `${end}`.charCodeAt(0);\r\n\r\n\t  let descending = a > b;\r\n\t  let min = Math.min(a, b);\r\n\t  let max = Math.max(a, b);\r\n\r\n\t  if (options.toRegex && step === 1) {\r\n\t    return toRange(min, max, false, options);\r\n\t  }\r\n\r\n\t  let range = [];\r\n\t  let index = 0;\r\n\r\n\t  while (descending ? a >= b : a <= b) {\r\n\t    range.push(format(a, index));\r\n\t    a = descending ? a - step : a + step;\r\n\t    index++;\r\n\t  }\r\n\r\n\t  if (options.toRegex === true) {\r\n\t    return toRegex(range, null, { wrap: false, options });\r\n\t  }\r\n\r\n\t  return range;\r\n\t};\r\n\r\n\tconst fill = (start, end, step, options = {}) => {\r\n\t  if (end == null && isValidValue(start)) {\r\n\t    return [start];\r\n\t  }\r\n\r\n\t  if (!isValidValue(start) || !isValidValue(end)) {\r\n\t    return invalidRange(start, end, options);\r\n\t  }\r\n\r\n\t  if (typeof step === 'function') {\r\n\t    return fill(start, end, 1, { transform: step });\r\n\t  }\r\n\r\n\t  if (isObject(step)) {\r\n\t    return fill(start, end, 0, step);\r\n\t  }\r\n\r\n\t  let opts = { ...options };\r\n\t  if (opts.capture === true) opts.wrap = true;\r\n\t  step = step || opts.step || 1;\r\n\r\n\t  if (!isNumber(step)) {\r\n\t    if (step != null && !isObject(step)) return invalidStep(step, opts);\r\n\t    return fill(start, end, 1, step);\r\n\t  }\r\n\r\n\t  if (isNumber(start) && isNumber(end)) {\r\n\t    return fillNumbers(start, end, step, opts);\r\n\t  }\r\n\r\n\t  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\r\n\t};\r\n\r\n\tfillRange = fill;\r\n\treturn fillRange;\r\n}\r\n\r\nvar compile_1;\r\nvar hasRequiredCompile;\r\n\r\nfunction requireCompile () {\r\n\tif (hasRequiredCompile) return compile_1;\r\n\thasRequiredCompile = 1;\r\n\r\n\tconst fill = /*@__PURE__*/ requireFillRange();\r\n\tconst utils = /*@__PURE__*/ requireUtils();\r\n\r\n\tconst compile = (ast, options = {}) => {\r\n\t  const walk = (node, parent = {}) => {\r\n\t    const invalidBlock = utils.isInvalidBrace(parent);\r\n\t    const invalidNode = node.invalid === true && options.escapeInvalid === true;\r\n\t    const invalid = invalidBlock === true || invalidNode === true;\r\n\t    const prefix = options.escapeInvalid === true ? '\\\\' : '';\r\n\t    let output = '';\r\n\r\n\t    if (node.isOpen === true) {\r\n\t      return prefix + node.value;\r\n\t    }\r\n\r\n\t    if (node.isClose === true) {\r\n\t      console.log('node.isClose', prefix, node.value);\r\n\t      return prefix + node.value;\r\n\t    }\r\n\r\n\t    if (node.type === 'open') {\r\n\t      return invalid ? prefix + node.value : '(';\r\n\t    }\r\n\r\n\t    if (node.type === 'close') {\r\n\t      return invalid ? prefix + node.value : ')';\r\n\t    }\r\n\r\n\t    if (node.type === 'comma') {\r\n\t      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\r\n\t    }\r\n\r\n\t    if (node.value) {\r\n\t      return node.value;\r\n\t    }\r\n\r\n\t    if (node.nodes && node.ranges > 0) {\r\n\t      const args = utils.reduce(node.nodes);\r\n\t      const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });\r\n\r\n\t      if (range.length !== 0) {\r\n\t        return args.length > 1 && range.length > 1 ? `(${range})` : range;\r\n\t      }\r\n\t    }\r\n\r\n\t    if (node.nodes) {\r\n\t      for (const child of node.nodes) {\r\n\t        output += walk(child, node);\r\n\t      }\r\n\t    }\r\n\r\n\t    return output;\r\n\t  };\r\n\r\n\t  return walk(ast);\r\n\t};\r\n\r\n\tcompile_1 = compile;\r\n\treturn compile_1;\r\n}\r\n\r\nvar expand_1;\r\nvar hasRequiredExpand;\r\n\r\nfunction requireExpand () {\r\n\tif (hasRequiredExpand) return expand_1;\r\n\thasRequiredExpand = 1;\r\n\r\n\tconst fill = /*@__PURE__*/ requireFillRange();\r\n\tconst stringify = /*@__PURE__*/ requireStringify();\r\n\tconst utils = /*@__PURE__*/ requireUtils();\r\n\r\n\tconst append = (queue = '', stash = '', enclose = false) => {\r\n\t  const result = [];\r\n\r\n\t  queue = [].concat(queue);\r\n\t  stash = [].concat(stash);\r\n\r\n\t  if (!stash.length) return queue;\r\n\t  if (!queue.length) {\r\n\t    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\r\n\t  }\r\n\r\n\t  for (const item of queue) {\r\n\t    if (Array.isArray(item)) {\r\n\t      for (const value of item) {\r\n\t        result.push(append(value, stash, enclose));\r\n\t      }\r\n\t    } else {\r\n\t      for (let ele of stash) {\r\n\t        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\r\n\t        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t  return utils.flatten(result);\r\n\t};\r\n\r\n\tconst expand = (ast, options = {}) => {\r\n\t  const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;\r\n\r\n\t  const walk = (node, parent = {}) => {\r\n\t    node.queue = [];\r\n\r\n\t    let p = parent;\r\n\t    let q = parent.queue;\r\n\r\n\t    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\r\n\t      p = p.parent;\r\n\t      q = p.queue;\r\n\t    }\r\n\r\n\t    if (node.invalid || node.dollar) {\r\n\t      q.push(append(q.pop(), stringify(node, options)));\r\n\t      return;\r\n\t    }\r\n\r\n\t    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\r\n\t      q.push(append(q.pop(), ['{}']));\r\n\t      return;\r\n\t    }\r\n\r\n\t    if (node.nodes && node.ranges > 0) {\r\n\t      const args = utils.reduce(node.nodes);\r\n\r\n\t      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\r\n\t        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\r\n\t      }\r\n\r\n\t      let range = fill(...args, options);\r\n\t      if (range.length === 0) {\r\n\t        range = stringify(node, options);\r\n\t      }\r\n\r\n\t      q.push(append(q.pop(), range));\r\n\t      node.nodes = [];\r\n\t      return;\r\n\t    }\r\n\r\n\t    const enclose = utils.encloseBrace(node);\r\n\t    let queue = node.queue;\r\n\t    let block = node;\r\n\r\n\t    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\r\n\t      block = block.parent;\r\n\t      queue = block.queue;\r\n\t    }\r\n\r\n\t    for (let i = 0; i < node.nodes.length; i++) {\r\n\t      const child = node.nodes[i];\r\n\r\n\t      if (child.type === 'comma' && node.type === 'brace') {\r\n\t        if (i === 1) queue.push('');\r\n\t        queue.push('');\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (child.type === 'close') {\r\n\t        q.push(append(q.pop(), queue, enclose));\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (child.value && child.type !== 'open') {\r\n\t        queue.push(append(queue.pop(), child.value));\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (child.nodes) {\r\n\t        walk(child, node);\r\n\t      }\r\n\t    }\r\n\r\n\t    return queue;\r\n\t  };\r\n\r\n\t  return utils.flatten(walk(ast));\r\n\t};\r\n\r\n\texpand_1 = expand;\r\n\treturn expand_1;\r\n}\r\n\r\nvar constants$1;\r\nvar hasRequiredConstants$1;\r\n\r\nfunction requireConstants$1 () {\r\n\tif (hasRequiredConstants$1) return constants$1;\r\n\thasRequiredConstants$1 = 1;\r\n\r\n\tconstants$1 = {\r\n\t  MAX_LENGTH: 10000,\r\n\r\n\t  // Digits\r\n\t  CHAR_0: '0', /* 0 */\r\n\t  CHAR_9: '9', /* 9 */\r\n\r\n\t  // Alphabet chars.\r\n\t  CHAR_UPPERCASE_A: 'A', /* A */\r\n\t  CHAR_LOWERCASE_A: 'a', /* a */\r\n\t  CHAR_UPPERCASE_Z: 'Z', /* Z */\r\n\t  CHAR_LOWERCASE_Z: 'z', /* z */\r\n\r\n\t  CHAR_LEFT_PARENTHESES: '(', /* ( */\r\n\t  CHAR_RIGHT_PARENTHESES: ')', /* ) */\r\n\r\n\t  CHAR_ASTERISK: '*', /* * */\r\n\r\n\t  // Non-alphabetic chars.\r\n\t  CHAR_AMPERSAND: '&', /* & */\r\n\t  CHAR_AT: '@', /* @ */\r\n\t  CHAR_BACKSLASH: '\\\\', /* \\ */\r\n\t  CHAR_BACKTICK: '`', /* ` */\r\n\t  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\r\n\t  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\r\n\t  CHAR_COLON: ':', /* : */\r\n\t  CHAR_COMMA: ',', /* , */\r\n\t  CHAR_DOLLAR: '$', /* . */\r\n\t  CHAR_DOT: '.', /* . */\r\n\t  CHAR_DOUBLE_QUOTE: '\"', /* \" */\r\n\t  CHAR_EQUAL: '=', /* = */\r\n\t  CHAR_EXCLAMATION_MARK: '!', /* ! */\r\n\t  CHAR_FORM_FEED: '\\f', /* \\f */\r\n\t  CHAR_FORWARD_SLASH: '/', /* / */\r\n\t  CHAR_HASH: '#', /* # */\r\n\t  CHAR_HYPHEN_MINUS: '-', /* - */\r\n\t  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\r\n\t  CHAR_LEFT_CURLY_BRACE: '{', /* { */\r\n\t  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\r\n\t  CHAR_LINE_FEED: '\\n', /* \\n */\r\n\t  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\r\n\t  CHAR_PERCENT: '%', /* % */\r\n\t  CHAR_PLUS: '+', /* + */\r\n\t  CHAR_QUESTION_MARK: '?', /* ? */\r\n\t  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\r\n\t  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\r\n\t  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\r\n\t  CHAR_SEMICOLON: ';', /* ; */\r\n\t  CHAR_SINGLE_QUOTE: '\\'', /* ' */\r\n\t  CHAR_SPACE: ' ', /*   */\r\n\t  CHAR_TAB: '\\t', /* \\t */\r\n\t  CHAR_UNDERSCORE: '_', /* _ */\r\n\t  CHAR_VERTICAL_LINE: '|', /* | */\r\n\t  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\r\n\t};\r\n\treturn constants$1;\r\n}\r\n\r\nvar parse_1;\r\nvar hasRequiredParse;\r\n\r\nfunction requireParse () {\r\n\tif (hasRequiredParse) return parse_1;\r\n\thasRequiredParse = 1;\r\n\r\n\tconst stringify = /*@__PURE__*/ requireStringify();\r\n\r\n\t/**\r\n\t * Constants\r\n\t */\r\n\r\n\tconst {\r\n\t  MAX_LENGTH,\r\n\t  CHAR_BACKSLASH, /* \\ */\r\n\t  CHAR_BACKTICK, /* ` */\r\n\t  CHAR_COMMA, /* , */\r\n\t  CHAR_DOT, /* . */\r\n\t  CHAR_LEFT_PARENTHESES, /* ( */\r\n\t  CHAR_RIGHT_PARENTHESES, /* ) */\r\n\t  CHAR_LEFT_CURLY_BRACE, /* { */\r\n\t  CHAR_RIGHT_CURLY_BRACE, /* } */\r\n\t  CHAR_LEFT_SQUARE_BRACKET, /* [ */\r\n\t  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\r\n\t  CHAR_DOUBLE_QUOTE, /* \" */\r\n\t  CHAR_SINGLE_QUOTE, /* ' */\r\n\t  CHAR_NO_BREAK_SPACE,\r\n\t  CHAR_ZERO_WIDTH_NOBREAK_SPACE\r\n\t} = /*@__PURE__*/ requireConstants$1();\r\n\r\n\t/**\r\n\t * parse\r\n\t */\r\n\r\n\tconst parse = (input, options = {}) => {\r\n\t  if (typeof input !== 'string') {\r\n\t    throw new TypeError('Expected a string');\r\n\t  }\r\n\r\n\t  const opts = options || {};\r\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\r\n\t  if (input.length > max) {\r\n\t    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\r\n\t  }\r\n\r\n\t  const ast = { type: 'root', input, nodes: [] };\r\n\t  const stack = [ast];\r\n\t  let block = ast;\r\n\t  let prev = ast;\r\n\t  let brackets = 0;\r\n\t  const length = input.length;\r\n\t  let index = 0;\r\n\t  let depth = 0;\r\n\t  let value;\r\n\r\n\t  /**\r\n\t   * Helpers\r\n\t   */\r\n\r\n\t  const advance = () => input[index++];\r\n\t  const push = node => {\r\n\t    if (node.type === 'text' && prev.type === 'dot') {\r\n\t      prev.type = 'text';\r\n\t    }\r\n\r\n\t    if (prev && prev.type === 'text' && node.type === 'text') {\r\n\t      prev.value += node.value;\r\n\t      return;\r\n\t    }\r\n\r\n\t    block.nodes.push(node);\r\n\t    node.parent = block;\r\n\t    node.prev = prev;\r\n\t    prev = node;\r\n\t    return node;\r\n\t  };\r\n\r\n\t  push({ type: 'bos' });\r\n\r\n\t  while (index < length) {\r\n\t    block = stack[stack.length - 1];\r\n\t    value = advance();\r\n\r\n\t    /**\r\n\t     * Invalid chars\r\n\t     */\r\n\r\n\t    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Escaped chars\r\n\t     */\r\n\r\n\t    if (value === CHAR_BACKSLASH) {\r\n\t      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Right square bracket (literal): ']'\r\n\t     */\r\n\r\n\t    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\r\n\t      push({ type: 'text', value: '\\\\' + value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Left square bracket: '['\r\n\t     */\r\n\r\n\t    if (value === CHAR_LEFT_SQUARE_BRACKET) {\r\n\t      brackets++;\r\n\r\n\t      let next;\r\n\r\n\t      while (index < length && (next = advance())) {\r\n\t        value += next;\r\n\r\n\t        if (next === CHAR_LEFT_SQUARE_BRACKET) {\r\n\t          brackets++;\r\n\t          continue;\r\n\t        }\r\n\r\n\t        if (next === CHAR_BACKSLASH) {\r\n\t          value += advance();\r\n\t          continue;\r\n\t        }\r\n\r\n\t        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\r\n\t          brackets--;\r\n\r\n\t          if (brackets === 0) {\r\n\t            break;\r\n\t          }\r\n\t        }\r\n\t      }\r\n\r\n\t      push({ type: 'text', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Parentheses\r\n\t     */\r\n\r\n\t    if (value === CHAR_LEFT_PARENTHESES) {\r\n\t      block = push({ type: 'paren', nodes: [] });\r\n\t      stack.push(block);\r\n\t      push({ type: 'text', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    if (value === CHAR_RIGHT_PARENTHESES) {\r\n\t      if (block.type !== 'paren') {\r\n\t        push({ type: 'text', value });\r\n\t        continue;\r\n\t      }\r\n\t      block = stack.pop();\r\n\t      push({ type: 'text', value });\r\n\t      block = stack[stack.length - 1];\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Quotes: '|\"|`\r\n\t     */\r\n\r\n\t    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\r\n\t      const open = value;\r\n\t      let next;\r\n\r\n\t      if (options.keepQuotes !== true) {\r\n\t        value = '';\r\n\t      }\r\n\r\n\t      while (index < length && (next = advance())) {\r\n\t        if (next === CHAR_BACKSLASH) {\r\n\t          value += next + advance();\r\n\t          continue;\r\n\t        }\r\n\r\n\t        if (next === open) {\r\n\t          if (options.keepQuotes === true) value += next;\r\n\t          break;\r\n\t        }\r\n\r\n\t        value += next;\r\n\t      }\r\n\r\n\t      push({ type: 'text', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Left curly brace: '{'\r\n\t     */\r\n\r\n\t    if (value === CHAR_LEFT_CURLY_BRACE) {\r\n\t      depth++;\r\n\r\n\t      const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\r\n\t      const brace = {\r\n\t        type: 'brace',\r\n\t        open: true,\r\n\t        close: false,\r\n\t        dollar,\r\n\t        depth,\r\n\t        commas: 0,\r\n\t        ranges: 0,\r\n\t        nodes: []\r\n\t      };\r\n\r\n\t      block = push(brace);\r\n\t      stack.push(block);\r\n\t      push({ type: 'open', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Right curly brace: '}'\r\n\t     */\r\n\r\n\t    if (value === CHAR_RIGHT_CURLY_BRACE) {\r\n\t      if (block.type !== 'brace') {\r\n\t        push({ type: 'text', value });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      const type = 'close';\r\n\t      block = stack.pop();\r\n\t      block.close = true;\r\n\r\n\t      push({ type, value });\r\n\t      depth--;\r\n\r\n\t      block = stack[stack.length - 1];\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Comma: ','\r\n\t     */\r\n\r\n\t    if (value === CHAR_COMMA && depth > 0) {\r\n\t      if (block.ranges > 0) {\r\n\t        block.ranges = 0;\r\n\t        const open = block.nodes.shift();\r\n\t        block.nodes = [open, { type: 'text', value: stringify(block) }];\r\n\t      }\r\n\r\n\t      push({ type: 'comma', value });\r\n\t      block.commas++;\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Dot: '.'\r\n\t     */\r\n\r\n\t    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\r\n\t      const siblings = block.nodes;\r\n\r\n\t      if (depth === 0 || siblings.length === 0) {\r\n\t        push({ type: 'text', value });\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prev.type === 'dot') {\r\n\t        block.range = [];\r\n\t        prev.value += value;\r\n\t        prev.type = 'range';\r\n\r\n\t        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\r\n\t          block.invalid = true;\r\n\t          block.ranges = 0;\r\n\t          prev.type = 'text';\r\n\t          continue;\r\n\t        }\r\n\r\n\t        block.ranges++;\r\n\t        block.args = [];\r\n\t        continue;\r\n\t      }\r\n\r\n\t      if (prev.type === 'range') {\r\n\t        siblings.pop();\r\n\r\n\t        const before = siblings[siblings.length - 1];\r\n\t        before.value += prev.value + value;\r\n\t        prev = before;\r\n\t        block.ranges--;\r\n\t        continue;\r\n\t      }\r\n\r\n\t      push({ type: 'dot', value });\r\n\t      continue;\r\n\t    }\r\n\r\n\t    /**\r\n\t     * Text\r\n\t     */\r\n\r\n\t    push({ type: 'text', value });\r\n\t  }\r\n\r\n\t  // Mark imbalanced braces and brackets as invalid\r\n\t  do {\r\n\t    block = stack.pop();\r\n\r\n\t    if (block.type !== 'root') {\r\n\t      block.nodes.forEach(node => {\r\n\t        if (!node.nodes) {\r\n\t          if (node.type === 'open') node.isOpen = true;\r\n\t          if (node.type === 'close') node.isClose = true;\r\n\t          if (!node.nodes) node.type = 'text';\r\n\t          node.invalid = true;\r\n\t        }\r\n\t      });\r\n\r\n\t      // get the location of the block on parent.nodes (block's siblings)\r\n\t      const parent = stack[stack.length - 1];\r\n\t      const index = parent.nodes.indexOf(block);\r\n\t      // replace the (invalid) block with it's nodes\r\n\t      parent.nodes.splice(index, 1, ...block.nodes);\r\n\t    }\r\n\t  } while (stack.length > 0);\r\n\r\n\t  push({ type: 'eos' });\r\n\t  return ast;\r\n\t};\r\n\r\n\tparse_1 = parse;\r\n\treturn parse_1;\r\n}\r\n\r\nvar braces_1;\r\nvar hasRequiredBraces;\r\n\r\nfunction requireBraces () {\r\n\tif (hasRequiredBraces) return braces_1;\r\n\thasRequiredBraces = 1;\r\n\r\n\tconst stringify = /*@__PURE__*/ requireStringify();\r\n\tconst compile = /*@__PURE__*/ requireCompile();\r\n\tconst expand = /*@__PURE__*/ requireExpand();\r\n\tconst parse = /*@__PURE__*/ requireParse();\r\n\r\n\t/**\r\n\t * Expand the given pattern or create a regex-compatible string.\r\n\t *\r\n\t * ```js\r\n\t * const braces = require('braces');\r\n\t * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\r\n\t * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\r\n\t * ```\r\n\t * @param {String} `str`\r\n\t * @param {Object} `options`\r\n\t * @return {String}\r\n\t * @api public\r\n\t */\r\n\r\n\tconst braces = (input, options = {}) => {\r\n\t  let output = [];\r\n\r\n\t  if (Array.isArray(input)) {\r\n\t    for (const pattern of input) {\r\n\t      const result = braces.create(pattern, options);\r\n\t      if (Array.isArray(result)) {\r\n\t        output.push(...result);\r\n\t      } else {\r\n\t        output.push(result);\r\n\t      }\r\n\t    }\r\n\t  } else {\r\n\t    output = [].concat(braces.create(input, options));\r\n\t  }\r\n\r\n\t  if (options && options.expand === true && options.nodupes === true) {\r\n\t    output = [...new Set(output)];\r\n\t  }\r\n\t  return output;\r\n\t};\r\n\r\n\t/**\r\n\t * Parse the given `str` with the given `options`.\r\n\t *\r\n\t * ```js\r\n\t * // braces.parse(pattern, [, options]);\r\n\t * const ast = braces.parse('a/{b,c}/d');\r\n\t * console.log(ast);\r\n\t * ```\r\n\t * @param {String} pattern Brace pattern to parse\r\n\t * @param {Object} options\r\n\t * @return {Object} Returns an AST\r\n\t * @api public\r\n\t */\r\n\r\n\tbraces.parse = (input, options = {}) => parse(input, options);\r\n\r\n\t/**\r\n\t * Creates a braces string from an AST, or an AST node.\r\n\t *\r\n\t * ```js\r\n\t * const braces = require('braces');\r\n\t * let ast = braces.parse('foo/{a,b}/bar');\r\n\t * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\r\n\t * ```\r\n\t * @param {String} `input` Brace pattern or AST.\r\n\t * @param {Object} `options`\r\n\t * @return {Array} Returns an array of expanded values.\r\n\t * @api public\r\n\t */\r\n\r\n\tbraces.stringify = (input, options = {}) => {\r\n\t  if (typeof input === 'string') {\r\n\t    return stringify(braces.parse(input, options), options);\r\n\t  }\r\n\t  return stringify(input, options);\r\n\t};\r\n\r\n\t/**\r\n\t * Compiles a brace pattern into a regex-compatible, optimized string.\r\n\t * This method is called by the main [braces](#braces) function by default.\r\n\t *\r\n\t * ```js\r\n\t * const braces = require('braces');\r\n\t * console.log(braces.compile('a/{b,c}/d'));\r\n\t * //=> ['a/(b|c)/d']\r\n\t * ```\r\n\t * @param {String} `input` Brace pattern or AST.\r\n\t * @param {Object} `options`\r\n\t * @return {Array} Returns an array of expanded values.\r\n\t * @api public\r\n\t */\r\n\r\n\tbraces.compile = (input, options = {}) => {\r\n\t  if (typeof input === 'string') {\r\n\t    input = braces.parse(input, options);\r\n\t  }\r\n\t  return compile(input, options);\r\n\t};\r\n\r\n\t/**\r\n\t * Expands a brace pattern into an array. This method is called by the\r\n\t * main [braces](#braces) function when `options.expand` is true. Before\r\n\t * using this method it's recommended that you read the [performance notes](#performance))\r\n\t * and advantages of using [.compile](#compile) instead.\r\n\t *\r\n\t * ```js\r\n\t * const braces = require('braces');\r\n\t * console.log(braces.expand('a/{b,c}/d'));\r\n\t * //=> ['a/b/d', 'a/c/d'];\r\n\t * ```\r\n\t * @param {String} `pattern` Brace pattern\r\n\t * @param {Object} `options`\r\n\t * @return {Array} Returns an array of expanded values.\r\n\t * @api public\r\n\t */\r\n\r\n\tbraces.expand = (input, options = {}) => {\r\n\t  if (typeof input === 'string') {\r\n\t    input = braces.parse(input, options);\r\n\t  }\r\n\r\n\t  let result = expand(input, options);\r\n\r\n\t  // filter out empty strings if specified\r\n\t  if (options.noempty === true) {\r\n\t    result = result.filter(Boolean);\r\n\t  }\r\n\r\n\t  // filter out duplicates if specified\r\n\t  if (options.nodupes === true) {\r\n\t    result = [...new Set(result)];\r\n\t  }\r\n\r\n\t  return result;\r\n\t};\r\n\r\n\t/**\r\n\t * Processes a brace pattern and returns either an expanded array\r\n\t * (if `options.expand` is true), a highly optimized regex-compatible string.\r\n\t * This method is called by the main [braces](#braces) function.\r\n\t *\r\n\t * ```js\r\n\t * const braces = require('braces');\r\n\t * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\r\n\t * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\r\n\t * ```\r\n\t * @param {String} `pattern` Brace pattern\r\n\t * @param {Object} `options`\r\n\t * @return {Array} Returns an array of expanded values.\r\n\t * @api public\r\n\t */\r\n\r\n\tbraces.create = (input, options = {}) => {\r\n\t  if (input === '' || input.length < 3) {\r\n\t    return [input];\r\n\t  }\r\n\r\n\t  return options.expand !== true\r\n\t    ? braces.compile(input, options)\r\n\t    : braces.expand(input, options);\r\n\t};\r\n\r\n\t/**\r\n\t * Expose \"braces\"\r\n\t */\r\n\r\n\tbraces_1 = braces;\r\n\treturn braces_1;\r\n}\r\n\r\nconst require$$0 = [\r\n\t\"3dm\",\r\n\t\"3ds\",\r\n\t\"3g2\",\r\n\t\"3gp\",\r\n\t\"7z\",\r\n\t\"a\",\r\n\t\"aac\",\r\n\t\"adp\",\r\n\t\"afdesign\",\r\n\t\"afphoto\",\r\n\t\"afpub\",\r\n\t\"ai\",\r\n\t\"aif\",\r\n\t\"aiff\",\r\n\t\"alz\",\r\n\t\"ape\",\r\n\t\"apk\",\r\n\t\"appimage\",\r\n\t\"ar\",\r\n\t\"arj\",\r\n\t\"asf\",\r\n\t\"au\",\r\n\t\"avi\",\r\n\t\"bak\",\r\n\t\"baml\",\r\n\t\"bh\",\r\n\t\"bin\",\r\n\t\"bk\",\r\n\t\"bmp\",\r\n\t\"btif\",\r\n\t\"bz2\",\r\n\t\"bzip2\",\r\n\t\"cab\",\r\n\t\"caf\",\r\n\t\"cgm\",\r\n\t\"class\",\r\n\t\"cmx\",\r\n\t\"cpio\",\r\n\t\"cr2\",\r\n\t\"cur\",\r\n\t\"dat\",\r\n\t\"dcm\",\r\n\t\"deb\",\r\n\t\"dex\",\r\n\t\"djvu\",\r\n\t\"dll\",\r\n\t\"dmg\",\r\n\t\"dng\",\r\n\t\"doc\",\r\n\t\"docm\",\r\n\t\"docx\",\r\n\t\"dot\",\r\n\t\"dotm\",\r\n\t\"dra\",\r\n\t\"DS_Store\",\r\n\t\"dsk\",\r\n\t\"dts\",\r\n\t\"dtshd\",\r\n\t\"dvb\",\r\n\t\"dwg\",\r\n\t\"dxf\",\r\n\t\"ecelp4800\",\r\n\t\"ecelp7470\",\r\n\t\"ecelp9600\",\r\n\t\"egg\",\r\n\t\"eol\",\r\n\t\"eot\",\r\n\t\"epub\",\r\n\t\"exe\",\r\n\t\"f4v\",\r\n\t\"fbs\",\r\n\t\"fh\",\r\n\t\"fla\",\r\n\t\"flac\",\r\n\t\"flatpak\",\r\n\t\"fli\",\r\n\t\"flv\",\r\n\t\"fpx\",\r\n\t\"fst\",\r\n\t\"fvt\",\r\n\t\"g3\",\r\n\t\"gh\",\r\n\t\"gif\",\r\n\t\"graffle\",\r\n\t\"gz\",\r\n\t\"gzip\",\r\n\t\"h261\",\r\n\t\"h263\",\r\n\t\"h264\",\r\n\t\"icns\",\r\n\t\"ico\",\r\n\t\"ief\",\r\n\t\"img\",\r\n\t\"ipa\",\r\n\t\"iso\",\r\n\t\"jar\",\r\n\t\"jpeg\",\r\n\t\"jpg\",\r\n\t\"jpgv\",\r\n\t\"jpm\",\r\n\t\"jxr\",\r\n\t\"key\",\r\n\t\"ktx\",\r\n\t\"lha\",\r\n\t\"lib\",\r\n\t\"lvp\",\r\n\t\"lz\",\r\n\t\"lzh\",\r\n\t\"lzma\",\r\n\t\"lzo\",\r\n\t\"m3u\",\r\n\t\"m4a\",\r\n\t\"m4v\",\r\n\t\"mar\",\r\n\t\"mdi\",\r\n\t\"mht\",\r\n\t\"mid\",\r\n\t\"midi\",\r\n\t\"mj2\",\r\n\t\"mka\",\r\n\t\"mkv\",\r\n\t\"mmr\",\r\n\t\"mng\",\r\n\t\"mobi\",\r\n\t\"mov\",\r\n\t\"movie\",\r\n\t\"mp3\",\r\n\t\"mp4\",\r\n\t\"mp4a\",\r\n\t\"mpeg\",\r\n\t\"mpg\",\r\n\t\"mpga\",\r\n\t\"mxu\",\r\n\t\"nef\",\r\n\t\"npx\",\r\n\t\"numbers\",\r\n\t\"nupkg\",\r\n\t\"o\",\r\n\t\"odp\",\r\n\t\"ods\",\r\n\t\"odt\",\r\n\t\"oga\",\r\n\t\"ogg\",\r\n\t\"ogv\",\r\n\t\"otf\",\r\n\t\"ott\",\r\n\t\"pages\",\r\n\t\"pbm\",\r\n\t\"pcx\",\r\n\t\"pdb\",\r\n\t\"pdf\",\r\n\t\"pea\",\r\n\t\"pgm\",\r\n\t\"pic\",\r\n\t\"png\",\r\n\t\"pnm\",\r\n\t\"pot\",\r\n\t\"potm\",\r\n\t\"potx\",\r\n\t\"ppa\",\r\n\t\"ppam\",\r\n\t\"ppm\",\r\n\t\"pps\",\r\n\t\"ppsm\",\r\n\t\"ppsx\",\r\n\t\"ppt\",\r\n\t\"pptm\",\r\n\t\"pptx\",\r\n\t\"psd\",\r\n\t\"pya\",\r\n\t\"pyc\",\r\n\t\"pyo\",\r\n\t\"pyv\",\r\n\t\"qt\",\r\n\t\"rar\",\r\n\t\"ras\",\r\n\t\"raw\",\r\n\t\"resources\",\r\n\t\"rgb\",\r\n\t\"rip\",\r\n\t\"rlc\",\r\n\t\"rmf\",\r\n\t\"rmvb\",\r\n\t\"rpm\",\r\n\t\"rtf\",\r\n\t\"rz\",\r\n\t\"s3m\",\r\n\t\"s7z\",\r\n\t\"scpt\",\r\n\t\"sgi\",\r\n\t\"shar\",\r\n\t\"snap\",\r\n\t\"sil\",\r\n\t\"sketch\",\r\n\t\"slk\",\r\n\t\"smv\",\r\n\t\"snk\",\r\n\t\"so\",\r\n\t\"stl\",\r\n\t\"suo\",\r\n\t\"sub\",\r\n\t\"swf\",\r\n\t\"tar\",\r\n\t\"tbz\",\r\n\t\"tbz2\",\r\n\t\"tga\",\r\n\t\"tgz\",\r\n\t\"thmx\",\r\n\t\"tif\",\r\n\t\"tiff\",\r\n\t\"tlz\",\r\n\t\"ttc\",\r\n\t\"ttf\",\r\n\t\"txz\",\r\n\t\"udf\",\r\n\t\"uvh\",\r\n\t\"uvi\",\r\n\t\"uvm\",\r\n\t\"uvp\",\r\n\t\"uvs\",\r\n\t\"uvu\",\r\n\t\"viv\",\r\n\t\"vob\",\r\n\t\"war\",\r\n\t\"wav\",\r\n\t\"wax\",\r\n\t\"wbmp\",\r\n\t\"wdp\",\r\n\t\"weba\",\r\n\t\"webm\",\r\n\t\"webp\",\r\n\t\"whl\",\r\n\t\"wim\",\r\n\t\"wm\",\r\n\t\"wma\",\r\n\t\"wmv\",\r\n\t\"wmx\",\r\n\t\"woff\",\r\n\t\"woff2\",\r\n\t\"wrm\",\r\n\t\"wvx\",\r\n\t\"xbm\",\r\n\t\"xif\",\r\n\t\"xla\",\r\n\t\"xlam\",\r\n\t\"xls\",\r\n\t\"xlsb\",\r\n\t\"xlsm\",\r\n\t\"xlsx\",\r\n\t\"xlt\",\r\n\t\"xltm\",\r\n\t\"xltx\",\r\n\t\"xm\",\r\n\t\"xmind\",\r\n\t\"xpi\",\r\n\t\"xpm\",\r\n\t\"xwd\",\r\n\t\"xz\",\r\n\t\"z\",\r\n\t\"zip\",\r\n\t\"zipx\"\r\n];\r\n\r\nvar binaryExtensions;\r\nvar hasRequiredBinaryExtensions;\r\n\r\nfunction requireBinaryExtensions () {\r\n\tif (hasRequiredBinaryExtensions) return binaryExtensions;\r\n\thasRequiredBinaryExtensions = 1;\r\n\tbinaryExtensions = require$$0;\r\n\treturn binaryExtensions;\r\n}\r\n\r\nvar isBinaryPath;\r\nvar hasRequiredIsBinaryPath;\r\n\r\nfunction requireIsBinaryPath () {\r\n\tif (hasRequiredIsBinaryPath) return isBinaryPath;\r\n\thasRequiredIsBinaryPath = 1;\r\n\tconst path = require$$0$1;\r\n\tconst binaryExtensions = /*@__PURE__*/ requireBinaryExtensions();\r\n\r\n\tconst extensions = new Set(binaryExtensions);\r\n\r\n\tisBinaryPath = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\r\n\treturn isBinaryPath;\r\n}\r\n\r\nvar constants = {};\r\n\r\nvar hasRequiredConstants;\r\n\r\nfunction requireConstants () {\r\n\tif (hasRequiredConstants) return constants;\r\n\thasRequiredConstants = 1;\r\n\t(function (exports) {\r\n\r\n\t\tconst {sep} = require$$0$1;\r\n\t\tconst {platform} = process;\r\n\t\tconst os = require$$2$1;\r\n\r\n\t\texports.EV_ALL = 'all';\r\n\t\texports.EV_READY = 'ready';\r\n\t\texports.EV_ADD = 'add';\r\n\t\texports.EV_CHANGE = 'change';\r\n\t\texports.EV_ADD_DIR = 'addDir';\r\n\t\texports.EV_UNLINK = 'unlink';\r\n\t\texports.EV_UNLINK_DIR = 'unlinkDir';\r\n\t\texports.EV_RAW = 'raw';\r\n\t\texports.EV_ERROR = 'error';\r\n\r\n\t\texports.STR_DATA = 'data';\r\n\t\texports.STR_END = 'end';\r\n\t\texports.STR_CLOSE = 'close';\r\n\r\n\t\texports.FSEVENT_CREATED = 'created';\r\n\t\texports.FSEVENT_MODIFIED = 'modified';\r\n\t\texports.FSEVENT_DELETED = 'deleted';\r\n\t\texports.FSEVENT_MOVED = 'moved';\r\n\t\texports.FSEVENT_CLONED = 'cloned';\r\n\t\texports.FSEVENT_UNKNOWN = 'unknown';\r\n\t\texports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;\r\n\t\texports.FSEVENT_TYPE_FILE = 'file';\r\n\t\texports.FSEVENT_TYPE_DIRECTORY = 'directory';\r\n\t\texports.FSEVENT_TYPE_SYMLINK = 'symlink';\r\n\r\n\t\texports.KEY_LISTENERS = 'listeners';\r\n\t\texports.KEY_ERR = 'errHandlers';\r\n\t\texports.KEY_RAW = 'rawEmitters';\r\n\t\texports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\r\n\r\n\t\texports.DOT_SLASH = `.${sep}`;\r\n\r\n\t\texports.BACK_SLASH_RE = /\\\\/g;\r\n\t\texports.DOUBLE_SLASH_RE = /\\/\\//;\r\n\t\texports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\r\n\t\texports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\r\n\t\texports.REPLACER_RE = /^\\.[/\\\\]/;\r\n\r\n\t\texports.SLASH = '/';\r\n\t\texports.SLASH_SLASH = '//';\r\n\t\texports.BRACE_START = '{';\r\n\t\texports.BANG = '!';\r\n\t\texports.ONE_DOT = '.';\r\n\t\texports.TWO_DOTS = '..';\r\n\t\texports.STAR = '*';\r\n\t\texports.GLOBSTAR = '**';\r\n\t\texports.ROOT_GLOBSTAR = '/**/*';\r\n\t\texports.SLASH_GLOBSTAR = '/**';\r\n\t\texports.DIR_SUFFIX = 'Dir';\r\n\t\texports.ANYMATCH_OPTS = {dot: true};\r\n\t\texports.STRING_TYPE = 'string';\r\n\t\texports.FUNCTION_TYPE = 'function';\r\n\t\texports.EMPTY_STR = '';\r\n\t\texports.EMPTY_FN = () => {};\r\n\t\texports.IDENTITY_FN = val => val;\r\n\r\n\t\texports.isWindows = platform === 'win32';\r\n\t\texports.isMacos = platform === 'darwin';\r\n\t\texports.isLinux = platform === 'linux';\r\n\t\texports.isIBMi = os.type() === 'OS400'; \r\n\t} (constants));\r\n\treturn constants;\r\n}\r\n\r\nvar nodefsHandler;\r\nvar hasRequiredNodefsHandler;\r\n\r\nfunction requireNodefsHandler () {\r\n\tif (hasRequiredNodefsHandler) return nodefsHandler;\r\n\thasRequiredNodefsHandler = 1;\r\n\r\n\tconst fs = require$$0$2;\r\n\tconst sysPath = require$$0$1;\r\n\tconst { promisify } = require$$2;\r\n\tconst isBinaryPath = /*@__PURE__*/ requireIsBinaryPath();\r\n\tconst {\r\n\t  isWindows,\r\n\t  isLinux,\r\n\t  EMPTY_FN,\r\n\t  EMPTY_STR,\r\n\t  KEY_LISTENERS,\r\n\t  KEY_ERR,\r\n\t  KEY_RAW,\r\n\t  HANDLER_KEYS,\r\n\t  EV_CHANGE,\r\n\t  EV_ADD,\r\n\t  EV_ADD_DIR,\r\n\t  EV_ERROR,\r\n\t  STR_DATA,\r\n\t  STR_END,\r\n\t  BRACE_START,\r\n\t  STAR\r\n\t} = /*@__PURE__*/ requireConstants();\r\n\r\n\tconst THROTTLE_MODE_WATCH = 'watch';\r\n\r\n\tconst open = promisify(fs.open);\r\n\tconst stat = promisify(fs.stat);\r\n\tconst lstat = promisify(fs.lstat);\r\n\tconst close = promisify(fs.close);\r\n\tconst fsrealpath = promisify(fs.realpath);\r\n\r\n\tconst statMethods = { lstat, stat };\r\n\r\n\t// TODO: emit errors properly. Example: EMFILE on Macos.\r\n\tconst foreach = (val, fn) => {\r\n\t  if (val instanceof Set) {\r\n\t    val.forEach(fn);\r\n\t  } else {\r\n\t    fn(val);\r\n\t  }\r\n\t};\r\n\r\n\tconst addAndConvert = (main, prop, item) => {\r\n\t  let container = main[prop];\r\n\t  if (!(container instanceof Set)) {\r\n\t    main[prop] = container = new Set([container]);\r\n\t  }\r\n\t  container.add(item);\r\n\t};\r\n\r\n\tconst clearItem = cont => key => {\r\n\t  const set = cont[key];\r\n\t  if (set instanceof Set) {\r\n\t    set.clear();\r\n\t  } else {\r\n\t    delete cont[key];\r\n\t  }\r\n\t};\r\n\r\n\tconst delFromSet = (main, prop, item) => {\r\n\t  const container = main[prop];\r\n\t  if (container instanceof Set) {\r\n\t    container.delete(item);\r\n\t  } else if (container === item) {\r\n\t    delete main[prop];\r\n\t  }\r\n\t};\r\n\r\n\tconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\r\n\r\n\t/**\r\n\t * @typedef {String} Path\r\n\t */\r\n\r\n\t// fs_watch helpers\r\n\r\n\t// object to hold per-process fs_watch instances\r\n\t// (may be shared across chokidar FSWatcher instances)\r\n\r\n\t/**\r\n\t * @typedef {Object} FsWatchContainer\r\n\t * @property {Set} listeners\r\n\t * @property {Set} errHandlers\r\n\t * @property {Set} rawEmitters\r\n\t * @property {fs.FSWatcher=} watcher\r\n\t * @property {Boolean=} watcherUnusable\r\n\t */\r\n\r\n\t/**\r\n\t * @type {Map<String,FsWatchContainer>}\r\n\t */\r\n\tconst FsWatchInstances = new Map();\r\n\r\n\t/**\r\n\t * Instantiates the fs_watch interface\r\n\t * @param {String} path to be watched\r\n\t * @param {Object} options to be passed to fs_watch\r\n\t * @param {Function} listener main event handler\r\n\t * @param {Function} errHandler emits info about errors\r\n\t * @param {Function} emitRaw emits raw event data\r\n\t * @returns {fs.FSWatcher} new fsevents instance\r\n\t */\r\n\tfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\r\n\t  const handleEvent = (rawEvent, evPath) => {\r\n\t    listener(path);\r\n\t    emitRaw(rawEvent, evPath, {watchedPath: path});\r\n\r\n\t    // emit based on events occurring for files from a directory's watcher in\r\n\t    // case the file's watcher misses it (and rely on throttling to de-dupe)\r\n\t    if (evPath && path !== evPath) {\r\n\t      fsWatchBroadcast(\r\n\t        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\r\n\t      );\r\n\t    }\r\n\t  };\r\n\t  try {\r\n\t    return fs.watch(path, options, handleEvent);\r\n\t  } catch (error) {\r\n\t    errHandler(error);\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Helper for passing fs_watch event data to a collection of listeners\r\n\t * @param {Path} fullPath absolute path bound to fs_watch instance\r\n\t * @param {String} type listener type\r\n\t * @param {*=} val1 arguments to be passed to listeners\r\n\t * @param {*=} val2\r\n\t * @param {*=} val3\r\n\t */\r\n\tconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\r\n\t  const cont = FsWatchInstances.get(fullPath);\r\n\t  if (!cont) return;\r\n\t  foreach(cont[type], (listener) => {\r\n\t    listener(val1, val2, val3);\r\n\t  });\r\n\t};\r\n\r\n\t/**\r\n\t * Instantiates the fs_watch interface or binds listeners\r\n\t * to an existing one covering the same file system entry\r\n\t * @param {String} path\r\n\t * @param {String} fullPath absolute path\r\n\t * @param {Object} options to be passed to fs_watch\r\n\t * @param {Object} handlers container for event listener functions\r\n\t */\r\n\tconst setFsWatchListener = (path, fullPath, options, handlers) => {\r\n\t  const {listener, errHandler, rawEmitter} = handlers;\r\n\t  let cont = FsWatchInstances.get(fullPath);\r\n\r\n\t  /** @type {fs.FSWatcher=} */\r\n\t  let watcher;\r\n\t  if (!options.persistent) {\r\n\t    watcher = createFsWatchInstance(\r\n\t      path, options, listener, errHandler, rawEmitter\r\n\t    );\r\n\t    return watcher.close.bind(watcher);\r\n\t  }\r\n\t  if (cont) {\r\n\t    addAndConvert(cont, KEY_LISTENERS, listener);\r\n\t    addAndConvert(cont, KEY_ERR, errHandler);\r\n\t    addAndConvert(cont, KEY_RAW, rawEmitter);\r\n\t  } else {\r\n\t    watcher = createFsWatchInstance(\r\n\t      path,\r\n\t      options,\r\n\t      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\r\n\t      errHandler, // no need to use broadcast here\r\n\t      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\r\n\t    );\r\n\t    if (!watcher) return;\r\n\t    watcher.on(EV_ERROR, async (error) => {\r\n\t      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\r\n\t      cont.watcherUnusable = true; // documented since Node 10.4.1\r\n\t      // Workaround for https://github.com/joyent/node/issues/4337\r\n\t      if (isWindows && error.code === 'EPERM') {\r\n\t        try {\r\n\t          const fd = await open(path, 'r');\r\n\t          await close(fd);\r\n\t          broadcastErr(error);\r\n\t        } catch (err) {}\r\n\t      } else {\r\n\t        broadcastErr(error);\r\n\t      }\r\n\t    });\r\n\t    cont = {\r\n\t      listeners: listener,\r\n\t      errHandlers: errHandler,\r\n\t      rawEmitters: rawEmitter,\r\n\t      watcher\r\n\t    };\r\n\t    FsWatchInstances.set(fullPath, cont);\r\n\t  }\r\n\t  // const index = cont.listeners.indexOf(listener);\r\n\r\n\t  // removes this instance's listeners and closes the underlying fs_watch\r\n\t  // instance if there are no more listeners left\r\n\t  return () => {\r\n\t    delFromSet(cont, KEY_LISTENERS, listener);\r\n\t    delFromSet(cont, KEY_ERR, errHandler);\r\n\t    delFromSet(cont, KEY_RAW, rawEmitter);\r\n\t    if (isEmptySet(cont.listeners)) {\r\n\t      // Check to protect against issue gh-730.\r\n\t      // if (cont.watcherUnusable) {\r\n\t      cont.watcher.close();\r\n\t      // }\r\n\t      FsWatchInstances.delete(fullPath);\r\n\t      HANDLER_KEYS.forEach(clearItem(cont));\r\n\t      cont.watcher = undefined;\r\n\t      Object.freeze(cont);\r\n\t    }\r\n\t  };\r\n\t};\r\n\r\n\t// fs_watchFile helpers\r\n\r\n\t// object to hold per-process fs_watchFile instances\r\n\t// (may be shared across chokidar FSWatcher instances)\r\n\tconst FsWatchFileInstances = new Map();\r\n\r\n\t/**\r\n\t * Instantiates the fs_watchFile interface or binds listeners\r\n\t * to an existing one covering the same file system entry\r\n\t * @param {String} path to be watched\r\n\t * @param {String} fullPath absolute path\r\n\t * @param {Object} options options to be passed to fs_watchFile\r\n\t * @param {Object} handlers container for event listener functions\r\n\t * @returns {Function} closer\r\n\t */\r\n\tconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\r\n\t  const {listener, rawEmitter} = handlers;\r\n\t  let cont = FsWatchFileInstances.get(fullPath);\r\n\r\n\t  const copts = cont && cont.options;\r\n\t  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\r\n\t    fs.unwatchFile(fullPath);\r\n\t    cont = undefined;\r\n\t  }\r\n\r\n\t  /* eslint-enable no-unused-vars, prefer-destructuring */\r\n\r\n\t  if (cont) {\r\n\t    addAndConvert(cont, KEY_LISTENERS, listener);\r\n\t    addAndConvert(cont, KEY_RAW, rawEmitter);\r\n\t  } else {\r\n\t    // TODO\r\n\t    // listeners.add(listener);\r\n\t    // rawEmitters.add(rawEmitter);\r\n\t    cont = {\r\n\t      listeners: listener,\r\n\t      rawEmitters: rawEmitter,\r\n\t      options,\r\n\t      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\r\n\t        foreach(cont.rawEmitters, (rawEmitter) => {\r\n\t          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\r\n\t        });\r\n\t        const currmtime = curr.mtimeMs;\r\n\t        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\r\n\t          foreach(cont.listeners, (listener) => listener(path, curr));\r\n\t        }\r\n\t      })\r\n\t    };\r\n\t    FsWatchFileInstances.set(fullPath, cont);\r\n\t  }\r\n\t  // const index = cont.listeners.indexOf(listener);\r\n\r\n\t  // Removes this instance's listeners and closes the underlying fs_watchFile\r\n\t  // instance if there are no more listeners left.\r\n\t  return () => {\r\n\t    delFromSet(cont, KEY_LISTENERS, listener);\r\n\t    delFromSet(cont, KEY_RAW, rawEmitter);\r\n\t    if (isEmptySet(cont.listeners)) {\r\n\t      FsWatchFileInstances.delete(fullPath);\r\n\t      fs.unwatchFile(fullPath);\r\n\t      cont.options = cont.watcher = undefined;\r\n\t      Object.freeze(cont);\r\n\t    }\r\n\t  };\r\n\t};\r\n\r\n\t/**\r\n\t * @mixin\r\n\t */\r\n\tclass NodeFsHandler {\r\n\r\n\t/**\r\n\t * @param {import(\"../index\").FSWatcher} fsW\r\n\t */\r\n\tconstructor(fsW) {\r\n\t  this.fsw = fsW;\r\n\t  this._boundHandleError = (error) => fsW._handleError(error);\r\n\t}\r\n\r\n\t/**\r\n\t * Watch file for changes with fs_watchFile or fs_watch.\r\n\t * @param {String} path to file or dir\r\n\t * @param {Function} listener on fs change\r\n\t * @returns {Function} closer for the watcher instance\r\n\t */\r\n\t_watchWithNodeFs(path, listener) {\r\n\t  const opts = this.fsw.options;\r\n\t  const directory = sysPath.dirname(path);\r\n\t  const basename = sysPath.basename(path);\r\n\t  const parent = this.fsw._getWatchedDir(directory);\r\n\t  parent.add(basename);\r\n\t  const absolutePath = sysPath.resolve(path);\r\n\t  const options = {persistent: opts.persistent};\r\n\t  if (!listener) listener = EMPTY_FN;\r\n\r\n\t  let closer;\r\n\t  if (opts.usePolling) {\r\n\t    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\r\n\t      opts.binaryInterval : opts.interval;\r\n\t    closer = setFsWatchFileListener(path, absolutePath, options, {\r\n\t      listener,\r\n\t      rawEmitter: this.fsw._emitRaw\r\n\t    });\r\n\t  } else {\r\n\t    closer = setFsWatchListener(path, absolutePath, options, {\r\n\t      listener,\r\n\t      errHandler: this._boundHandleError,\r\n\t      rawEmitter: this.fsw._emitRaw\r\n\t    });\r\n\t  }\r\n\t  return closer;\r\n\t}\r\n\r\n\t/**\r\n\t * Watch a file and emit add event if warranted.\r\n\t * @param {Path} file Path\r\n\t * @param {fs.Stats} stats result of fs_stat\r\n\t * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n\t * @returns {Function} closer for the watcher instance\r\n\t */\r\n\t_handleFile(file, stats, initialAdd) {\r\n\t  if (this.fsw.closed) {\r\n\t    return;\r\n\t  }\r\n\t  const dirname = sysPath.dirname(file);\r\n\t  const basename = sysPath.basename(file);\r\n\t  const parent = this.fsw._getWatchedDir(dirname);\r\n\t  // stats is always present\r\n\t  let prevStats = stats;\r\n\r\n\t  // if the file is already being watched, do nothing\r\n\t  if (parent.has(basename)) return;\r\n\r\n\t  const listener = async (path, newStats) => {\r\n\t    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\r\n\t    if (!newStats || newStats.mtimeMs === 0) {\r\n\t      try {\r\n\t        const newStats = await stat(file);\r\n\t        if (this.fsw.closed) return;\r\n\t        // Check that change event was not fired because of changed only accessTime.\r\n\t        const at = newStats.atimeMs;\r\n\t        const mt = newStats.mtimeMs;\r\n\t        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\r\n\t          this.fsw._emit(EV_CHANGE, file, newStats);\r\n\t        }\r\n\t        if (isLinux && prevStats.ino !== newStats.ino) {\r\n\t          this.fsw._closeFile(path);\r\n\t          prevStats = newStats;\r\n\t          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\r\n\t        } else {\r\n\t          prevStats = newStats;\r\n\t        }\r\n\t      } catch (error) {\r\n\t        // Fix issues where mtime is null but file is still present\r\n\t        this.fsw._remove(dirname, basename);\r\n\t      }\r\n\t      // add is about to be emitted if file not already tracked in parent\r\n\t    } else if (parent.has(basename)) {\r\n\t      // Check that change event was not fired because of changed only accessTime.\r\n\t      const at = newStats.atimeMs;\r\n\t      const mt = newStats.mtimeMs;\r\n\t      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\r\n\t        this.fsw._emit(EV_CHANGE, file, newStats);\r\n\t      }\r\n\t      prevStats = newStats;\r\n\t    }\r\n\t  };\r\n\t  // kick off the watcher\r\n\t  const closer = this._watchWithNodeFs(file, listener);\r\n\r\n\t  // emit an add event if we're supposed to\r\n\t  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\r\n\t    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\r\n\t    this.fsw._emit(EV_ADD, file, stats);\r\n\t  }\r\n\r\n\t  return closer;\r\n\t}\r\n\r\n\t/**\r\n\t * Handle symlinks encountered while reading a dir.\r\n\t * @param {Object} entry returned by readdirp\r\n\t * @param {String} directory path of dir being read\r\n\t * @param {String} path of this item\r\n\t * @param {String} item basename of this item\r\n\t * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\r\n\t */\r\n\tasync _handleSymlink(entry, directory, path, item) {\r\n\t  if (this.fsw.closed) {\r\n\t    return;\r\n\t  }\r\n\t  const full = entry.fullPath;\r\n\t  const dir = this.fsw._getWatchedDir(directory);\r\n\r\n\t  if (!this.fsw.options.followSymlinks) {\r\n\t    // watch symlink directly (don't follow) and detect changes\r\n\t    this.fsw._incrReadyCount();\r\n\r\n\t    let linkPath;\r\n\t    try {\r\n\t      linkPath = await fsrealpath(path);\r\n\t    } catch (e) {\r\n\t      this.fsw._emitReady();\r\n\t      return true;\r\n\t    }\r\n\r\n\t    if (this.fsw.closed) return;\r\n\t    if (dir.has(item)) {\r\n\t      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\r\n\t        this.fsw._symlinkPaths.set(full, linkPath);\r\n\t        this.fsw._emit(EV_CHANGE, path, entry.stats);\r\n\t      }\r\n\t    } else {\r\n\t      dir.add(item);\r\n\t      this.fsw._symlinkPaths.set(full, linkPath);\r\n\t      this.fsw._emit(EV_ADD, path, entry.stats);\r\n\t    }\r\n\t    this.fsw._emitReady();\r\n\t    return true;\r\n\t  }\r\n\r\n\t  // don't follow the same symlink more than once\r\n\t  if (this.fsw._symlinkPaths.has(full)) {\r\n\t    return true;\r\n\t  }\r\n\r\n\t  this.fsw._symlinkPaths.set(full, true);\r\n\t}\r\n\r\n\t_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\r\n\t  // Normalize the directory name on Windows\r\n\t  directory = sysPath.join(directory, EMPTY_STR);\r\n\r\n\t  if (!wh.hasGlob) {\r\n\t    throttler = this.fsw._throttle('readdir', directory, 1000);\r\n\t    if (!throttler) return;\r\n\t  }\r\n\r\n\t  const previous = this.fsw._getWatchedDir(wh.path);\r\n\t  const current = new Set();\r\n\r\n\t  let stream = this.fsw._readdirp(directory, {\r\n\t    fileFilter: entry => wh.filterPath(entry),\r\n\t    directoryFilter: entry => wh.filterDir(entry),\r\n\t    depth: 0\r\n\t  }).on(STR_DATA, async (entry) => {\r\n\t    if (this.fsw.closed) {\r\n\t      stream = undefined;\r\n\t      return;\r\n\t    }\r\n\t    const item = entry.path;\r\n\t    let path = sysPath.join(directory, item);\r\n\t    current.add(item);\r\n\r\n\t    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\r\n\t      return;\r\n\t    }\r\n\r\n\t    if (this.fsw.closed) {\r\n\t      stream = undefined;\r\n\t      return;\r\n\t    }\r\n\t    // Files that present in current directory snapshot\r\n\t    // but absent in previous are added to watch list and\r\n\t    // emit `add` event.\r\n\t    if (item === target || !target && !previous.has(item)) {\r\n\t      this.fsw._incrReadyCount();\r\n\r\n\t      // ensure relativeness of path is preserved in case of watcher reuse\r\n\t      path = sysPath.join(dir, sysPath.relative(dir, path));\r\n\r\n\t      this._addToNodeFs(path, initialAdd, wh, depth + 1);\r\n\t    }\r\n\t  }).on(EV_ERROR, this._boundHandleError);\r\n\r\n\t  return new Promise(resolve =>\r\n\t    stream.once(STR_END, () => {\r\n\t      if (this.fsw.closed) {\r\n\t        stream = undefined;\r\n\t        return;\r\n\t      }\r\n\t      const wasThrottled = throttler ? throttler.clear() : false;\r\n\r\n\t      resolve();\r\n\r\n\t      // Files that absent in current directory snapshot\r\n\t      // but present in previous emit `remove` event\r\n\t      // and are removed from @watched[directory].\r\n\t      previous.getChildren().filter((item) => {\r\n\t        return item !== directory &&\r\n\t          !current.has(item) &&\r\n\t          // in case of intersecting globs;\r\n\t          // a path may have been filtered out of this readdir, but\r\n\t          // shouldn't be removed because it matches a different glob\r\n\t          (!wh.hasGlob || wh.filterPath({\r\n\t            fullPath: sysPath.resolve(directory, item)\r\n\t          }));\r\n\t      }).forEach((item) => {\r\n\t        this.fsw._remove(directory, item);\r\n\t      });\r\n\r\n\t      stream = undefined;\r\n\r\n\t      // one more time for any missed in case changes came in extremely quickly\r\n\t      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\r\n\t    })\r\n\t  );\r\n\t}\r\n\r\n\t/**\r\n\t * Read directory to add / remove files from `@watched` list and re-read it on change.\r\n\t * @param {String} dir fs path\r\n\t * @param {fs.Stats} stats\r\n\t * @param {Boolean} initialAdd\r\n\t * @param {Number} depth relative to user-supplied path\r\n\t * @param {String} target child path targeted for watch\r\n\t * @param {Object} wh Common watch helpers for this path\r\n\t * @param {String} realpath\r\n\t * @returns {Promise<Function>} closer for the watcher instance.\r\n\t */\r\n\tasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\r\n\t  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\r\n\t  const tracked = parentDir.has(sysPath.basename(dir));\r\n\t  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\r\n\t    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\r\n\t  }\r\n\r\n\t  // ensure dir is tracked (harmless if redundant)\r\n\t  parentDir.add(sysPath.basename(dir));\r\n\t  this.fsw._getWatchedDir(dir);\r\n\t  let throttler;\r\n\t  let closer;\r\n\r\n\t  const oDepth = this.fsw.options.depth;\r\n\t  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\r\n\t    if (!target) {\r\n\t      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\r\n\t      if (this.fsw.closed) return;\r\n\t    }\r\n\r\n\t    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\r\n\t      // if current directory is removed, do nothing\r\n\t      if (stats && stats.mtimeMs === 0) return;\r\n\r\n\t      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\r\n\t    });\r\n\t  }\r\n\t  return closer;\r\n\t}\r\n\r\n\t/**\r\n\t * Handle added file, directory, or glob pattern.\r\n\t * Delegates call to _handleFile / _handleDir after checks.\r\n\t * @param {String} path to file or ir\r\n\t * @param {Boolean} initialAdd was the file added at watch instantiation?\r\n\t * @param {Object} priorWh depth relative to user-supplied path\r\n\t * @param {Number} depth Child path actually targeted for watch\r\n\t * @param {String=} target Child path actually targeted for watch\r\n\t * @returns {Promise}\r\n\t */\r\n\tasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\r\n\t  const ready = this.fsw._emitReady;\r\n\t  if (this.fsw._isIgnored(path) || this.fsw.closed) {\r\n\t    ready();\r\n\t    return false;\r\n\t  }\r\n\r\n\t  const wh = this.fsw._getWatchHelpers(path, depth);\r\n\t  if (!wh.hasGlob && priorWh) {\r\n\t    wh.hasGlob = priorWh.hasGlob;\r\n\t    wh.globFilter = priorWh.globFilter;\r\n\t    wh.filterPath = entry => priorWh.filterPath(entry);\r\n\t    wh.filterDir = entry => priorWh.filterDir(entry);\r\n\t  }\r\n\r\n\t  // evaluate what is at the path we're being asked to watch\r\n\t  try {\r\n\t    const stats = await statMethods[wh.statMethod](wh.watchPath);\r\n\t    if (this.fsw.closed) return;\r\n\t    if (this.fsw._isIgnored(wh.watchPath, stats)) {\r\n\t      ready();\r\n\t      return false;\r\n\t    }\r\n\r\n\t    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\r\n\t    let closer;\r\n\t    if (stats.isDirectory()) {\r\n\t      const absPath = sysPath.resolve(path);\r\n\t      const targetPath = follow ? await fsrealpath(path) : path;\r\n\t      if (this.fsw.closed) return;\r\n\t      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\r\n\t      if (this.fsw.closed) return;\r\n\t      // preserve this symlink's target path\r\n\t      if (absPath !== targetPath && targetPath !== undefined) {\r\n\t        this.fsw._symlinkPaths.set(absPath, targetPath);\r\n\t      }\r\n\t    } else if (stats.isSymbolicLink()) {\r\n\t      const targetPath = follow ? await fsrealpath(path) : path;\r\n\t      if (this.fsw.closed) return;\r\n\t      const parent = sysPath.dirname(wh.watchPath);\r\n\t      this.fsw._getWatchedDir(parent).add(wh.watchPath);\r\n\t      this.fsw._emit(EV_ADD, wh.watchPath, stats);\r\n\t      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\r\n\t      if (this.fsw.closed) return;\r\n\r\n\t      // preserve this symlink's target path\r\n\t      if (targetPath !== undefined) {\r\n\t        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\r\n\t      }\r\n\t    } else {\r\n\t      closer = this._handleFile(wh.watchPath, stats, initialAdd);\r\n\t    }\r\n\t    ready();\r\n\r\n\t    this.fsw._addPathCloser(path, closer);\r\n\t    return false;\r\n\r\n\t  } catch (error) {\r\n\t    if (this.fsw._handleError(error)) {\r\n\t      ready();\r\n\t      return path;\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\t}\r\n\r\n\tnodefsHandler = NodeFsHandler;\r\n\treturn nodefsHandler;\r\n}\r\n\r\nvar fseventsHandler = {exports: {}};\r\n\r\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\r\n\r\nvar hasRequiredFseventsHandler;\r\n\r\nfunction requireFseventsHandler () {\r\n\tif (hasRequiredFseventsHandler) return fseventsHandler.exports;\r\n\thasRequiredFseventsHandler = 1;\r\n\r\n\tconst fs = require$$0$2;\r\n\tconst sysPath = require$$0$1;\r\n\tconst { promisify } = require$$2;\r\n\r\n\tlet fsevents;\r\n\ttry {\r\n\t  fsevents = require$$3.getFsEvents();\r\n\t} catch (error) {\r\n\t  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\r\n\t}\r\n\r\n\tif (fsevents) {\r\n\t  // TODO: real check\r\n\t  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\r\n\t  if (mtch && mtch[1] && mtch[2]) {\r\n\t    const maj = Number.parseInt(mtch[1], 10);\r\n\t    const min = Number.parseInt(mtch[2], 10);\r\n\t    if (maj === 8 && min < 16) {\r\n\t      fsevents = undefined;\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\tconst {\r\n\t  EV_ADD,\r\n\t  EV_CHANGE,\r\n\t  EV_ADD_DIR,\r\n\t  EV_UNLINK,\r\n\t  EV_ERROR,\r\n\t  STR_DATA,\r\n\t  STR_END,\r\n\t  FSEVENT_CREATED,\r\n\t  FSEVENT_MODIFIED,\r\n\t  FSEVENT_DELETED,\r\n\t  FSEVENT_MOVED,\r\n\t  // FSEVENT_CLONED,\r\n\t  FSEVENT_UNKNOWN,\r\n\t  FSEVENT_FLAG_MUST_SCAN_SUBDIRS,\r\n\t  FSEVENT_TYPE_FILE,\r\n\t  FSEVENT_TYPE_DIRECTORY,\r\n\t  FSEVENT_TYPE_SYMLINK,\r\n\r\n\t  ROOT_GLOBSTAR,\r\n\t  DIR_SUFFIX,\r\n\t  DOT_SLASH,\r\n\t  FUNCTION_TYPE,\r\n\t  EMPTY_FN,\r\n\t  IDENTITY_FN\r\n\t} = /*@__PURE__*/ requireConstants();\r\n\r\n\tconst Depth = (value) => isNaN(value) ? {} : {depth: value};\r\n\r\n\tconst stat = promisify(fs.stat);\r\n\tconst lstat = promisify(fs.lstat);\r\n\tconst realpath = promisify(fs.realpath);\r\n\r\n\tconst statMethods = { stat, lstat };\r\n\r\n\t/**\r\n\t * @typedef {String} Path\r\n\t */\r\n\r\n\t/**\r\n\t * @typedef {Object} FsEventsWatchContainer\r\n\t * @property {Set<Function>} listeners\r\n\t * @property {Function} rawEmitter\r\n\t * @property {{stop: Function}} watcher\r\n\t */\r\n\r\n\t// fsevents instance helper functions\r\n\t/**\r\n\t * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\r\n\t * @type {Map<Path,FsEventsWatchContainer>}\r\n\t */\r\n\tconst FSEventsWatchers = new Map();\r\n\r\n\t// Threshold of duplicate path prefixes at which to start\r\n\t// consolidating going forward\r\n\tconst consolidateThreshhold = 10;\r\n\r\n\tconst wrongEventFlags = new Set([\r\n\t  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\r\n\t]);\r\n\r\n\t/**\r\n\t * Instantiates the fsevents interface\r\n\t * @param {Path} path path to be watched\r\n\t * @param {Function} callback called when fsevents is bound and ready\r\n\t * @returns {{stop: Function}} new fsevents instance\r\n\t */\r\n\tconst createFSEventsInstance = (path, callback) => {\r\n\t  const stop = fsevents.watch(path, callback);\r\n\t  return {stop};\r\n\t};\r\n\r\n\t/**\r\n\t * Instantiates the fsevents interface or binds listeners to an existing one covering\r\n\t * the same file tree.\r\n\t * @param {Path} path           - to be watched\r\n\t * @param {Path} realPath       - real path for symlinks\r\n\t * @param {Function} listener   - called when fsevents emits events\r\n\t * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\r\n\t * @returns {Function} closer\r\n\t */\r\n\tfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\r\n\t  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\r\n\r\n\t  const parentPath = sysPath.dirname(watchPath);\r\n\t  let cont = FSEventsWatchers.get(watchPath);\r\n\r\n\t  // If we've accumulated a substantial number of paths that\r\n\t  // could have been consolidated by watching one directory\r\n\t  // above the current one, create a watcher on the parent\r\n\t  // path instead, so that we do consolidate going forward.\r\n\t  if (couldConsolidate(parentPath)) {\r\n\t    watchPath = parentPath;\r\n\t  }\r\n\r\n\t  const resolvedPath = sysPath.resolve(path);\r\n\t  const hasSymlink = resolvedPath !== realPath;\r\n\r\n\t  const filteredListener = (fullPath, flags, info) => {\r\n\t    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\r\n\t    if (\r\n\t      fullPath === resolvedPath ||\r\n\t      !fullPath.indexOf(resolvedPath + sysPath.sep)\r\n\t    ) listener(fullPath, flags, info);\r\n\t  };\r\n\r\n\t  // check if there is already a watcher on a parent path\r\n\t  // modifies `watchPath` to the parent path when it finds a match\r\n\t  let watchedParent = false;\r\n\t  for (const watchedPath of FSEventsWatchers.keys()) {\r\n\t    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\r\n\t      watchPath = watchedPath;\r\n\t      cont = FSEventsWatchers.get(watchPath);\r\n\t      watchedParent = true;\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\r\n\t  if (cont || watchedParent) {\r\n\t    cont.listeners.add(filteredListener);\r\n\t  } else {\r\n\t    cont = {\r\n\t      listeners: new Set([filteredListener]),\r\n\t      rawEmitter,\r\n\t      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\r\n\t        if (!cont.listeners.size) return;\r\n\t        if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;\r\n\t        const info = fsevents.getInfo(fullPath, flags);\r\n\t        cont.listeners.forEach(list => {\r\n\t          list(fullPath, flags, info);\r\n\t        });\r\n\r\n\t        cont.rawEmitter(info.event, fullPath, info);\r\n\t      })\r\n\t    };\r\n\t    FSEventsWatchers.set(watchPath, cont);\r\n\t  }\r\n\r\n\t  // removes this instance's listeners and closes the underlying fsevents\r\n\t  // instance if there are no more listeners left\r\n\t  return () => {\r\n\t    const lst = cont.listeners;\r\n\r\n\t    lst.delete(filteredListener);\r\n\t    if (!lst.size) {\r\n\t      FSEventsWatchers.delete(watchPath);\r\n\t      if (cont.watcher) return cont.watcher.stop().then(() => {\r\n\t        cont.rawEmitter = cont.watcher = undefined;\r\n\t        Object.freeze(cont);\r\n\t      });\r\n\t    }\r\n\t  };\r\n\t}\r\n\r\n\t// Decide whether or not we should start a new higher-level\r\n\t// parent watcher\r\n\tconst couldConsolidate = (path) => {\r\n\t  let count = 0;\r\n\t  for (const watchPath of FSEventsWatchers.keys()) {\r\n\t    if (watchPath.indexOf(path) === 0) {\r\n\t      count++;\r\n\t      if (count >= consolidateThreshhold) {\r\n\t        return true;\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  return false;\r\n\t};\r\n\r\n\t// returns boolean indicating whether fsevents can be used\r\n\tconst canUse = () => fsevents && FSEventsWatchers.size < 128;\r\n\r\n\t// determines subdirectory traversal levels from root to path\r\n\tconst calcDepth = (path, root) => {\r\n\t  let i = 0;\r\n\t  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\r\n\t  return i;\r\n\t};\r\n\r\n\t// returns boolean indicating whether the fsevents' event info has the same type\r\n\t// as the one returned by fs.stat\r\n\tconst sameTypes = (info, stats) => (\r\n\t  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\r\n\t  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\r\n\t  info.type === FSEVENT_TYPE_FILE && stats.isFile()\r\n\t);\r\n\r\n\t/**\r\n\t * @mixin\r\n\t */\r\n\tclass FsEventsHandler {\r\n\r\n\t/**\r\n\t * @param {import('../index').FSWatcher} fsw\r\n\t */\r\n\tconstructor(fsw) {\r\n\t  this.fsw = fsw;\r\n\t}\r\n\tcheckIgnored(path, stats) {\r\n\t  const ipaths = this.fsw._ignoredPaths;\r\n\t  if (this.fsw._isIgnored(path, stats)) {\r\n\t    ipaths.add(path);\r\n\t    if (stats && stats.isDirectory()) {\r\n\t      ipaths.add(path + ROOT_GLOBSTAR);\r\n\t    }\r\n\t    return true;\r\n\t  }\r\n\r\n\t  ipaths.delete(path);\r\n\t  ipaths.delete(path + ROOT_GLOBSTAR);\r\n\t}\r\n\r\n\taddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n\t  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\r\n\t  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t}\r\n\r\n\tasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n\t  try {\r\n\t    const stats = await stat(path);\r\n\t    if (this.fsw.closed) return;\r\n\t    if (sameTypes(info, stats)) {\r\n\t      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t    } else {\r\n\t      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t    }\r\n\t  } catch (error) {\r\n\t    if (error.code === 'EACCES') {\r\n\t      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t    } else {\r\n\t      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\thandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\r\n\t  if (this.fsw.closed || this.checkIgnored(path)) return;\r\n\r\n\t  if (event === EV_UNLINK) {\r\n\t    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\r\n\t    // suppress unlink events on never before seen files\r\n\t    if (isDirectory || watchedDir.has(item)) {\r\n\t      this.fsw._remove(parent, item, isDirectory);\r\n\t    }\r\n\t  } else {\r\n\t    if (event === EV_ADD) {\r\n\t      // track new directories\r\n\t      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\r\n\r\n\t      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\r\n\t        // push symlinks back to the top of the stack to get handled\r\n\t        const curDepth = opts.depth === undefined ?\r\n\t          undefined : calcDepth(fullPath, realPath) + 1;\r\n\t        return this._addToFsEvents(path, false, true, curDepth);\r\n\t      }\r\n\r\n\t      // track new paths\r\n\t      // (other than symlinks being followed, which will be tracked soon)\r\n\t      this.fsw._getWatchedDir(parent).add(item);\r\n\t    }\r\n\t    /**\r\n\t     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\r\n\t     */\r\n\t    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\r\n\t    this.fsw._emit(eventName, path);\r\n\t    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Handle symlinks encountered during directory scan\r\n\t * @param {String} watchPath  - file/dir path to be watched with fsevents\r\n\t * @param {String} realPath   - real path (in case of symlinks)\r\n\t * @param {Function} transform  - path transformer\r\n\t * @param {Function} globFilter - path filter in case a glob pattern was provided\r\n\t * @returns {Function} closer for the watcher instance\r\n\t*/\r\n\t_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\r\n\t  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\r\n\t  const opts = this.fsw.options;\r\n\t  const watchCallback = async (fullPath, flags, info) => {\r\n\t    if (this.fsw.closed) return;\r\n\t    if (\r\n\t      opts.depth !== undefined &&\r\n\t      calcDepth(fullPath, realPath) > opts.depth\r\n\t    ) return;\r\n\t    const path = transform(sysPath.join(\r\n\t      watchPath, sysPath.relative(watchPath, fullPath)\r\n\t    ));\r\n\t    if (globFilter && !globFilter(path)) return;\r\n\t    // ensure directories are tracked\r\n\t    const parent = sysPath.dirname(path);\r\n\t    const item = sysPath.basename(path);\r\n\t    const watchedDir = this.fsw._getWatchedDir(\r\n\t      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\r\n\t    );\r\n\r\n\t    // correct for wrong events emitted\r\n\t    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\r\n\t      if (typeof opts.ignored === FUNCTION_TYPE) {\r\n\t        let stats;\r\n\t        try {\r\n\t          stats = await stat(path);\r\n\t        } catch (error) {}\r\n\t        if (this.fsw.closed) return;\r\n\t        if (this.checkIgnored(path, stats)) return;\r\n\t        if (sameTypes(info, stats)) {\r\n\t          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t        } else {\r\n\t          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t        }\r\n\t      } else {\r\n\t        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t      }\r\n\t    } else {\r\n\t      switch (info.event) {\r\n\t      case FSEVENT_CREATED:\r\n\t      case FSEVENT_MODIFIED:\r\n\t        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t      case FSEVENT_DELETED:\r\n\t      case FSEVENT_MOVED:\r\n\t        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\r\n\t      }\r\n\t    }\r\n\t  };\r\n\r\n\t  const closer = setFSEventsListener(\r\n\t    watchPath,\r\n\t    realPath,\r\n\t    watchCallback,\r\n\t    this.fsw._emitRaw\r\n\t  );\r\n\r\n\t  this.fsw._emitReady();\r\n\t  return closer;\r\n\t}\r\n\r\n\t/**\r\n\t * Handle symlinks encountered during directory scan\r\n\t * @param {String} linkPath path to symlink\r\n\t * @param {String} fullPath absolute path to the symlink\r\n\t * @param {Function} transform pre-existing path transformer\r\n\t * @param {Number} curDepth level of subdirectories traversed to where symlink is\r\n\t * @returns {Promise<void>}\r\n\t */\r\n\tasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\r\n\t  // don't follow the same symlink more than once\r\n\t  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\r\n\r\n\t  this.fsw._symlinkPaths.set(fullPath, true);\r\n\t  this.fsw._incrReadyCount();\r\n\r\n\t  try {\r\n\t    const linkTarget = await realpath(linkPath);\r\n\t    if (this.fsw.closed) return;\r\n\t    if (this.fsw._isIgnored(linkTarget)) {\r\n\t      return this.fsw._emitReady();\r\n\t    }\r\n\r\n\t    this.fsw._incrReadyCount();\r\n\r\n\t    // add the linkTarget for watching with a wrapper for transform\r\n\t    // that causes emitted paths to incorporate the link's path\r\n\t    this._addToFsEvents(linkTarget || linkPath, (path) => {\r\n\t      let aliasedPath = linkPath;\r\n\t      if (linkTarget && linkTarget !== DOT_SLASH) {\r\n\t        aliasedPath = path.replace(linkTarget, linkPath);\r\n\t      } else if (path !== DOT_SLASH) {\r\n\t        aliasedPath = sysPath.join(linkPath, path);\r\n\t      }\r\n\t      return transform(aliasedPath);\r\n\t    }, false, curDepth);\r\n\t  } catch(error) {\r\n\t    if (this.fsw._handleError(error)) {\r\n\t      return this.fsw._emitReady();\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Path} newPath\r\n\t * @param {fs.Stats} stats\r\n\t */\r\n\temitAdd(newPath, stats, processPath, opts, forceAdd) {\r\n\t  const pp = processPath(newPath);\r\n\t  const isDir = stats.isDirectory();\r\n\t  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\r\n\t  const base = sysPath.basename(pp);\r\n\r\n\t  // ensure empty dirs get tracked\r\n\t  if (isDir) this.fsw._getWatchedDir(pp);\r\n\t  if (dirObj.has(base)) return;\r\n\t  dirObj.add(base);\r\n\r\n\t  if (!opts.ignoreInitial || forceAdd === true) {\r\n\t    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\r\n\t  }\r\n\t}\r\n\r\n\tinitWatch(realPath, path, wh, processPath) {\r\n\t  if (this.fsw.closed) return;\r\n\t  const closer = this._watchWithFsEvents(\r\n\t    wh.watchPath,\r\n\t    sysPath.resolve(realPath || wh.watchPath),\r\n\t    processPath,\r\n\t    wh.globFilter\r\n\t  );\r\n\t  this.fsw._addPathCloser(path, closer);\r\n\t}\r\n\r\n\t/**\r\n\t * Handle added path with fsevents\r\n\t * @param {String} path file/dir path or glob pattern\r\n\t * @param {Function|Boolean=} transform converts working path to what the user expects\r\n\t * @param {Boolean=} forceAdd ensure add is emitted\r\n\t * @param {Number=} priorDepth Level of subdirectories already traversed.\r\n\t * @returns {Promise<void>}\r\n\t */\r\n\tasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\r\n\t  if (this.fsw.closed) {\r\n\t    return;\r\n\t  }\r\n\t  const opts = this.fsw.options;\r\n\t  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\r\n\r\n\t  const wh = this.fsw._getWatchHelpers(path);\r\n\r\n\t  // evaluate what is at the path we're being asked to watch\r\n\t  try {\r\n\t    const stats = await statMethods[wh.statMethod](wh.watchPath);\r\n\t    if (this.fsw.closed) return;\r\n\t    if (this.fsw._isIgnored(wh.watchPath, stats)) {\r\n\t      throw null;\r\n\t    }\r\n\t    if (stats.isDirectory()) {\r\n\t      // emit addDir unless this is a glob parent\r\n\t      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\r\n\r\n\t      // don't recurse further if it would exceed depth setting\r\n\t      if (priorDepth && priorDepth > opts.depth) return;\r\n\r\n\t      // scan the contents of the dir\r\n\t      this.fsw._readdirp(wh.watchPath, {\r\n\t        fileFilter: entry => wh.filterPath(entry),\r\n\t        directoryFilter: entry => wh.filterDir(entry),\r\n\t        ...Depth(opts.depth - (priorDepth || 0))\r\n\t      }).on(STR_DATA, (entry) => {\r\n\t        // need to check filterPath on dirs b/c filterDir is less restrictive\r\n\t        if (this.fsw.closed) {\r\n\t          return;\r\n\t        }\r\n\t        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\r\n\r\n\t        const joinedPath = sysPath.join(wh.watchPath, entry.path);\r\n\t        const {fullPath} = entry;\r\n\r\n\t        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\r\n\t          // preserve the current depth here since it can't be derived from\r\n\t          // real paths past the symlink\r\n\t          const curDepth = opts.depth === undefined ?\r\n\t            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\r\n\r\n\t          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\r\n\t        } else {\r\n\t          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\r\n\t        }\r\n\t      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\r\n\t        this.fsw._emitReady();\r\n\t      });\r\n\t    } else {\r\n\t      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\r\n\t      this.fsw._emitReady();\r\n\t    }\r\n\t  } catch (error) {\r\n\t    if (!error || this.fsw._handleError(error)) {\r\n\t      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\r\n\t      this.fsw._emitReady();\r\n\t      this.fsw._emitReady();\r\n\t    }\r\n\t  }\r\n\r\n\t  if (opts.persistent && forceAdd !== true) {\r\n\t    if (typeof transform === FUNCTION_TYPE) {\r\n\t      // realpath has already been resolved\r\n\t      this.initWatch(undefined, path, wh, processPath);\r\n\t    } else {\r\n\t      let realPath;\r\n\t      try {\r\n\t        realPath = await realpath(wh.watchPath);\r\n\t      } catch (e) {}\r\n\t      this.initWatch(realPath, path, wh, processPath);\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\t}\r\n\r\n\tfseventsHandler.exports = FsEventsHandler;\r\n\tfseventsHandler.exports.canUse = canUse;\r\n\treturn fseventsHandler.exports;\r\n}\r\n\r\nvar hasRequiredChokidar;\r\n\r\nfunction requireChokidar () {\r\n\tif (hasRequiredChokidar) return chokidar$1;\r\n\thasRequiredChokidar = 1;\r\n\r\n\tconst { EventEmitter } = require$$0$3;\r\n\tconst fs = require$$0$2;\r\n\tconst sysPath = require$$0$1;\r\n\tconst { promisify } = require$$2;\r\n\tconst readdirp = /*@__PURE__*/ requireReaddirp();\r\n\tconst anymatch = /*@__PURE__*/ requireAnymatch().default;\r\n\tconst globParent = /*@__PURE__*/ requireGlobParent();\r\n\tconst isGlob = /*@__PURE__*/ requireIsGlob();\r\n\tconst braces = /*@__PURE__*/ requireBraces();\r\n\tconst normalizePath = /*@__PURE__*/ requireNormalizePath();\r\n\r\n\tconst NodeFsHandler = /*@__PURE__*/ requireNodefsHandler();\r\n\tconst FsEventsHandler = /*@__PURE__*/ requireFseventsHandler();\r\n\tconst {\r\n\t  EV_ALL,\r\n\t  EV_READY,\r\n\t  EV_ADD,\r\n\t  EV_CHANGE,\r\n\t  EV_UNLINK,\r\n\t  EV_ADD_DIR,\r\n\t  EV_UNLINK_DIR,\r\n\t  EV_RAW,\r\n\t  EV_ERROR,\r\n\r\n\t  STR_CLOSE,\r\n\t  STR_END,\r\n\r\n\t  BACK_SLASH_RE,\r\n\t  DOUBLE_SLASH_RE,\r\n\t  SLASH_OR_BACK_SLASH_RE,\r\n\t  DOT_RE,\r\n\t  REPLACER_RE,\r\n\r\n\t  SLASH,\r\n\t  SLASH_SLASH,\r\n\t  BRACE_START,\r\n\t  BANG,\r\n\t  ONE_DOT,\r\n\t  TWO_DOTS,\r\n\t  GLOBSTAR,\r\n\t  SLASH_GLOBSTAR,\r\n\t  ANYMATCH_OPTS,\r\n\t  STRING_TYPE,\r\n\t  FUNCTION_TYPE,\r\n\t  EMPTY_STR,\r\n\t  EMPTY_FN,\r\n\r\n\t  isWindows,\r\n\t  isMacos,\r\n\t  isIBMi\r\n\t} = /*@__PURE__*/ requireConstants();\r\n\r\n\tconst stat = promisify(fs.stat);\r\n\tconst readdir = promisify(fs.readdir);\r\n\r\n\t/**\r\n\t * @typedef {String} Path\r\n\t * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\r\n\t * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\r\n\t */\r\n\r\n\t/**\r\n\t *\r\n\t * @typedef {Object} WatchHelpers\r\n\t * @property {Boolean} followSymlinks\r\n\t * @property {'stat'|'lstat'} statMethod\r\n\t * @property {Path} path\r\n\t * @property {Path} watchPath\r\n\t * @property {Function} entryPath\r\n\t * @property {Boolean} hasGlob\r\n\t * @property {Object} globFilter\r\n\t * @property {Function} filterPath\r\n\t * @property {Function} filterDir\r\n\t */\r\n\r\n\tconst arrify = (value = []) => Array.isArray(value) ? value : [value];\r\n\tconst flatten = (list, result = []) => {\r\n\t  list.forEach(item => {\r\n\t    if (Array.isArray(item)) {\r\n\t      flatten(item, result);\r\n\t    } else {\r\n\t      result.push(item);\r\n\t    }\r\n\t  });\r\n\t  return result;\r\n\t};\r\n\r\n\tconst unifyPaths = (paths_) => {\r\n\t  /**\r\n\t   * @type {Array<String>}\r\n\t   */\r\n\t  const paths = flatten(arrify(paths_));\r\n\t  if (!paths.every(p => typeof p === STRING_TYPE)) {\r\n\t    throw new TypeError(`Non-string provided as watch path: ${paths}`);\r\n\t  }\r\n\t  return paths.map(normalizePathToUnix);\r\n\t};\r\n\r\n\t// If SLASH_SLASH occurs at the beginning of path, it is not replaced\r\n\t//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\r\n\tconst toUnix = (string) => {\r\n\t  let str = string.replace(BACK_SLASH_RE, SLASH);\r\n\t  let prepend = false;\r\n\t  if (str.startsWith(SLASH_SLASH)) {\r\n\t    prepend = true;\r\n\t  }\r\n\t  while (str.match(DOUBLE_SLASH_RE)) {\r\n\t    str = str.replace(DOUBLE_SLASH_RE, SLASH);\r\n\t  }\r\n\t  if (prepend) {\r\n\t    str = SLASH + str;\r\n\t  }\r\n\t  return str;\r\n\t};\r\n\r\n\t// Our version of upath.normalize\r\n\t// TODO: this is not equal to path-normalize module - investigate why\r\n\tconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\r\n\r\n\tconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\r\n\t  if (typeof path !== STRING_TYPE) return path;\r\n\t  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\r\n\t};\r\n\r\n\tconst getAbsolutePath = (path, cwd) => {\r\n\t  if (sysPath.isAbsolute(path)) {\r\n\t    return path;\r\n\t  }\r\n\t  if (path.startsWith(BANG)) {\r\n\t    return BANG + sysPath.join(cwd, path.slice(1));\r\n\t  }\r\n\t  return sysPath.join(cwd, path);\r\n\t};\r\n\r\n\tconst undef = (opts, key) => opts[key] === undefined;\r\n\r\n\t/**\r\n\t * Directory entry.\r\n\t * @property {Path} path\r\n\t * @property {Set<Path>} items\r\n\t */\r\n\tclass DirEntry {\r\n\t  /**\r\n\t   * @param {Path} dir\r\n\t   * @param {Function} removeWatcher\r\n\t   */\r\n\t  constructor(dir, removeWatcher) {\r\n\t    this.path = dir;\r\n\t    this._removeWatcher = removeWatcher;\r\n\t    /** @type {Set<Path>} */\r\n\t    this.items = new Set();\r\n\t  }\r\n\r\n\t  add(item) {\r\n\t    const {items} = this;\r\n\t    if (!items) return;\r\n\t    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\r\n\t  }\r\n\r\n\t  async remove(item) {\r\n\t    const {items} = this;\r\n\t    if (!items) return;\r\n\t    items.delete(item);\r\n\t    if (items.size > 0) return;\r\n\r\n\t    const dir = this.path;\r\n\t    try {\r\n\t      await readdir(dir);\r\n\t    } catch (err) {\r\n\t      if (this._removeWatcher) {\r\n\t        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\r\n\t      }\r\n\t    }\r\n\t  }\r\n\r\n\t  has(item) {\r\n\t    const {items} = this;\r\n\t    if (!items) return;\r\n\t    return items.has(item);\r\n\t  }\r\n\r\n\t  /**\r\n\t   * @returns {Array<String>}\r\n\t   */\r\n\t  getChildren() {\r\n\t    const {items} = this;\r\n\t    if (!items) return;\r\n\t    return [...items.values()];\r\n\t  }\r\n\r\n\t  dispose() {\r\n\t    this.items.clear();\r\n\t    delete this.path;\r\n\t    delete this._removeWatcher;\r\n\t    delete this.items;\r\n\t    Object.freeze(this);\r\n\t  }\r\n\t}\r\n\r\n\tconst STAT_METHOD_F = 'stat';\r\n\tconst STAT_METHOD_L = 'lstat';\r\n\tclass WatchHelper {\r\n\t  constructor(path, watchPath, follow, fsw) {\r\n\t    this.fsw = fsw;\r\n\t    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\r\n\t    this.watchPath = watchPath;\r\n\t    this.fullWatchPath = sysPath.resolve(watchPath);\r\n\t    this.hasGlob = watchPath !== path;\r\n\t    /** @type {object|boolean} */\r\n\t    if (path === EMPTY_STR) this.hasGlob = false;\r\n\t    this.globSymlink = this.hasGlob && follow ? undefined : false;\r\n\t    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\r\n\t    this.dirParts = this.getDirParts(path);\r\n\t    this.dirParts.forEach((parts) => {\r\n\t      if (parts.length > 1) parts.pop();\r\n\t    });\r\n\t    this.followSymlinks = follow;\r\n\t    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\r\n\t  }\r\n\r\n\t  checkGlobSymlink(entry) {\r\n\t    // only need to resolve once\r\n\t    // first entry should always have entry.parentDir === EMPTY_STR\r\n\t    if (this.globSymlink === undefined) {\r\n\t      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\r\n\t        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\r\n\t    }\r\n\r\n\t    if (this.globSymlink) {\r\n\t      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\r\n\t    }\r\n\r\n\t    return entry.fullPath;\r\n\t  }\r\n\r\n\t  entryPath(entry) {\r\n\t    return sysPath.join(this.watchPath,\r\n\t      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\r\n\t    );\r\n\t  }\r\n\r\n\t  filterPath(entry) {\r\n\t    const {stats} = entry;\r\n\t    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\r\n\t    const resolvedPath = this.entryPath(entry);\r\n\t    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\r\n\t      this.globFilter(resolvedPath) : true;\r\n\t    return matchesGlob &&\r\n\t      this.fsw._isntIgnored(resolvedPath, stats) &&\r\n\t      this.fsw._hasReadPermissions(stats);\r\n\t  }\r\n\r\n\t  getDirParts(path) {\r\n\t    if (!this.hasGlob) return [];\r\n\t    const parts = [];\r\n\t    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\r\n\t    expandedPath.forEach((path) => {\r\n\t      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\r\n\t    });\r\n\t    return parts;\r\n\t  }\r\n\r\n\t  filterDir(entry) {\r\n\t    if (this.hasGlob) {\r\n\t      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\r\n\t      let globstar = false;\r\n\t      this.unmatchedGlob = !this.dirParts.some((parts) => {\r\n\t        return parts.every((part, i) => {\r\n\t          if (part === GLOBSTAR) globstar = true;\r\n\t          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\r\n\t        });\r\n\t      });\r\n\t    }\r\n\t    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Watches files & directories for changes. Emitted events:\r\n\t * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\r\n\t *\r\n\t *     new FSWatcher()\r\n\t *       .add(directories)\r\n\t *       .on('add', path => log('File', path, 'was added'))\r\n\t */\r\n\tclass FSWatcher extends EventEmitter {\r\n\t// Not indenting methods for history sake; for now.\r\n\tconstructor(_opts) {\r\n\t  super();\r\n\r\n\t  const opts = {};\r\n\t  if (_opts) Object.assign(opts, _opts); // for frozen objects\r\n\r\n\t  /** @type {Map<String, DirEntry>} */\r\n\t  this._watched = new Map();\r\n\t  /** @type {Map<String, Array>} */\r\n\t  this._closers = new Map();\r\n\t  /** @type {Set<String>} */\r\n\t  this._ignoredPaths = new Set();\r\n\r\n\t  /** @type {Map<ThrottleType, Map>} */\r\n\t  this._throttled = new Map();\r\n\r\n\t  /** @type {Map<Path, String|Boolean>} */\r\n\t  this._symlinkPaths = new Map();\r\n\r\n\t  this._streams = new Set();\r\n\t  this.closed = false;\r\n\r\n\t  // Set up default options.\r\n\t  if (undef(opts, 'persistent')) opts.persistent = true;\r\n\t  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\r\n\t  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\r\n\t  if (undef(opts, 'interval')) opts.interval = 100;\r\n\t  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\r\n\t  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\r\n\t  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\r\n\r\n\t  // Enable fsevents on OS X when polling isn't explicitly enabled.\r\n\t  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\r\n\r\n\t  // If we can't use fsevents, ensure the options reflect it's disabled.\r\n\t  const canUseFsEvents = FsEventsHandler.canUse();\r\n\t  if (!canUseFsEvents) opts.useFsEvents = false;\r\n\r\n\t  // Use polling on Mac if not using fsevents.\r\n\t  // Other platforms use non-polling fs_watch.\r\n\t  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\r\n\t    opts.usePolling = isMacos;\r\n\t  }\r\n\r\n\t  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\r\n\t  if(isIBMi) {\r\n\t    opts.usePolling = true;\r\n\t  }\r\n\r\n\t  // Global override (useful for end-developers that need to force polling for all\r\n\t  // instances of chokidar, regardless of usage/dependency depth)\r\n\t  const envPoll = process.env.CHOKIDAR_USEPOLLING;\r\n\t  if (envPoll !== undefined) {\r\n\t    const envLower = envPoll.toLowerCase();\r\n\r\n\t    if (envLower === 'false' || envLower === '0') {\r\n\t      opts.usePolling = false;\r\n\t    } else if (envLower === 'true' || envLower === '1') {\r\n\t      opts.usePolling = true;\r\n\t    } else {\r\n\t      opts.usePolling = !!envLower;\r\n\t    }\r\n\t  }\r\n\t  const envInterval = process.env.CHOKIDAR_INTERVAL;\r\n\t  if (envInterval) {\r\n\t    opts.interval = Number.parseInt(envInterval, 10);\r\n\t  }\r\n\r\n\t  // Editor atomic write normalization enabled by default with fs.watch\r\n\t  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\r\n\t  if (opts.atomic) this._pendingUnlinks = new Map();\r\n\r\n\t  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\r\n\r\n\t  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\r\n\t  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\r\n\t  const awf = opts.awaitWriteFinish;\r\n\t  if (awf) {\r\n\t    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\r\n\t    if (!awf.pollInterval) awf.pollInterval = 100;\r\n\t    this._pendingWrites = new Map();\r\n\t  }\r\n\t  if (opts.ignored) opts.ignored = arrify(opts.ignored);\r\n\r\n\t  let readyCalls = 0;\r\n\t  this._emitReady = () => {\r\n\t    readyCalls++;\r\n\t    if (readyCalls >= this._readyCount) {\r\n\t      this._emitReady = EMPTY_FN;\r\n\t      this._readyEmitted = true;\r\n\t      // use process.nextTick to allow time for listener to be bound\r\n\t      process.nextTick(() => this.emit(EV_READY));\r\n\t    }\r\n\t  };\r\n\t  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\r\n\t  this._readyEmitted = false;\r\n\t  this.options = opts;\r\n\r\n\t  // Initialize with proper watcher.\r\n\t  if (opts.useFsEvents) {\r\n\t    this._fsEventsHandler = new FsEventsHandler(this);\r\n\t  } else {\r\n\t    this._nodeFsHandler = new NodeFsHandler(this);\r\n\t  }\r\n\r\n\t  // You’re frozen when your heart’s not open.\r\n\t  Object.freeze(opts);\r\n\t}\r\n\r\n\t// Public methods\r\n\r\n\t/**\r\n\t * Adds paths to be watched on an existing FSWatcher instance\r\n\t * @param {Path|Array<Path>} paths_\r\n\t * @param {String=} _origAdd private; for handling non-existent paths to be watched\r\n\t * @param {Boolean=} _internal private; indicates a non-user add\r\n\t * @returns {FSWatcher} for chaining\r\n\t */\r\n\tadd(paths_, _origAdd, _internal) {\r\n\t  const {cwd, disableGlobbing} = this.options;\r\n\t  this.closed = false;\r\n\t  let paths = unifyPaths(paths_);\r\n\t  if (cwd) {\r\n\t    paths = paths.map((path) => {\r\n\t      const absPath = getAbsolutePath(path, cwd);\r\n\r\n\t      // Check `path` instead of `absPath` because the cwd portion can't be a glob\r\n\t      if (disableGlobbing || !isGlob(path)) {\r\n\t        return absPath;\r\n\t      }\r\n\t      return normalizePath(absPath);\r\n\t    });\r\n\t  }\r\n\r\n\t  // set aside negated glob strings\r\n\t  paths = paths.filter((path) => {\r\n\t    if (path.startsWith(BANG)) {\r\n\t      this._ignoredPaths.add(path.slice(1));\r\n\t      return false;\r\n\t    }\r\n\r\n\t    // if a path is being added that was previously ignored, stop ignoring it\r\n\t    this._ignoredPaths.delete(path);\r\n\t    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\r\n\r\n\t    // reset the cached userIgnored anymatch fn\r\n\t    // to make ignoredPaths changes effective\r\n\t    this._userIgnored = undefined;\r\n\r\n\t    return true;\r\n\t  });\r\n\r\n\t  if (this.options.useFsEvents && this._fsEventsHandler) {\r\n\t    if (!this._readyCount) this._readyCount = paths.length;\r\n\t    if (this.options.persistent) this._readyCount += paths.length;\r\n\t    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\r\n\t  } else {\r\n\t    if (!this._readyCount) this._readyCount = 0;\r\n\t    this._readyCount += paths.length;\r\n\t    Promise.all(\r\n\t      paths.map(async path => {\r\n\t        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\r\n\t        if (res) this._emitReady();\r\n\t        return res;\r\n\t      })\r\n\t    ).then(results => {\r\n\t      if (this.closed) return;\r\n\t      results.filter(item => item).forEach(item => {\r\n\t        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\r\n\t      });\r\n\t    });\r\n\t  }\r\n\r\n\t  return this;\r\n\t}\r\n\r\n\t/**\r\n\t * Close watchers or start ignoring events from specified paths.\r\n\t * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\r\n\t * @returns {FSWatcher} for chaining\r\n\t*/\r\n\tunwatch(paths_) {\r\n\t  if (this.closed) return this;\r\n\t  const paths = unifyPaths(paths_);\r\n\t  const {cwd} = this.options;\r\n\r\n\t  paths.forEach((path) => {\r\n\t    // convert to absolute path unless relative path already matches\r\n\t    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\r\n\t      if (cwd) path = sysPath.join(cwd, path);\r\n\t      path = sysPath.resolve(path);\r\n\t    }\r\n\r\n\t    this._closePath(path);\r\n\r\n\t    this._ignoredPaths.add(path);\r\n\t    if (this._watched.has(path)) {\r\n\t      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\r\n\t    }\r\n\r\n\t    // reset the cached userIgnored anymatch fn\r\n\t    // to make ignoredPaths changes effective\r\n\t    this._userIgnored = undefined;\r\n\t  });\r\n\r\n\t  return this;\r\n\t}\r\n\r\n\t/**\r\n\t * Close watchers and remove all listeners from watched paths.\r\n\t * @returns {Promise<void>}.\r\n\t*/\r\n\tclose() {\r\n\t  if (this.closed) return this._closePromise;\r\n\t  this.closed = true;\r\n\r\n\t  // Memory management.\r\n\t  this.removeAllListeners();\r\n\t  const closers = [];\r\n\t  this._closers.forEach(closerList => closerList.forEach(closer => {\r\n\t    const promise = closer();\r\n\t    if (promise instanceof Promise) closers.push(promise);\r\n\t  }));\r\n\t  this._streams.forEach(stream => stream.destroy());\r\n\t  this._userIgnored = undefined;\r\n\t  this._readyCount = 0;\r\n\t  this._readyEmitted = false;\r\n\t  this._watched.forEach(dirent => dirent.dispose());\r\n\t  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\r\n\t    this[`_${key}`].clear();\r\n\t  });\r\n\r\n\t  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\r\n\t  return this._closePromise;\r\n\t}\r\n\r\n\t/**\r\n\t * Expose list of watched paths\r\n\t * @returns {Object} for chaining\r\n\t*/\r\n\tgetWatched() {\r\n\t  const watchList = {};\r\n\t  this._watched.forEach((entry, dir) => {\r\n\t    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\r\n\t    watchList[key || ONE_DOT] = entry.getChildren().sort();\r\n\t  });\r\n\t  return watchList;\r\n\t}\r\n\r\n\temitWithAll(event, args) {\r\n\t  this.emit(...args);\r\n\t  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\r\n\t}\r\n\r\n\t// Common helpers\r\n\t// --------------\r\n\r\n\t/**\r\n\t * Normalize and emit events.\r\n\t * Calling _emit DOES NOT MEAN emit() would be called!\r\n\t * @param {EventName} event Type of event\r\n\t * @param {Path} path File or directory path\r\n\t * @param {*=} val1 arguments to be passed with event\r\n\t * @param {*=} val2\r\n\t * @param {*=} val3\r\n\t * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\r\n\t */\r\n\tasync _emit(event, path, val1, val2, val3) {\r\n\t  if (this.closed) return;\r\n\r\n\t  const opts = this.options;\r\n\t  if (isWindows) path = sysPath.normalize(path);\r\n\t  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\r\n\t  /** @type Array<any> */\r\n\t  const args = [event, path];\r\n\t  if (val3 !== undefined) args.push(val1, val2, val3);\r\n\t  else if (val2 !== undefined) args.push(val1, val2);\r\n\t  else if (val1 !== undefined) args.push(val1);\r\n\r\n\t  const awf = opts.awaitWriteFinish;\r\n\t  let pw;\r\n\t  if (awf && (pw = this._pendingWrites.get(path))) {\r\n\t    pw.lastChange = new Date();\r\n\t    return this;\r\n\t  }\r\n\r\n\t  if (opts.atomic) {\r\n\t    if (event === EV_UNLINK) {\r\n\t      this._pendingUnlinks.set(path, args);\r\n\t      setTimeout(() => {\r\n\t        this._pendingUnlinks.forEach((entry, path) => {\r\n\t          this.emit(...entry);\r\n\t          this.emit(EV_ALL, ...entry);\r\n\t          this._pendingUnlinks.delete(path);\r\n\t        });\r\n\t      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\r\n\t      return this;\r\n\t    }\r\n\t    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\r\n\t      event = args[0] = EV_CHANGE;\r\n\t      this._pendingUnlinks.delete(path);\r\n\t    }\r\n\t  }\r\n\r\n\t  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\r\n\t    const awfEmit = (err, stats) => {\r\n\t      if (err) {\r\n\t        event = args[0] = EV_ERROR;\r\n\t        args[1] = err;\r\n\t        this.emitWithAll(event, args);\r\n\t      } else if (stats) {\r\n\t        // if stats doesn't exist the file must have been deleted\r\n\t        if (args.length > 2) {\r\n\t          args[2] = stats;\r\n\t        } else {\r\n\t          args.push(stats);\r\n\t        }\r\n\t        this.emitWithAll(event, args);\r\n\t      }\r\n\t    };\r\n\r\n\t    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\r\n\t    return this;\r\n\t  }\r\n\r\n\t  if (event === EV_CHANGE) {\r\n\t    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\r\n\t    if (isThrottled) return this;\r\n\t  }\r\n\r\n\t  if (opts.alwaysStat && val1 === undefined &&\r\n\t    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\r\n\t  ) {\r\n\t    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\r\n\t    let stats;\r\n\t    try {\r\n\t      stats = await stat(fullPath);\r\n\t    } catch (err) {}\r\n\t    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\r\n\t    if (!stats || this.closed) return;\r\n\t    args.push(stats);\r\n\t  }\r\n\t  this.emitWithAll(event, args);\r\n\r\n\t  return this;\r\n\t}\r\n\r\n\t/**\r\n\t * Common handler for errors\r\n\t * @param {Error} error\r\n\t * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\r\n\t */\r\n\t_handleError(error) {\r\n\t  const code = error && error.code;\r\n\t  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\r\n\t    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\r\n\t  ) {\r\n\t    this.emit(EV_ERROR, error);\r\n\t  }\r\n\t  return error || this.closed;\r\n\t}\r\n\r\n\t/**\r\n\t * Helper utility for throttling\r\n\t * @param {ThrottleType} actionType type being throttled\r\n\t * @param {Path} path being acted upon\r\n\t * @param {Number} timeout duration of time to suppress duplicate actions\r\n\t * @returns {Object|false} tracking object or false if action should be suppressed\r\n\t */\r\n\t_throttle(actionType, path, timeout) {\r\n\t  if (!this._throttled.has(actionType)) {\r\n\t    this._throttled.set(actionType, new Map());\r\n\t  }\r\n\r\n\t  /** @type {Map<Path, Object>} */\r\n\t  const action = this._throttled.get(actionType);\r\n\t  /** @type {Object} */\r\n\t  const actionPath = action.get(path);\r\n\r\n\t  if (actionPath) {\r\n\t    actionPath.count++;\r\n\t    return false;\r\n\t  }\r\n\r\n\t  let timeoutObject;\r\n\t  const clear = () => {\r\n\t    const item = action.get(path);\r\n\t    const count = item ? item.count : 0;\r\n\t    action.delete(path);\r\n\t    clearTimeout(timeoutObject);\r\n\t    if (item) clearTimeout(item.timeoutObject);\r\n\t    return count;\r\n\t  };\r\n\t  timeoutObject = setTimeout(clear, timeout);\r\n\t  const thr = {timeoutObject, clear, count: 0};\r\n\t  action.set(path, thr);\r\n\t  return thr;\r\n\t}\r\n\r\n\t_incrReadyCount() {\r\n\t  return this._readyCount++;\r\n\t}\r\n\r\n\t/**\r\n\t * Awaits write operation to finish.\r\n\t * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\r\n\t * @param {Path} path being acted upon\r\n\t * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\r\n\t * @param {EventName} event\r\n\t * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\r\n\t */\r\n\t_awaitWriteFinish(path, threshold, event, awfEmit) {\r\n\t  let timeoutHandler;\r\n\r\n\t  let fullPath = path;\r\n\t  if (this.options.cwd && !sysPath.isAbsolute(path)) {\r\n\t    fullPath = sysPath.join(this.options.cwd, path);\r\n\t  }\r\n\r\n\t  const now = new Date();\r\n\r\n\t  const awaitWriteFinish = (prevStat) => {\r\n\t    fs.stat(fullPath, (err, curStat) => {\r\n\t      if (err || !this._pendingWrites.has(path)) {\r\n\t        if (err && err.code !== 'ENOENT') awfEmit(err);\r\n\t        return;\r\n\t      }\r\n\r\n\t      const now = Number(new Date());\r\n\r\n\t      if (prevStat && curStat.size !== prevStat.size) {\r\n\t        this._pendingWrites.get(path).lastChange = now;\r\n\t      }\r\n\t      const pw = this._pendingWrites.get(path);\r\n\t      const df = now - pw.lastChange;\r\n\r\n\t      if (df >= threshold) {\r\n\t        this._pendingWrites.delete(path);\r\n\t        awfEmit(undefined, curStat);\r\n\t      } else {\r\n\t        timeoutHandler = setTimeout(\r\n\t          awaitWriteFinish,\r\n\t          this.options.awaitWriteFinish.pollInterval,\r\n\t          curStat\r\n\t        );\r\n\t      }\r\n\t    });\r\n\t  };\r\n\r\n\t  if (!this._pendingWrites.has(path)) {\r\n\t    this._pendingWrites.set(path, {\r\n\t      lastChange: now,\r\n\t      cancelWait: () => {\r\n\t        this._pendingWrites.delete(path);\r\n\t        clearTimeout(timeoutHandler);\r\n\t        return event;\r\n\t      }\r\n\t    });\r\n\t    timeoutHandler = setTimeout(\r\n\t      awaitWriteFinish,\r\n\t      this.options.awaitWriteFinish.pollInterval\r\n\t    );\r\n\t  }\r\n\t}\r\n\r\n\t_getGlobIgnored() {\r\n\t  return [...this._ignoredPaths.values()];\r\n\t}\r\n\r\n\t/**\r\n\t * Determines whether user has asked to ignore this path.\r\n\t * @param {Path} path filepath or dir\r\n\t * @param {fs.Stats=} stats result of fs.stat\r\n\t * @returns {Boolean}\r\n\t */\r\n\t_isIgnored(path, stats) {\r\n\t  if (this.options.atomic && DOT_RE.test(path)) return true;\r\n\t  if (!this._userIgnored) {\r\n\t    const {cwd} = this.options;\r\n\t    const ign = this.options.ignored;\r\n\r\n\t    const ignored = ign && ign.map(normalizeIgnored(cwd));\r\n\t    const paths = arrify(ignored)\r\n\t      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\r\n\t      .map((path) => path + SLASH_GLOBSTAR);\r\n\t    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\r\n\t    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\r\n\t  }\r\n\r\n\t  return this._userIgnored([path, stats]);\r\n\t}\r\n\r\n\t_isntIgnored(path, stat) {\r\n\t  return !this._isIgnored(path, stat);\r\n\t}\r\n\r\n\t/**\r\n\t * Provides a set of common helpers and properties relating to symlink and glob handling.\r\n\t * @param {Path} path file, directory, or glob pattern being watched\r\n\t * @param {Number=} depth at any depth > 0, this isn't a glob\r\n\t * @returns {WatchHelper} object containing helpers for this path\r\n\t */\r\n\t_getWatchHelpers(path, depth) {\r\n\t  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\r\n\t  const follow = this.options.followSymlinks;\r\n\r\n\t  return new WatchHelper(path, watchPath, follow, this);\r\n\t}\r\n\r\n\t// Directory helpers\r\n\t// -----------------\r\n\r\n\t/**\r\n\t * Provides directory tracking objects\r\n\t * @param {String} directory path of the directory\r\n\t * @returns {DirEntry} the directory's tracking object\r\n\t */\r\n\t_getWatchedDir(directory) {\r\n\t  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\r\n\t  const dir = sysPath.resolve(directory);\r\n\t  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\r\n\t  return this._watched.get(dir);\r\n\t}\r\n\r\n\t// File helpers\r\n\t// ------------\r\n\r\n\t/**\r\n\t * Check for read permissions.\r\n\t * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\r\n\t * @param {fs.Stats} stats - object, result of fs_stat\r\n\t * @returns {Boolean} indicates whether the file can be read\r\n\t*/\r\n\t_hasReadPermissions(stats) {\r\n\t  if (this.options.ignorePermissionErrors) return true;\r\n\r\n\t  // stats.mode may be bigint\r\n\t  const md = stats && Number.parseInt(stats.mode, 10);\r\n\t  const st = md & 0o777;\r\n\t  const it = Number.parseInt(st.toString(8)[0], 10);\r\n\t  return Boolean(4 & it);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles emitting unlink events for\r\n\t * files and directories, and via recursion, for\r\n\t * files and directories within directories that are unlinked\r\n\t * @param {String} directory within which the following item is located\r\n\t * @param {String} item      base path of item/directory\r\n\t * @returns {void}\r\n\t*/\r\n\t_remove(directory, item, isDirectory) {\r\n\t  // if what is being deleted is a directory, get that directory's paths\r\n\t  // for recursive deleting and cleaning of watched object\r\n\t  // if it is not a directory, nestedDirectoryChildren will be empty array\r\n\t  const path = sysPath.join(directory, item);\r\n\t  const fullPath = sysPath.resolve(path);\r\n\t  isDirectory = isDirectory != null\r\n\t    ? isDirectory\r\n\t    : this._watched.has(path) || this._watched.has(fullPath);\r\n\r\n\t  // prevent duplicate handling in case of arriving here nearly simultaneously\r\n\t  // via multiple paths (such as _handleFile and _handleDir)\r\n\t  if (!this._throttle('remove', path, 100)) return;\r\n\r\n\t  // if the only watched file is removed, watch for its return\r\n\t  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\r\n\t    this.add(directory, item, true);\r\n\t  }\r\n\r\n\t  // This will create a new entry in the watched object in either case\r\n\t  // so we got to do the directory check beforehand\r\n\t  const wp = this._getWatchedDir(path);\r\n\t  const nestedDirectoryChildren = wp.getChildren();\r\n\r\n\t  // Recursively remove children directories / files.\r\n\t  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\r\n\r\n\t  // Check if item was on the watched list and remove it\r\n\t  const parent = this._getWatchedDir(directory);\r\n\t  const wasTracked = parent.has(item);\r\n\t  parent.remove(item);\r\n\r\n\t  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\r\n\t  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\r\n\t  // but never removed from the map in case the path was deleted.\r\n\t  // This leads to an incorrect state if the path was recreated:\r\n\t  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\r\n\t  if (this._symlinkPaths.has(fullPath)) {\r\n\t    this._symlinkPaths.delete(fullPath);\r\n\t  }\r\n\r\n\t  // If we wait for this file to be fully written, cancel the wait.\r\n\t  let relPath = path;\r\n\t  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\r\n\t  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\r\n\t    const event = this._pendingWrites.get(relPath).cancelWait();\r\n\t    if (event === EV_ADD) return;\r\n\t  }\r\n\r\n\t  // The Entry will either be a directory that just got removed\r\n\t  // or a bogus entry to a file, in either case we have to remove it\r\n\t  this._watched.delete(path);\r\n\t  this._watched.delete(fullPath);\r\n\t  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\r\n\t  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\r\n\r\n\t  // Avoid conflicts if we later create another file with the same name\r\n\t  if (!this.options.useFsEvents) {\r\n\t    this._closePath(path);\r\n\t  }\r\n\t}\r\n\r\n\t/**\r\n\t * Closes all watchers for a path\r\n\t * @param {Path} path\r\n\t */\r\n\t_closePath(path) {\r\n\t  this._closeFile(path);\r\n\t  const dir = sysPath.dirname(path);\r\n\t  this._getWatchedDir(dir).remove(sysPath.basename(path));\r\n\t}\r\n\r\n\t/**\r\n\t * Closes only file-specific watchers\r\n\t * @param {Path} path\r\n\t */\r\n\t_closeFile(path) {\r\n\t  const closers = this._closers.get(path);\r\n\t  if (!closers) return;\r\n\t  closers.forEach(closer => closer());\r\n\t  this._closers.delete(path);\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @param {Path} path\r\n\t * @param {Function} closer\r\n\t */\r\n\t_addPathCloser(path, closer) {\r\n\t  if (!closer) return;\r\n\t  let list = this._closers.get(path);\r\n\t  if (!list) {\r\n\t    list = [];\r\n\t    this._closers.set(path, list);\r\n\t  }\r\n\t  list.push(closer);\r\n\t}\r\n\r\n\t_readdirp(root, opts) {\r\n\t  if (this.closed) return;\r\n\t  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\r\n\t  let stream = readdirp(root, options);\r\n\t  this._streams.add(stream);\r\n\t  stream.once(STR_CLOSE, () => {\r\n\t    stream = undefined;\r\n\t  });\r\n\t  stream.once(STR_END, () => {\r\n\t    if (stream) {\r\n\t      this._streams.delete(stream);\r\n\t      stream = undefined;\r\n\t    }\r\n\t  });\r\n\t  return stream;\r\n\t}\r\n\r\n\t}\r\n\r\n\t// Export FSWatcher class\r\n\tchokidar$1.FSWatcher = FSWatcher;\r\n\r\n\t/**\r\n\t * Instantiates watcher with paths to be tracked.\r\n\t * @param {String|Array<String>} paths file/directory paths and/or globs\r\n\t * @param {Object=} options chokidar opts\r\n\t * @returns an instance of FSWatcher for chaining.\r\n\t */\r\n\tconst watch = (paths, options) => {\r\n\t  const watcher = new FSWatcher(options);\r\n\t  watcher.add(paths);\r\n\t  return watcher;\r\n\t};\r\n\r\n\tchokidar$1.watch = watch;\r\n\treturn chokidar$1;\r\n}\r\n\r\nvar chokidarExports = /*@__PURE__*/ requireChokidar();\r\nconst chokidar = /*@__PURE__*/getDefaultExportFromCjs(chokidarExports);\r\n\r\nclass FileWatcher {\r\n    constructor(task, chokidarOptions) {\r\n        this.transformWatchers = new Map();\r\n        this.chokidarOptions = chokidarOptions;\r\n        this.task = task;\r\n        this.watcher = this.createWatcher(null);\r\n    }\r\n    close() {\r\n        this.watcher.close();\r\n        for (const watcher of this.transformWatchers.values()) {\r\n            watcher.close();\r\n        }\r\n    }\r\n    unwatch(id) {\r\n        this.watcher.unwatch(id);\r\n        const transformWatcher = this.transformWatchers.get(id);\r\n        if (transformWatcher) {\r\n            this.transformWatchers.delete(id);\r\n            transformWatcher.close();\r\n        }\r\n    }\r\n    watch(id, isTransformDependency) {\r\n        if (isTransformDependency) {\r\n            const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);\r\n            watcher.add(id);\r\n            this.transformWatchers.set(id, watcher);\r\n        }\r\n        else {\r\n            this.watcher.add(id);\r\n        }\r\n    }\r\n    createWatcher(transformWatcherId) {\r\n        const task = this.task;\r\n        const isLinux = platform() === 'linux';\r\n        const isFreeBSD = platform() === 'freebsd';\r\n        const isTransformDependency = transformWatcherId !== null;\r\n        const handleChange = (id, event) => {\r\n            const changedId = transformWatcherId || id;\r\n            if (isLinux || isFreeBSD) {\r\n                // unwatching and watching fixes an issue with chokidar where on certain systems,\r\n                // a file that was unlinked and immediately recreated would create a change event\r\n                // but then no longer any further events\r\n                watcher.unwatch(changedId);\r\n                watcher.add(changedId);\r\n            }\r\n            task.invalidate(changedId, { event, isTransformDependency });\r\n        };\r\n        const watcher = chokidar\r\n            .watch([], this.chokidarOptions)\r\n            .on('add', id => handleChange(id, 'create'))\r\n            .on('change', id => handleChange(id, 'update'))\r\n            .on('unlink', id => handleChange(id, 'delete'));\r\n        return watcher;\r\n    }\r\n}\r\n\r\nconst eventsRewrites = {\r\n    create: {\r\n        create: 'buggy',\r\n        delete: null, //delete file from map\r\n        update: 'create'\r\n    },\r\n    delete: {\r\n        create: 'update',\r\n        delete: 'buggy',\r\n        update: 'buggy'\r\n    },\r\n    update: {\r\n        create: 'buggy',\r\n        delete: 'delete',\r\n        update: 'update'\r\n    }\r\n};\r\nclass Watcher {\r\n    constructor(optionsList, emitter) {\r\n        this.buildDelay = 0;\r\n        this.buildTimeout = null;\r\n        this.closed = false;\r\n        this.invalidatedIds = new Map();\r\n        this.rerun = false;\r\n        this.running = true;\r\n        this.emitter = emitter;\r\n        emitter.close = this.close.bind(this);\r\n        this.tasks = optionsList.map(options => new Task(this, options));\r\n        for (const { watch } of optionsList) {\r\n            if (watch && typeof watch.buildDelay === 'number') {\r\n                this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);\r\n            }\r\n        }\r\n        process$1.nextTick(() => this.run());\r\n    }\r\n    async close() {\r\n        if (this.closed)\r\n            return;\r\n        this.closed = true;\r\n        if (this.buildTimeout)\r\n            clearTimeout(this.buildTimeout);\r\n        for (const task of this.tasks) {\r\n            task.close();\r\n        }\r\n        await this.emitter.emit('close');\r\n        this.emitter.removeAllListeners();\r\n    }\r\n    invalidate(file) {\r\n        if (file) {\r\n            const previousEvent = this.invalidatedIds.get(file.id);\r\n            const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;\r\n            if (event === 'buggy') {\r\n                //TODO: throws or warn? Currently just ignore, uses new event\r\n                this.invalidatedIds.set(file.id, file.event);\r\n            }\r\n            else if (event === null) {\r\n                this.invalidatedIds.delete(file.id);\r\n            }\r\n            else {\r\n                this.invalidatedIds.set(file.id, event);\r\n            }\r\n        }\r\n        if (this.running) {\r\n            this.rerun = true;\r\n            return;\r\n        }\r\n        if (this.buildTimeout)\r\n            clearTimeout(this.buildTimeout);\r\n        this.buildTimeout = setTimeout(async () => {\r\n            this.buildTimeout = null;\r\n            try {\r\n                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, { event })));\r\n                this.invalidatedIds.clear();\r\n                await this.emitter.emit('restart');\r\n                this.emitter.removeListenersForCurrentRun();\r\n                this.run();\r\n            }\r\n            catch (error) {\r\n                this.invalidatedIds.clear();\r\n                await this.emitter.emit('event', {\r\n                    code: 'ERROR',\r\n                    error,\r\n                    result: null\r\n                });\r\n                await this.emitter.emit('event', {\r\n                    code: 'END'\r\n                });\r\n            }\r\n        }, this.buildDelay);\r\n    }\r\n    async run() {\r\n        this.running = true;\r\n        await this.emitter.emit('event', {\r\n            code: 'START'\r\n        });\r\n        for (const task of this.tasks) {\r\n            await task.run();\r\n        }\r\n        this.running = false;\r\n        await this.emitter.emit('event', {\r\n            code: 'END'\r\n        });\r\n        if (this.rerun) {\r\n            this.rerun = false;\r\n            this.invalidate();\r\n        }\r\n    }\r\n}\r\nclass Task {\r\n    constructor(watcher, options) {\r\n        this.cache = { modules: [] };\r\n        this.watchFiles = [];\r\n        this.closed = false;\r\n        this.invalidated = true;\r\n        this.watched = new Set();\r\n        this.watcher = watcher;\r\n        this.options = options;\r\n        this.skipWrite = Boolean(options.watch && options.watch.skipWrite);\r\n        this.outputs = this.options.output;\r\n        this.outputFiles = this.outputs.map(output => {\r\n            if (output.file || output.dir)\r\n                return path.resolve(output.file || output.dir);\r\n            return undefined;\r\n        });\r\n        this.watchOptions = this.options.watch || {};\r\n        this.filter = createFilter(this.watchOptions.include, this.watchOptions.exclude);\r\n        this.fileWatcher = new FileWatcher(this, {\r\n            ...this.watchOptions.chokidar,\r\n            disableGlobbing: true,\r\n            ignoreInitial: true\r\n        });\r\n    }\r\n    close() {\r\n        this.closed = true;\r\n        this.fileWatcher.close();\r\n    }\r\n    invalidate(id, details) {\r\n        this.invalidated = true;\r\n        if (details.isTransformDependency) {\r\n            for (const module of this.cache.modules) {\r\n                if (!module.transformDependencies.includes(id))\r\n                    continue;\r\n                // effective invalidation\r\n                module.originalCode = null;\r\n            }\r\n        }\r\n        this.watcher.invalidate({ event: details.event, id });\r\n        this.watchOptions.onInvalidate?.(id);\r\n    }\r\n    async run() {\r\n        if (!this.invalidated)\r\n            return;\r\n        this.invalidated = false;\r\n        const options = {\r\n            ...this.options,\r\n            cache: this.cache\r\n        };\r\n        const start = Date.now();\r\n        await this.watcher.emitter.emit('event', {\r\n            code: 'BUNDLE_START',\r\n            input: this.options.input,\r\n            output: this.outputFiles\r\n        });\r\n        let result = null;\r\n        try {\r\n            result = await rollupInternal(options, this.watcher.emitter);\r\n            if (this.closed) {\r\n                return;\r\n            }\r\n            this.updateWatchedFiles(result);\r\n            if (!this.skipWrite) {\r\n                await Promise.all(this.outputs.map(output => result.write(output)));\r\n                if (this.closed) {\r\n                    return;\r\n                }\r\n                this.updateWatchedFiles(result);\r\n            }\r\n            await this.watcher.emitter.emit('event', {\r\n                code: 'BUNDLE_END',\r\n                duration: Date.now() - start,\r\n                input: this.options.input,\r\n                output: this.outputFiles,\r\n                result\r\n            });\r\n        }\r\n        catch (error) {\r\n            if (!this.closed) {\r\n                if (Array.isArray(error.watchFiles)) {\r\n                    for (const id of error.watchFiles) {\r\n                        this.watchFile(id);\r\n                    }\r\n                }\r\n                if (error.id) {\r\n                    this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\r\n                }\r\n            }\r\n            await this.watcher.emitter.emit('event', {\r\n                code: 'ERROR',\r\n                error,\r\n                result\r\n            });\r\n        }\r\n    }\r\n    updateWatchedFiles(result) {\r\n        const previouslyWatched = this.watched;\r\n        this.watched = new Set();\r\n        this.watchFiles = result.watchFiles;\r\n        this.cache = result.cache;\r\n        for (const id of this.watchFiles) {\r\n            this.watchFile(id);\r\n        }\r\n        for (const module of this.cache.modules) {\r\n            for (const depId of module.transformDependencies) {\r\n                this.watchFile(depId, true);\r\n            }\r\n        }\r\n        for (const id of previouslyWatched) {\r\n            if (!this.watched.has(id)) {\r\n                this.fileWatcher.unwatch(id);\r\n            }\r\n        }\r\n    }\r\n    watchFile(id, isTransformDependency = false) {\r\n        if (!this.filter(id))\r\n            return;\r\n        this.watched.add(id);\r\n        if (this.outputFiles.includes(id)) {\r\n            throw new Error('Cannot import the generated bundle');\r\n        }\r\n        // this is necessary to ensure that any 'renamed' files\r\n        // continue to be watched following an error\r\n        this.fileWatcher.watch(id, isTransformDependency);\r\n    }\r\n}\r\n\r\nexport { Task, Watcher };\r\n"],
  "mappings": "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EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,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",
  "names": ["path", "require$$0$1", "utils", "isGlob", "isExtglob", "constants", "opts", "value", "rest", "source", "picomatch", "state", "require$$0$2", "require$$1", "require$$2", "normalizePath", "testString", "returnIndex", "require$$2$1", "globParent", "node", "stringify", "isNumber", "max", "index", "binaryExtensions", "platform", "isBinaryPath", "rawEmitter", "listener", "newStats", "stats", "require$$0$3", "anymatch", "now", "stat", "process$1"]
}
