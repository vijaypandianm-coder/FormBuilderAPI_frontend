import {
  C
} from "./chunk-HUUV2CJB.js";
import {
  basename,
  dirname,
  isAbsolute,
  join,
  normalize,
  relative,
  resolve
} from "./chunk-5ZZAFORQ.js";
import {
  ve
} from "./chunk-JY2H3NC3.js";
import {
  BuildEnvironment,
  DEFAULT_CLIENT_CONDITIONS,
  DEFAULT_CLIENT_MAIN_FIELDS,
  DEFAULT_EXTERNAL_CONDITIONS,
  DEFAULT_SERVER_CONDITIONS,
  DEFAULT_SERVER_MAIN_FIELDS,
  DevEnvironment,
  VERSION,
  build$1,
  buildErrorMessage,
  createBuilder,
  createFilter,
  createIdResolver,
  createLogger,
  createRunnableDevEnvironment,
  createServer$2,
  createServerHotChannel,
  createServerModuleRunner,
  createServerModuleRunnerTransport,
  defaultAllowedOrigins,
  defineConfig,
  fetchModule,
  formatPostcssSourceMap,
  isCSSRequest,
  isFileLoadingAllowed,
  isFileServingAllowed,
  isRunnableDevEnvironment,
  loadConfigFromFile,
  loadEnv,
  mergeAlias,
  mergeConfig,
  normalizePath,
  optimizeDeps,
  perEnvironmentPlugin,
  perEnvironmentState,
  preprocessCSS,
  preview,
  require_main,
  require_node_util,
  resolveConfig,
  resolveEnvPrefix,
  rollupVersion,
  runnerImport,
  searchForWorkspaceRoot,
  send,
  sortUserPlugins,
  ssrTransform,
  transformWithEsbuild
} from "./chunk-P4ZB3LCK.js";
import {
  require_node_url
} from "./chunk-MYHZVKW7.js";
import {
  require_node_os
} from "./chunk-EXACAG4Z.js";
import {
  parseAst,
  parseAstAsync,
  require_node_perf_hooks
} from "./chunk-R2F3KQRP.js";
import {
  require_node_fs
} from "./chunk-Y27CEZEH.js";
import {
  require_node_module
} from "./chunk-5GUNUIXR.js";
import {
  require_node_path
} from "./chunk-PTHJ7W2W.js";
import {
  require_promises
} from "./chunk-2F4QH2CI.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-UN725CXD.js";

// browser-external:node:console
var require_node_console = __commonJS({
  "browser-external:node:console"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:console" has been externalized for browser compatibility. Cannot access "node:console.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:stream
var require_node_stream = __commonJS({
  "browser-external:node:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:stream" has been externalized for browser compatibility. Cannot access "node:stream.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/vitest/dist/chunks/index.CcRZ6fUh.js
var import_node_fs = __toESM(require_node_fs(), 1);
var import_promises = __toESM(require_promises(), 1);
var import_node_perf_hooks = __toESM(require_node_perf_hooks(), 1);

// node_modules/@vitest/pretty-format/dist/index.js
function _mergeNamespaces(n2, m2) {
  m2.forEach(function(e) {
    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n2)) {
        var d2 = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n2, k, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  });
  return Object.freeze(n2);
}
function getKeysOfEnumerableProperties(object2, compareKeys) {
  const rawKeys = Object.keys(object2);
  const keys2 = compareKeys === null ? rawKeys : rawKeys.sort(compareKeys);
  if (Object.getOwnPropertySymbols) {
    for (const symbol of Object.getOwnPropertySymbols(object2)) {
      if (Object.getOwnPropertyDescriptor(object2, symbol).enumerable) {
        keys2.push(symbol);
      }
    }
  }
  return keys2;
}
function printIteratorEntries(iterator, config, indentation, depth, refs, printer2, separator2 = ": ") {
  let result = "";
  let width = 0;
  let current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    while (!current.done) {
      result += indentationNext;
      if (width++ === config.maxWidth) {
        result += "…";
        break;
      }
      const name = printer2(current.value[0], config, indentationNext, depth, refs);
      const value = printer2(current.value[1], config, indentationNext, depth, refs);
      result += name + separator2 + value;
      current = iterator.next();
      if (!current.done) {
        result += `,${config.spacingInner}`;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
function printIteratorValues(iterator, config, indentation, depth, refs, printer2) {
  let result = "";
  let width = 0;
  let current = iterator.next();
  if (!current.done) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    while (!current.done) {
      result += indentationNext;
      if (width++ === config.maxWidth) {
        result += "…";
        break;
      }
      result += printer2(current.value, config, indentationNext, depth, refs);
      current = iterator.next();
      if (!current.done) {
        result += `,${config.spacingInner}`;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
function printListItems(list, config, indentation, depth, refs, printer2) {
  let result = "";
  list = list instanceof ArrayBuffer ? new DataView(list) : list;
  const isDataView = (l2) => l2 instanceof DataView;
  const length = isDataView(list) ? list.byteLength : list.length;
  if (length > 0) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    for (let i2 = 0; i2 < length; i2++) {
      result += indentationNext;
      if (i2 === config.maxWidth) {
        result += "…";
        break;
      }
      if (isDataView(list) || i2 in list) {
        result += printer2(isDataView(list) ? list.getInt8(i2) : list[i2], config, indentationNext, depth, refs);
      }
      if (i2 < length - 1) {
        result += `,${config.spacingInner}`;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
function printObjectProperties(val, config, indentation, depth, refs, printer2) {
  let result = "";
  const keys2 = getKeysOfEnumerableProperties(val, config.compareKeys);
  if (keys2.length > 0) {
    result += config.spacingOuter;
    const indentationNext = indentation + config.indent;
    for (let i2 = 0; i2 < keys2.length; i2++) {
      const key = keys2[i2];
      const name = printer2(key, config, indentationNext, depth, refs);
      const value = printer2(val[key], config, indentationNext, depth, refs);
      result += `${indentationNext + name}: ${value}`;
      if (i2 < keys2.length - 1) {
        result += `,${config.spacingInner}`;
      } else if (!config.min) {
        result += ",";
      }
    }
    result += config.spacingOuter + indentation;
  }
  return result;
}
var asymmetricMatcher = typeof Symbol === "function" && Symbol.for ? Symbol.for("jest.asymmetricMatcher") : 1267621;
var SPACE$2 = " ";
var serialize$5 = (val, config, indentation, depth, refs, printer2) => {
  const stringedValue = val.toString();
  if (stringedValue === "ArrayContaining" || stringedValue === "ArrayNotContaining") {
    if (++depth > config.maxDepth) {
      return `[${stringedValue}]`;
    }
    return `${stringedValue + SPACE$2}[${printListItems(val.sample, config, indentation, depth, refs, printer2)}]`;
  }
  if (stringedValue === "ObjectContaining" || stringedValue === "ObjectNotContaining") {
    if (++depth > config.maxDepth) {
      return `[${stringedValue}]`;
    }
    return `${stringedValue + SPACE$2}{${printObjectProperties(val.sample, config, indentation, depth, refs, printer2)}}`;
  }
  if (stringedValue === "StringMatching" || stringedValue === "StringNotMatching") {
    return stringedValue + SPACE$2 + printer2(val.sample, config, indentation, depth, refs);
  }
  if (stringedValue === "StringContaining" || stringedValue === "StringNotContaining") {
    return stringedValue + SPACE$2 + printer2(val.sample, config, indentation, depth, refs);
  }
  if (typeof val.toAsymmetricMatcher !== "function") {
    throw new TypeError(`Asymmetric matcher ${val.constructor.name} does not implement toAsymmetricMatcher()`);
  }
  return val.toAsymmetricMatcher();
};
var test$5 = (val) => val && val.$$typeof === asymmetricMatcher;
var plugin$5 = {
  serialize: serialize$5,
  test: test$5
};
var SPACE$1 = " ";
var OBJECT_NAMES = /* @__PURE__ */ new Set(["DOMStringMap", "NamedNodeMap"]);
var ARRAY_REGEXP = /^(?:HTML\w*Collection|NodeList)$/;
function testName(name) {
  return OBJECT_NAMES.has(name) || ARRAY_REGEXP.test(name);
}
var test$4 = (val) => val && val.constructor && !!val.constructor.name && testName(val.constructor.name);
function isNamedNodeMap(collection) {
  return collection.constructor.name === "NamedNodeMap";
}
var serialize$4 = (collection, config, indentation, depth, refs, printer2) => {
  const name = collection.constructor.name;
  if (++depth > config.maxDepth) {
    return `[${name}]`;
  }
  return (config.min ? "" : name + SPACE$1) + (OBJECT_NAMES.has(name) ? `{${printObjectProperties(isNamedNodeMap(collection) ? [...collection].reduce((props, attribute) => {
    props[attribute.name] = attribute.value;
    return props;
  }, {}) : { ...collection }, config, indentation, depth, refs, printer2)}}` : `[${printListItems([...collection], config, indentation, depth, refs, printer2)}]`);
};
var plugin$4 = {
  serialize: serialize$4,
  test: test$4
};
function escapeHTML(str) {
  return str.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
}
function printProps(keys2, props, config, indentation, depth, refs, printer2) {
  const indentationNext = indentation + config.indent;
  const colors = config.colors;
  return keys2.map((key) => {
    const value = props[key];
    let printed = printer2(value, config, indentationNext, depth, refs);
    if (typeof value !== "string") {
      if (printed.includes("\n")) {
        printed = config.spacingOuter + indentationNext + printed + config.spacingOuter + indentation;
      }
      printed = `{${printed}}`;
    }
    return `${config.spacingInner + indentation + colors.prop.open + key + colors.prop.close}=${colors.value.open}${printed}${colors.value.close}`;
  }).join("");
}
function printChildren(children, config, indentation, depth, refs, printer2) {
  return children.map((child) => config.spacingOuter + indentation + (typeof child === "string" ? printText(child, config) : printer2(child, config, indentation, depth, refs))).join("");
}
function printShadowRoot(children, config, indentation, depth, refs, printer2) {
  if (config.printShadowRoot === false) {
    return "";
  }
  return [`${config.spacingOuter + indentation}#shadow-root`, printChildren(children, config, indentation + config.indent, depth, refs, printer2)].join("");
}
function printText(text, config) {
  const contentColor = config.colors.content;
  return contentColor.open + escapeHTML(text) + contentColor.close;
}
function printComment(comment, config) {
  const commentColor = config.colors.comment;
  return `${commentColor.open}<!--${escapeHTML(comment)}-->${commentColor.close}`;
}
function printElement(type, printedProps, printedChildren, config, indentation) {
  const tagColor = config.colors.tag;
  return `${tagColor.open}<${type}${printedProps && tagColor.close + printedProps + config.spacingOuter + indentation + tagColor.open}${printedChildren ? `>${tagColor.close}${printedChildren}${config.spacingOuter}${indentation}${tagColor.open}</${type}` : `${printedProps && !config.min ? "" : " "}/`}>${tagColor.close}`;
}
function printElementAsLeaf(type, config) {
  const tagColor = config.colors.tag;
  return `${tagColor.open}<${type}${tagColor.close} …${tagColor.open} />${tagColor.close}`;
}
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var FRAGMENT_NODE = 11;
var ELEMENT_REGEXP = /^(?:(?:HTML|SVG)\w*)?Element$/;
function testHasAttribute(val) {
  try {
    return typeof val.hasAttribute === "function" && val.hasAttribute("is");
  } catch {
    return false;
  }
}
function testNode(val) {
  const constructorName = val.constructor.name;
  const { nodeType, tagName } = val;
  const isCustomElement = typeof tagName === "string" && tagName.includes("-") || testHasAttribute(val);
  return nodeType === ELEMENT_NODE && (ELEMENT_REGEXP.test(constructorName) || isCustomElement) || nodeType === TEXT_NODE && constructorName === "Text" || nodeType === COMMENT_NODE && constructorName === "Comment" || nodeType === FRAGMENT_NODE && constructorName === "DocumentFragment";
}
var test$3 = (val) => {
  var _a10;
  return ((_a10 = val == null ? void 0 : val.constructor) == null ? void 0 : _a10.name) && testNode(val);
};
function nodeIsText(node) {
  return node.nodeType === TEXT_NODE;
}
function nodeIsComment(node) {
  return node.nodeType === COMMENT_NODE;
}
function nodeIsFragment(node) {
  return node.nodeType === FRAGMENT_NODE;
}
var serialize$3 = (node, config, indentation, depth, refs, printer2) => {
  if (nodeIsText(node)) {
    return printText(node.data, config);
  }
  if (nodeIsComment(node)) {
    return printComment(node.data, config);
  }
  const type = nodeIsFragment(node) ? "DocumentFragment" : node.tagName.toLowerCase();
  if (++depth > config.maxDepth) {
    return printElementAsLeaf(type, config);
  }
  return printElement(type, printProps(nodeIsFragment(node) ? [] : Array.from(node.attributes, (attr) => attr.name).sort(), nodeIsFragment(node) ? {} : [...node.attributes].reduce((props, attribute) => {
    props[attribute.name] = attribute.value;
    return props;
  }, {}), config, indentation + config.indent, depth, refs, printer2), (nodeIsFragment(node) || !node.shadowRoot ? "" : printShadowRoot(Array.prototype.slice.call(node.shadowRoot.children), config, indentation + config.indent, depth, refs, printer2)) + printChildren(Array.prototype.slice.call(node.childNodes || node.children), config, indentation + config.indent, depth, refs, printer2), config, indentation);
};
var plugin$3 = {
  serialize: serialize$3,
  test: test$3
};
var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
var IS_RECORD_SENTINEL = "@@__IMMUTABLE_RECORD__@@";
var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
var getImmutableName = (name) => `Immutable.${name}`;
var printAsLeaf = (name) => `[${name}]`;
var SPACE = " ";
var LAZY = "…";
function printImmutableEntries(val, config, indentation, depth, refs, printer2, type) {
  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}{${printIteratorEntries(val.entries(), config, indentation, depth, refs, printer2)}}`;
}
function getRecordEntries(val) {
  let i2 = 0;
  return { next() {
    if (i2 < val._keys.length) {
      const key = val._keys[i2++];
      return {
        done: false,
        value: [key, val.get(key)]
      };
    }
    return {
      done: true,
      value: void 0
    };
  } };
}
function printImmutableRecord(val, config, indentation, depth, refs, printer2) {
  const name = getImmutableName(val._name || "Record");
  return ++depth > config.maxDepth ? printAsLeaf(name) : `${name + SPACE}{${printIteratorEntries(getRecordEntries(val), config, indentation, depth, refs, printer2)}}`;
}
function printImmutableSeq(val, config, indentation, depth, refs, printer2) {
  const name = getImmutableName("Seq");
  if (++depth > config.maxDepth) {
    return printAsLeaf(name);
  }
  if (val[IS_KEYED_SENTINEL]) {
    return `${name + SPACE}{${val._iter || val._object ? printIteratorEntries(val.entries(), config, indentation, depth, refs, printer2) : LAZY}}`;
  }
  return `${name + SPACE}[${val._iter || val._array || val._collection || val._iterable ? printIteratorValues(val.values(), config, indentation, depth, refs, printer2) : LAZY}]`;
}
function printImmutableValues(val, config, indentation, depth, refs, printer2, type) {
  return ++depth > config.maxDepth ? printAsLeaf(getImmutableName(type)) : `${getImmutableName(type) + SPACE}[${printIteratorValues(val.values(), config, indentation, depth, refs, printer2)}]`;
}
var serialize$2 = (val, config, indentation, depth, refs, printer2) => {
  if (val[IS_MAP_SENTINEL]) {
    return printImmutableEntries(val, config, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedMap" : "Map");
  }
  if (val[IS_LIST_SENTINEL]) {
    return printImmutableValues(val, config, indentation, depth, refs, printer2, "List");
  }
  if (val[IS_SET_SENTINEL]) {
    return printImmutableValues(val, config, indentation, depth, refs, printer2, val[IS_ORDERED_SENTINEL] ? "OrderedSet" : "Set");
  }
  if (val[IS_STACK_SENTINEL]) {
    return printImmutableValues(val, config, indentation, depth, refs, printer2, "Stack");
  }
  if (val[IS_SEQ_SENTINEL]) {
    return printImmutableSeq(val, config, indentation, depth, refs, printer2);
  }
  return printImmutableRecord(val, config, indentation, depth, refs, printer2);
};
var test$2 = (val) => val && (val[IS_ITERABLE_SENTINEL] === true || val[IS_RECORD_SENTINEL] === true);
var plugin$2 = {
  serialize: serialize$2,
  test: test$2
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var reactIs$1 = { exports: {} };
var reactIs_production = {};
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object2) {
    if ("object" === typeof object2 && null !== object2) {
      var $$typeof = object2.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object2 = object2.type, object2) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object2;
            default:
              switch (object2 = object2 && object2.$$typeof, object2) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object2;
                case REACT_CONSUMER_TYPE:
                  return object2;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function(object2) {
    return typeOf(object2) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function(object2) {
    return typeOf(object2) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function(object2) {
    return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function(object2) {
    return typeOf(object2) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function(object2) {
    return typeOf(object2) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function(object2) {
    return typeOf(object2) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function(object2) {
    return typeOf(object2) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function(object2) {
    return typeOf(object2) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function(object2) {
    return typeOf(object2) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function(object2) {
    return typeOf(object2) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function(object2) {
    return typeOf(object2) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function(object2) {
    return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function(type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  {
    reactIs$1.exports = requireReactIs_production();
  }
  return reactIs$1.exports;
}
var reactIsExports$1 = requireReactIs$1();
var index$1 = getDefaultExportFromCjs(reactIsExports$1);
var ReactIs19 = _mergeNamespaces({
  __proto__: null,
  default: index$1
}, [reactIsExports$1]);
var reactIs = { exports: {} };
var reactIs_production_min = {};
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b2 = Symbol.for("react.element"), c2 = Symbol.for("react.portal"), d2 = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f2 = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l2 = Symbol.for("react.forward_ref"), m2 = Symbol.for("react.suspense"), n2 = Symbol.for("react.suspense_list"), p2 = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t2 = Symbol.for("react.offscreen"), u2;
  u2 = Symbol.for("react.module.reference");
  function v2(a2) {
    if ("object" === typeof a2 && null !== a2) {
      var r2 = a2.$$typeof;
      switch (r2) {
        case b2:
          switch (a2 = a2.type, a2) {
            case d2:
            case f2:
            case e:
            case m2:
            case n2:
              return a2;
            default:
              switch (a2 = a2 && a2.$$typeof, a2) {
                case k:
                case h:
                case l2:
                case q:
                case p2:
                case g:
                  return a2;
                default:
                  return r2;
              }
          }
        case c2:
          return r2;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h;
  reactIs_production_min.ContextProvider = g;
  reactIs_production_min.Element = b2;
  reactIs_production_min.ForwardRef = l2;
  reactIs_production_min.Fragment = d2;
  reactIs_production_min.Lazy = q;
  reactIs_production_min.Memo = p2;
  reactIs_production_min.Portal = c2;
  reactIs_production_min.Profiler = f2;
  reactIs_production_min.StrictMode = e;
  reactIs_production_min.Suspense = m2;
  reactIs_production_min.SuspenseList = n2;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a2) {
    return v2(a2) === h;
  };
  reactIs_production_min.isContextProvider = function(a2) {
    return v2(a2) === g;
  };
  reactIs_production_min.isElement = function(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === b2;
  };
  reactIs_production_min.isForwardRef = function(a2) {
    return v2(a2) === l2;
  };
  reactIs_production_min.isFragment = function(a2) {
    return v2(a2) === d2;
  };
  reactIs_production_min.isLazy = function(a2) {
    return v2(a2) === q;
  };
  reactIs_production_min.isMemo = function(a2) {
    return v2(a2) === p2;
  };
  reactIs_production_min.isPortal = function(a2) {
    return v2(a2) === c2;
  };
  reactIs_production_min.isProfiler = function(a2) {
    return v2(a2) === f2;
  };
  reactIs_production_min.isStrictMode = function(a2) {
    return v2(a2) === e;
  };
  reactIs_production_min.isSuspense = function(a2) {
    return v2(a2) === m2;
  };
  reactIs_production_min.isSuspenseList = function(a2) {
    return v2(a2) === n2;
  };
  reactIs_production_min.isValidElementType = function(a2) {
    return "string" === typeof a2 || "function" === typeof a2 || a2 === d2 || a2 === f2 || a2 === e || a2 === m2 || a2 === n2 || a2 === t2 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p2 || a2.$$typeof === g || a2.$$typeof === h || a2.$$typeof === l2 || a2.$$typeof === u2 || void 0 !== a2.getModuleId) ? true : false;
  };
  reactIs_production_min.typeOf = v2;
  return reactIs_production_min;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = requireReactIs_production_min();
  }
  return reactIs.exports;
}
var reactIsExports = requireReactIs();
var index = getDefaultExportFromCjs(reactIsExports);
var ReactIs18 = _mergeNamespaces({
  __proto__: null,
  default: index
}, [reactIsExports]);
var reactIsMethods = [
  "isAsyncMode",
  "isConcurrentMode",
  "isContextConsumer",
  "isContextProvider",
  "isElement",
  "isForwardRef",
  "isFragment",
  "isLazy",
  "isMemo",
  "isPortal",
  "isProfiler",
  "isStrictMode",
  "isSuspense",
  "isSuspenseList",
  "isValidElementType"
];
var ReactIs = Object.fromEntries(reactIsMethods.map((m2) => [m2, (v2) => ReactIs18[m2](v2) || ReactIs19[m2](v2)]));
function getChildren(arg, children = []) {
  if (Array.isArray(arg)) {
    for (const item of arg) {
      getChildren(item, children);
    }
  } else if (arg != null && arg !== false && arg !== "") {
    children.push(arg);
  }
  return children;
}
function getType(element) {
  const type = element.type;
  if (typeof type === "string") {
    return type;
  }
  if (typeof type === "function") {
    return type.displayName || type.name || "Unknown";
  }
  if (ReactIs.isFragment(element)) {
    return "React.Fragment";
  }
  if (ReactIs.isSuspense(element)) {
    return "React.Suspense";
  }
  if (typeof type === "object" && type !== null) {
    if (ReactIs.isContextProvider(element)) {
      return "Context.Provider";
    }
    if (ReactIs.isContextConsumer(element)) {
      return "Context.Consumer";
    }
    if (ReactIs.isForwardRef(element)) {
      if (type.displayName) {
        return type.displayName;
      }
      const functionName = type.render.displayName || type.render.name || "";
      return functionName === "" ? "ForwardRef" : `ForwardRef(${functionName})`;
    }
    if (ReactIs.isMemo(element)) {
      const functionName = type.displayName || type.type.displayName || type.type.name || "";
      return functionName === "" ? "Memo" : `Memo(${functionName})`;
    }
  }
  return "UNDEFINED";
}
function getPropKeys$1(element) {
  const { props } = element;
  return Object.keys(props).filter((key) => key !== "children" && props[key] !== void 0).sort();
}
var serialize$1 = (element, config, indentation, depth, refs, printer2) => ++depth > config.maxDepth ? printElementAsLeaf(getType(element), config) : printElement(getType(element), printProps(getPropKeys$1(element), element.props, config, indentation + config.indent, depth, refs, printer2), printChildren(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer2), config, indentation);
var test$1 = (val) => val != null && ReactIs.isElement(val);
var plugin$1 = {
  serialize: serialize$1,
  test: test$1
};
var testSymbol = typeof Symbol === "function" && Symbol.for ? Symbol.for("react.test.json") : 245830487;
function getPropKeys(object2) {
  const { props } = object2;
  return props ? Object.keys(props).filter((key) => props[key] !== void 0).sort() : [];
}
var serialize = (object2, config, indentation, depth, refs, printer2) => ++depth > config.maxDepth ? printElementAsLeaf(object2.type, config) : printElement(object2.type, object2.props ? printProps(getPropKeys(object2), object2.props, config, indentation + config.indent, depth, refs, printer2) : "", object2.children ? printChildren(object2.children, config, indentation + config.indent, depth, refs, printer2) : "", config, indentation);
var test = (val) => val && val.$$typeof === testSymbol;
var plugin = {
  serialize,
  test
};
var toString = Object.prototype.toString;
var toISOString = Date.prototype.toISOString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
function getConstructorName(val) {
  return typeof val.constructor === "function" && val.constructor.name || "Object";
}
function isWindow(val) {
  return typeof window !== "undefined" && val === window;
}
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
var NEWLINE_REGEXP = /\n/g;
var PrettyFormatPluginError = class extends Error {
  constructor(message, stack) {
    super(message);
    this.stack = stack;
    this.name = this.constructor.name;
  }
};
function isToStringedArrayType(toStringed) {
  return toStringed === "[object Array]" || toStringed === "[object ArrayBuffer]" || toStringed === "[object DataView]" || toStringed === "[object Float32Array]" || toStringed === "[object Float64Array]" || toStringed === "[object Int8Array]" || toStringed === "[object Int16Array]" || toStringed === "[object Int32Array]" || toStringed === "[object Uint8Array]" || toStringed === "[object Uint8ClampedArray]" || toStringed === "[object Uint16Array]" || toStringed === "[object Uint32Array]";
}
function printNumber(val) {
  return Object.is(val, -0) ? "-0" : String(val);
}
function printBigInt(val) {
  return String(`${val}n`);
}
function printFunction(val, printFunctionName) {
  if (!printFunctionName) {
    return "[Function]";
  }
  return `[Function ${val.name || "anonymous"}]`;
}
function printSymbol(val) {
  return String(val).replace(SYMBOL_REGEXP, "Symbol($1)");
}
function printError(val) {
  return `[${errorToString.call(val)}]`;
}
function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
  if (val === true || val === false) {
    return `${val}`;
  }
  if (val === void 0) {
    return "undefined";
  }
  if (val === null) {
    return "null";
  }
  const typeOf = typeof val;
  if (typeOf === "number") {
    return printNumber(val);
  }
  if (typeOf === "bigint") {
    return printBigInt(val);
  }
  if (typeOf === "string") {
    if (escapeString) {
      return `"${val.replaceAll(/"|\\/g, "\\$&")}"`;
    }
    return `"${val}"`;
  }
  if (typeOf === "function") {
    return printFunction(val, printFunctionName);
  }
  if (typeOf === "symbol") {
    return printSymbol(val);
  }
  const toStringed = toString.call(val);
  if (toStringed === "[object WeakMap]") {
    return "WeakMap {}";
  }
  if (toStringed === "[object WeakSet]") {
    return "WeakSet {}";
  }
  if (toStringed === "[object Function]" || toStringed === "[object GeneratorFunction]") {
    return printFunction(val, printFunctionName);
  }
  if (toStringed === "[object Symbol]") {
    return printSymbol(val);
  }
  if (toStringed === "[object Date]") {
    return Number.isNaN(+val) ? "Date { NaN }" : toISOString.call(val);
  }
  if (toStringed === "[object Error]") {
    return printError(val);
  }
  if (toStringed === "[object RegExp]") {
    if (escapeRegex) {
      return regExpToString.call(val).replaceAll(/[$()*+.?[\\\]^{|}]/g, "\\$&");
    }
    return regExpToString.call(val);
  }
  if (val instanceof Error) {
    return printError(val);
  }
  return null;
}
function printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON) {
  if (refs.includes(val)) {
    return "[Circular]";
  }
  refs = [...refs];
  refs.push(val);
  const hitMaxDepth = ++depth > config.maxDepth;
  const min = config.min;
  if (config.callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === "function" && !hasCalledToJSON) {
    return printer(val.toJSON(), config, indentation, depth, refs, true);
  }
  const toStringed = toString.call(val);
  if (toStringed === "[object Arguments]") {
    return hitMaxDepth ? "[Arguments]" : `${min ? "" : "Arguments "}[${printListItems(val, config, indentation, depth, refs, printer)}]`;
  }
  if (isToStringedArrayType(toStringed)) {
    return hitMaxDepth ? `[${val.constructor.name}]` : `${min ? "" : !config.printBasicPrototype && val.constructor.name === "Array" ? "" : `${val.constructor.name} `}[${printListItems(val, config, indentation, depth, refs, printer)}]`;
  }
  if (toStringed === "[object Map]") {
    return hitMaxDepth ? "[Map]" : `Map {${printIteratorEntries(val.entries(), config, indentation, depth, refs, printer, " => ")}}`;
  }
  if (toStringed === "[object Set]") {
    return hitMaxDepth ? "[Set]" : `Set {${printIteratorValues(val.values(), config, indentation, depth, refs, printer)}}`;
  }
  return hitMaxDepth || isWindow(val) ? `[${getConstructorName(val)}]` : `${min ? "" : !config.printBasicPrototype && getConstructorName(val) === "Object" ? "" : `${getConstructorName(val)} `}{${printObjectProperties(val, config, indentation, depth, refs, printer)}}`;
}
var ErrorPlugin = {
  test: (val) => val && val instanceof Error,
  serialize(val, config, indentation, depth, refs, printer2) {
    if (refs.includes(val)) {
      return "[Circular]";
    }
    refs = [...refs, val];
    const hitMaxDepth = ++depth > config.maxDepth;
    const { message, cause, ...rest } = val;
    const entries = {
      message,
      ...typeof cause !== "undefined" ? { cause } : {},
      ...val instanceof AggregateError ? { errors: val.errors } : {},
      ...rest
    };
    const name = val.name !== "Error" ? val.name : getConstructorName(val);
    return hitMaxDepth ? `[${name}]` : `${name} {${printIteratorEntries(Object.entries(entries).values(), config, indentation, depth, refs, printer2)}}`;
  }
};
function isNewPlugin(plugin2) {
  return plugin2.serialize != null;
}
function printPlugin(plugin2, val, config, indentation, depth, refs) {
  let printed;
  try {
    printed = isNewPlugin(plugin2) ? plugin2.serialize(val, config, indentation, depth, refs, printer) : plugin2.print(val, (valChild) => printer(valChild, config, indentation, depth, refs), (str) => {
      const indentationNext = indentation + config.indent;
      return indentationNext + str.replaceAll(NEWLINE_REGEXP, `
${indentationNext}`);
    }, {
      edgeSpacing: config.spacingOuter,
      min: config.min,
      spacing: config.spacingInner
    }, config.colors);
  } catch (error) {
    throw new PrettyFormatPluginError(error.message, error.stack);
  }
  if (typeof printed !== "string") {
    throw new TypeError(`pretty-format: Plugin must return type "string" but instead returned "${typeof printed}".`);
  }
  return printed;
}
function findPlugin(plugins2, val) {
  for (const plugin2 of plugins2) {
    try {
      if (plugin2.test(val)) {
        return plugin2;
      }
    } catch (error) {
      throw new PrettyFormatPluginError(error.message, error.stack);
    }
  }
  return null;
}
function printer(val, config, indentation, depth, refs, hasCalledToJSON) {
  const plugin2 = findPlugin(config.plugins, val);
  if (plugin2 !== null) {
    return printPlugin(plugin2, val, config, indentation, depth, refs);
  }
  const basicResult = printBasicValue(val, config.printFunctionName, config.escapeRegex, config.escapeString);
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, config, indentation, depth, refs, hasCalledToJSON);
}
var DEFAULT_THEME = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
};
var DEFAULT_THEME_KEYS = Object.keys(DEFAULT_THEME);
var DEFAULT_OPTIONS = {
  callToJSON: true,
  compareKeys: void 0,
  escapeRegex: false,
  escapeString: true,
  highlight: false,
  indent: 2,
  maxDepth: Number.POSITIVE_INFINITY,
  maxWidth: Number.POSITIVE_INFINITY,
  min: false,
  plugins: [],
  printBasicPrototype: true,
  printFunctionName: true,
  printShadowRoot: true,
  theme: DEFAULT_THEME
};
function validateOptions(options) {
  for (const key of Object.keys(options)) {
    if (!Object.hasOwn(DEFAULT_OPTIONS, key)) {
      throw new Error(`pretty-format: Unknown option "${key}".`);
    }
  }
  if (options.min && options.indent !== void 0 && options.indent !== 0) {
    throw new Error('pretty-format: Options "min" and "indent" cannot be used together.');
  }
}
function getColorsHighlight() {
  return DEFAULT_THEME_KEYS.reduce((colors, key) => {
    const value = DEFAULT_THEME[key];
    const color = value && C[value];
    if (color && typeof color.close === "string" && typeof color.open === "string") {
      colors[key] = color;
    } else {
      throw new Error(`pretty-format: Option "theme" has a key "${key}" whose value "${value}" is undefined in ansi-styles.`);
    }
    return colors;
  }, /* @__PURE__ */ Object.create(null));
}
function getColorsEmpty() {
  return DEFAULT_THEME_KEYS.reduce((colors, key) => {
    colors[key] = {
      close: "",
      open: ""
    };
    return colors;
  }, /* @__PURE__ */ Object.create(null));
}
function getPrintFunctionName(options) {
  return (options == null ? void 0 : options.printFunctionName) ?? DEFAULT_OPTIONS.printFunctionName;
}
function getEscapeRegex(options) {
  return (options == null ? void 0 : options.escapeRegex) ?? DEFAULT_OPTIONS.escapeRegex;
}
function getEscapeString(options) {
  return (options == null ? void 0 : options.escapeString) ?? DEFAULT_OPTIONS.escapeString;
}
function getConfig(options) {
  return {
    callToJSON: (options == null ? void 0 : options.callToJSON) ?? DEFAULT_OPTIONS.callToJSON,
    colors: (options == null ? void 0 : options.highlight) ? getColorsHighlight() : getColorsEmpty(),
    compareKeys: typeof (options == null ? void 0 : options.compareKeys) === "function" || (options == null ? void 0 : options.compareKeys) === null ? options.compareKeys : DEFAULT_OPTIONS.compareKeys,
    escapeRegex: getEscapeRegex(options),
    escapeString: getEscapeString(options),
    indent: (options == null ? void 0 : options.min) ? "" : createIndent((options == null ? void 0 : options.indent) ?? DEFAULT_OPTIONS.indent),
    maxDepth: (options == null ? void 0 : options.maxDepth) ?? DEFAULT_OPTIONS.maxDepth,
    maxWidth: (options == null ? void 0 : options.maxWidth) ?? DEFAULT_OPTIONS.maxWidth,
    min: (options == null ? void 0 : options.min) ?? DEFAULT_OPTIONS.min,
    plugins: (options == null ? void 0 : options.plugins) ?? DEFAULT_OPTIONS.plugins,
    printBasicPrototype: (options == null ? void 0 : options.printBasicPrototype) ?? true,
    printFunctionName: getPrintFunctionName(options),
    printShadowRoot: (options == null ? void 0 : options.printShadowRoot) ?? true,
    spacingInner: (options == null ? void 0 : options.min) ? " " : "\n",
    spacingOuter: (options == null ? void 0 : options.min) ? "" : "\n"
  };
}
function createIndent(indent) {
  return Array.from({ length: indent + 1 }).join(" ");
}
function format(val, options) {
  if (options) {
    validateOptions(options);
    if (options.plugins) {
      const plugin2 = findPlugin(options.plugins, val);
      if (plugin2 !== null) {
        return printPlugin(plugin2, val, getConfig(options), "", 0, []);
      }
    }
  }
  const basicResult = printBasicValue(val, getPrintFunctionName(options), getEscapeRegex(options), getEscapeString(options));
  if (basicResult !== null) {
    return basicResult;
  }
  return printComplexValue(val, getConfig(options), "", 0, []);
}
var plugins = {
  AsymmetricMatcher: plugin$5,
  DOMCollection: plugin$4,
  DOMElement: plugin$3,
  Immutable: plugin$2,
  ReactElement: plugin$1,
  ReactTestComponent: plugin,
  Error: ErrorPlugin
};

// node_modules/@vitest/utils/dist/display.js
var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
};
var styles = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
};
var truncator = "…";
function colorise(value, styleType) {
  const color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";
  if (!color) {
    return String(value);
  }
  return `\x1B[${color[0]}m${String(value)}\x1B[${color[1]}m`;
}
function normaliseOptions({
  showHidden = false,
  depth = 2,
  colors = false,
  customInspect = true,
  showProxy = false,
  maxArrayLength = Infinity,
  breakLength = Infinity,
  seen = [],
  // eslint-disable-next-line no-shadow
  truncate: truncate2 = Infinity,
  stylize = String
} = {}, inspect2) {
  const options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate2),
    seen,
    inspect: inspect2,
    stylize
  };
  if (options.colors) {
    options.stylize = colorise;
  }
  return options;
}
function isHighSurrogate(char) {
  return char >= "\uD800" && char <= "\uDBFF";
}
function truncate(string, length, tail = truncator) {
  string = String(string);
  const tailLength = tail.length;
  const stringLength = string.length;
  if (tailLength > length && stringLength > tailLength) {
    return tail;
  }
  if (stringLength > length && stringLength > tailLength) {
    let end = length - tailLength;
    if (end > 0 && isHighSurrogate(string[end - 1])) {
      end = end - 1;
    }
    return `${string.slice(0, end)}${tail}`;
  }
  return string;
}
function inspectList(list, options, inspectItem, separator2 = ", ") {
  inspectItem = inspectItem || options.inspect;
  const size = list.length;
  if (size === 0)
    return "";
  const originalLength = options.truncate;
  let output = "";
  let peek = "";
  let truncated = "";
  for (let i2 = 0; i2 < size; i2 += 1) {
    const last = i2 + 1 === list.length;
    const secondToLast = i2 + 2 === list.length;
    truncated = `${truncator}(${list.length - i2})`;
    const value = list[i2];
    options.truncate = originalLength - output.length - (last ? 0 : separator2.length);
    const string = peek || inspectItem(value, options) + (last ? "" : separator2);
    const nextLength = output.length + string.length;
    const truncatedLength = nextLength + truncated.length;
    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    }
    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    }
    peek = last ? "" : inspectItem(list[i2 + 1], options) + (secondToLast ? "" : separator2);
    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }
    output += string;
    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = `${truncator}(${list.length - i2 - 1})`;
      break;
    }
    truncated = "";
  }
  return `${output}${truncated}`;
}
function quoteComplexKey(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }
  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
function inspectProperty([key, value], options) {
  options.truncate -= 2;
  if (typeof key === "string") {
    key = quoteComplexKey(key);
  } else if (typeof key !== "number") {
    key = `[${options.inspect(key, options)}]`;
  }
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return `${key}: ${value}`;
}
function inspectArray(array, options) {
  const nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return "[]";
  options.truncate -= 4;
  const listContents = inspectList(array, options);
  options.truncate -= listContents.length;
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);
  }
  return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
var getArrayName = (array) => {
  if (typeof Buffer === "function" && array instanceof Buffer) {
    return "Buffer";
  }
  if (array[Symbol.toStringTag]) {
    return array[Symbol.toStringTag];
  }
  return array.constructor.name;
};
function inspectTypedArray(array, options) {
  const name = getArrayName(array);
  options.truncate -= name.length + 4;
  const nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length)
    return `${name}[]`;
  let output = "";
  for (let i2 = 0; i2 < array.length; i2++) {
    const string = `${options.stylize(truncate(array[i2], options.truncate), "number")}${i2 === array.length - 1 ? "" : ", "}`;
    options.truncate -= string.length;
    if (array[i2] !== array.length && options.truncate <= 3) {
      output += `${truncator}(${array.length - array[i2] + 1})`;
      break;
    }
    output += string;
  }
  let propertyContents = "";
  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map((key) => [key, array[key]]), options, inspectProperty);
  }
  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ""} ]`;
}
function inspectDate(dateObject, options) {
  const stringRepresentation = dateObject.toJSON();
  if (stringRepresentation === null) {
    return "Invalid Date";
  }
  const split = stringRepresentation.split("T");
  const date = split[0];
  return options.stylize(`${date}T${truncate(split[1], options.truncate - date.length - 1)}`, "date");
}
function inspectFunction(func, options) {
  const functionType = func[Symbol.toStringTag] || "Function";
  const name = func.name;
  if (!name) {
    return options.stylize(`[${functionType}]`, "special");
  }
  return options.stylize(`[${functionType} ${truncate(name, options.truncate - 11)}]`, "special");
}
function inspectMapEntry([key, value], options) {
  options.truncate -= 4;
  key = options.inspect(key, options);
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return `${key} => ${value}`;
}
function mapToEntries(map) {
  const entries = [];
  map.forEach((value, key) => {
    entries.push([key, value]);
  });
  return entries;
}
function inspectMap(map, options) {
  if (map.size === 0)
    return "Map{}";
  options.truncate -= 7;
  return `Map{ ${inspectList(mapToEntries(map), options, inspectMapEntry)} }`;
}
var isNaN = Number.isNaN || ((i2) => i2 !== i2);
function inspectNumber(number, options) {
  if (isNaN(number)) {
    return options.stylize("NaN", "number");
  }
  if (number === Infinity) {
    return options.stylize("Infinity", "number");
  }
  if (number === -Infinity) {
    return options.stylize("-Infinity", "number");
  }
  if (number === 0) {
    return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
  }
  return options.stylize(truncate(String(number), options.truncate), "number");
}
function inspectBigInt(number, options) {
  let nums = truncate(number.toString(), options.truncate - 1);
  if (nums !== truncator)
    nums += "n";
  return options.stylize(nums, "bigint");
}
function inspectRegExp(value, options) {
  const flags = value.toString().split("/")[2];
  const sourceLength = options.truncate - (2 + flags.length);
  const source = value.source;
  return options.stylize(`/${truncate(source, sourceLength)}/${flags}`, "regexp");
}
function arrayFromSet(set2) {
  const values = [];
  set2.forEach((value) => {
    values.push(value);
  });
  return values;
}
function inspectSet(set2, options) {
  if (set2.size === 0)
    return "Set{}";
  options.truncate -= 7;
  return `Set{ ${inspectList(arrayFromSet(set2), options)} }`;
}
var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
};
var hex = 16;
function escape(char) {
  return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-4)}`;
}
function inspectString(string, options) {
  if (stringEscapeChars.test(string)) {
    string = string.replace(stringEscapeChars, escape);
  }
  return options.stylize(`'${truncate(string, options.truncate - 2)}'`, "string");
}
function inspectSymbol(value) {
  if ("description" in Symbol.prototype) {
    return value.description ? `Symbol(${value.description})` : "Symbol()";
  }
  return value.toString();
}
var getPromiseValue = () => "Promise{…}";
function inspectObject$1(object2, options) {
  const properties = Object.getOwnPropertyNames(object2);
  const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object2) : [];
  if (properties.length === 0 && symbols.length === 0) {
    return "{}";
  }
  options.truncate -= 4;
  options.seen = options.seen || [];
  if (options.seen.includes(object2)) {
    return "[Circular]";
  }
  options.seen.push(object2);
  const propertyContents = inspectList(properties.map((key) => [key, object2[key]]), options, inspectProperty);
  const symbolContents = inspectList(symbols.map((key) => [key, object2[key]]), options, inspectProperty);
  options.seen.pop();
  let sep = "";
  if (propertyContents && symbolContents) {
    sep = ", ";
  }
  return `{ ${propertyContents}${sep}${symbolContents} }`;
}
var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value, options) {
  let name = "";
  if (toStringTag && toStringTag in value) {
    name = value[toStringTag];
  }
  name = name || value.constructor.name;
  if (!name || name === "_class") {
    name = "<Anonymous Class>";
  }
  options.truncate -= name.length;
  return `${name}${inspectObject$1(value, options)}`;
}
function inspectArguments(args, options) {
  if (args.length === 0)
    return "Arguments[]";
  options.truncate -= 13;
  return `Arguments[ ${inspectList(args, options)} ]`;
}
var errorKeys = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function inspectObject(error, options) {
  const properties = Object.getOwnPropertyNames(error).filter((key) => errorKeys.indexOf(key) === -1);
  const name = error.name;
  options.truncate -= name.length;
  let message = "";
  if (typeof error.message === "string") {
    message = truncate(error.message, options.truncate);
  } else {
    properties.unshift("message");
  }
  message = message ? `: ${message}` : "";
  options.truncate -= message.length + 5;
  options.seen = options.seen || [];
  if (options.seen.includes(error)) {
    return "[Circular]";
  }
  options.seen.push(error);
  const propertyContents = inspectList(properties.map((key) => [key, error[key]]), options, inspectProperty);
  return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ""}`;
}
function inspectAttribute([key, value], options) {
  options.truncate -= 3;
  if (!value) {
    return `${options.stylize(String(key), "yellow")}`;
  }
  return `${options.stylize(String(key), "yellow")}=${options.stylize(`"${value}"`, "string")}`;
}
function inspectNodeCollection(collection, options) {
  return inspectList(collection, options, inspectNode, "\n");
}
function inspectNode(node, options) {
  switch (node.nodeType) {
    case 1:
      return inspectHTML(node, options);
    case 3:
      return options.inspect(node.data, options);
    default:
      return options.inspect(node, options);
  }
}
function inspectHTML(element, options) {
  const properties = element.getAttributeNames();
  const name = element.tagName.toLowerCase();
  const head = options.stylize(`<${name}`, "special");
  const headClose = options.stylize(`>`, "special");
  const tail = options.stylize(`</${name}>`, "special");
  options.truncate -= name.length * 2 + 5;
  let propertyContents = "";
  if (properties.length > 0) {
    propertyContents += " ";
    propertyContents += inspectList(properties.map((key) => [key, element.getAttribute(key)]), options, inspectAttribute, " ");
  }
  options.truncate -= propertyContents.length;
  const truncate2 = options.truncate;
  let children = inspectNodeCollection(element.children, options);
  if (children && children.length > truncate2) {
    children = `${truncator}(${element.children.length})`;
  }
  return `${head}${propertyContents}${headClose}${children}${tail}`;
}
var symbolsSupported = typeof Symbol === "function" && typeof Symbol.for === "function";
var chaiInspect = symbolsSupported ? Symbol.for("chai/inspect") : "@@chai/inspect";
var nodeInspect = Symbol.for("nodejs.util.inspect.custom");
var constructorMap = /* @__PURE__ */ new WeakMap();
var stringTagMap = {};
var baseTypesMap = {
  undefined: (value, options) => options.stylize("undefined", "undefined"),
  null: (value, options) => options.stylize("null", "null"),
  boolean: (value, options) => options.stylize(String(value), "boolean"),
  Boolean: (value, options) => options.stylize(String(value), "boolean"),
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  function: inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: getPromiseValue,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (value, options) => options.stylize("WeakSet{…}", "special"),
  WeakMap: (value, options) => options.stylize("WeakMap{…}", "special"),
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: inspectObject,
  HTMLCollection: inspectNodeCollection,
  NodeList: inspectNodeCollection
};
var inspectCustom = (value, options, type, inspectFn) => {
  if (chaiInspect in value && typeof value[chaiInspect] === "function") {
    return value[chaiInspect](options);
  }
  if (nodeInspect in value && typeof value[nodeInspect] === "function") {
    return value[nodeInspect](options.depth, options, inspectFn);
  }
  if ("inspect" in value && typeof value.inspect === "function") {
    return value.inspect(options.depth, options);
  }
  if ("constructor" in value && constructorMap.has(value.constructor)) {
    return constructorMap.get(value.constructor)(value, options);
  }
  if (stringTagMap[type]) {
    return stringTagMap[type](value, options);
  }
  return "";
};
var toString2 = Object.prototype.toString;
function inspect$1(value, opts = {}) {
  const options = normaliseOptions(opts, inspect$1);
  const { customInspect } = options;
  let type = value === null ? "null" : typeof value;
  if (type === "object") {
    type = toString2.call(value).slice(8, -1);
  }
  if (type in baseTypesMap) {
    return baseTypesMap[type](value, options);
  }
  if (customInspect && value) {
    const output = inspectCustom(value, options, type, inspect$1);
    if (output) {
      if (typeof output === "string")
        return output;
      return inspect$1(output, options);
    }
  }
  const proto = value ? Object.getPrototypeOf(value) : false;
  if (proto === Object.prototype || proto === null) {
    return inspectObject$1(value, options);
  }
  if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) {
    return inspectHTML(value, options);
  }
  if ("constructor" in value) {
    if (value.constructor !== Object) {
      return inspectClass(value, options);
    }
    return inspectObject$1(value, options);
  }
  if (value === Object(value)) {
    return inspectObject$1(value, options);
  }
  return options.stylize(String(value), type);
}
var { AsymmetricMatcher, DOMCollection, DOMElement, Immutable, ReactElement, ReactTestComponent } = plugins;
var PLUGINS = [
  ReactTestComponent,
  ReactElement,
  DOMElement,
  DOMCollection,
  Immutable,
  AsymmetricMatcher
];
function stringify(object2, maxDepth = 10, { maxLength, ...options } = {}) {
  const MAX_LENGTH = maxLength ?? 1e4;
  let result;
  try {
    result = format(object2, {
      maxDepth,
      escapeString: false,
      plugins: PLUGINS,
      ...options
    });
  } catch {
    result = format(object2, {
      callToJSON: false,
      maxDepth,
      escapeString: false,
      plugins: PLUGINS,
      ...options
    });
  }
  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object2, Math.floor(Math.min(maxDepth, Number.MAX_SAFE_INTEGER) / 2), {
    maxLength,
    ...options
  }) : result;
}
function inspect(obj, options = {}) {
  if (options.truncate === 0) {
    options.truncate = Number.POSITIVE_INFINITY;
  }
  return inspect$1(obj, options);
}

// node_modules/@vitest/utils/dist/constants.js
var KNOWN_ASSET_TYPES = [
  "apng",
  "bmp",
  "png",
  "jpe?g",
  "jfif",
  "pjpeg",
  "pjp",
  "gif",
  "svg",
  "ico",
  "webp",
  "avif",
  "mp4",
  "webm",
  "ogg",
  "mp3",
  "wav",
  "flac",
  "aac",
  "woff2?",
  "eot",
  "ttf",
  "otf",
  "webmanifest",
  "pdf",
  "txt"
];
var KNOWN_ASSET_RE = new RegExp(`\\.(${KNOWN_ASSET_TYPES.join("|")})$`);
var VALID_ID_PREFIX = `/@id/`;
var NULL_BYTE_PLACEHOLDER = `__x00__`;

// node_modules/@vitest/utils/dist/helpers.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function nanoid(size = 21) {
  let id = "";
  let i2 = size;
  while (i2--) {
    id += urlAlphabet[Math.random() * 64 | 0];
  }
  return id;
}
var RealDate = Date;
function random(seed) {
  const x = Math.sin(seed++) * 1e4;
  return x - Math.floor(x);
}
function shuffle(array, seed = RealDate.now()) {
  let length = array.length;
  while (length) {
    const index2 = Math.floor(random(seed) * length--);
    const previous = array[length];
    array[length] = array[index2];
    array[index2] = previous;
    ++seed;
  }
  return array;
}
function notNullish(v2) {
  return v2 != null;
}
function isPrimitive(value) {
  return value === null || typeof value !== "function" && typeof value !== "object";
}
function slash(path) {
  return path.replace(/\\/g, "/");
}
var postfixRE = /[?#].*$/;
function cleanUrl(url2) {
  return url2.replace(postfixRE, "");
}
var externalRE = /^(?:[a-z]+:)?\/\//;
var isExternalUrl = (url2) => externalRE.test(url2);
function wrapId(id) {
  return id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace("\0", NULL_BYTE_PLACEHOLDER);
}
function unwrapId(id) {
  return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, "\0") : id;
}
function withTrailingSlash(path) {
  if (path.at(-1) !== "/") {
    return `${path}/`;
  }
  return path;
}
function toArray(array) {
  if (array === null || array === void 0) {
    array = [];
  }
  if (Array.isArray(array)) {
    return array;
  }
  return [array];
}
function isFinalObj(obj) {
  return obj === Object.prototype || obj === Function.prototype || obj === RegExp.prototype;
}
function getType2(value) {
  return Object.prototype.toString.apply(value).slice(8, -1);
}
function collectOwnProperties(obj, collector) {
  const collect = typeof collector === "function" ? collector : (key) => collector.add(key);
  Object.getOwnPropertyNames(obj).forEach(collect);
  Object.getOwnPropertySymbols(obj).forEach(collect);
}
function getOwnProperties(obj) {
  const ownProps = /* @__PURE__ */ new Set();
  if (isFinalObj(obj)) {
    return [];
  }
  collectOwnProperties(obj, ownProps);
  return Array.from(ownProps);
}
var defaultCloneOptions = { forceWritable: false };
function deepClone(val, options = defaultCloneOptions) {
  const seen = /* @__PURE__ */ new WeakMap();
  return clone(val, seen, options);
}
function clone(val, seen, options = defaultCloneOptions) {
  let k, out;
  if (seen.has(val)) {
    return seen.get(val);
  }
  if (Array.isArray(val)) {
    out = Array.from({ length: k = val.length });
    seen.set(val, out);
    while (k--) {
      out[k] = clone(val[k], seen, options);
    }
    return out;
  }
  if (Object.prototype.toString.call(val) === "[object Object]") {
    out = Object.create(Object.getPrototypeOf(val));
    seen.set(val, out);
    const props = getOwnProperties(val);
    for (const k2 of props) {
      const descriptor = Object.getOwnPropertyDescriptor(val, k2);
      if (!descriptor) {
        continue;
      }
      const cloned = clone(val[k2], seen, options);
      if (options.forceWritable) {
        Object.defineProperty(out, k2, {
          enumerable: descriptor.enumerable,
          configurable: true,
          writable: true,
          value: cloned
        });
      } else if ("get" in descriptor) {
        Object.defineProperty(out, k2, {
          ...descriptor,
          get() {
            return cloned;
          }
        });
      } else {
        Object.defineProperty(out, k2, {
          ...descriptor,
          value: cloned
        });
      }
    }
    return out;
  }
  return val;
}
function noop() {
}
function createDefer() {
  let resolve5 = null;
  let reject = null;
  const p2 = new Promise((_resolve, _reject) => {
    resolve5 = _resolve;
    reject = _reject;
  });
  p2.resolve = resolve5;
  p2.reject = reject;
  return p2;
}
function toString3(v2) {
  return Object.prototype.toString.call(v2);
}
function isPlainObject(val) {
  return toString3(val) === "[object Object]" && (!val.constructor || val.constructor.name === "Object");
}
function isMergeableObject(item) {
  return isPlainObject(item) && !Array.isArray(item);
}
function deepMerge(target, ...sources) {
  if (!sources.length) {
    return target;
  }
  const source = sources.shift();
  if (source === void 0) {
    return target;
  }
  if (isMergeableObject(target) && isMergeableObject(source)) {
    Object.keys(source).forEach((key) => {
      const _source = source;
      if (isMergeableObject(_source[key])) {
        if (!target[key]) {
          target[key] = {};
        }
        deepMerge(target[key], _source[key]);
      } else {
        target[key] = _source[key];
      }
    });
  }
  return deepMerge(target, ...sources);
}

// node_modules/@vitest/utils/dist/chunk-_commonjsHelpers.js
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}

// node_modules/@vitest/utils/dist/diff.js
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
var Diff = class {
  constructor(op, text) {
    __publicField(this, 0);
    __publicField(this, 1);
    this[0] = op;
    this[1] = text;
  }
};
function diff_commonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
    return 0;
  }
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diff_commonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1)) {
    return 0;
  }
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diff_commonOverlap_(text1, text2) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0) {
    return 0;
  }
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  const text_length = Math.min(text1_length, text2_length);
  if (text1 === text2) {
    return text_length;
  }
  let best = 0;
  let length = 1;
  while (true) {
    const pattern = text1.substring(text_length - length);
    const found3 = text2.indexOf(pattern);
    if (found3 === -1) {
      return best;
    }
    length += found3;
    if (found3 === 0 || text1.substring(text_length - length) === text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
}
function diff_cleanupSemantic(diffs) {
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer2 = 0;
  let length_insertions1 = 0;
  let length_deletions1 = 0;
  let length_insertions2 = 0;
  let length_deletions2 = 0;
  while (pointer2 < diffs.length) {
    if (diffs[pointer2][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer2;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer2][1];
    } else {
      if (diffs[pointer2][0] === DIFF_INSERT) {
        length_insertions2 += diffs[pointer2][1].length;
      } else {
        length_deletions2 += diffs[pointer2][1].length;
      }
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, new Diff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer2 = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer2++;
  }
  if (changes) {
    diff_cleanupMerge(diffs);
  }
  diff_cleanupSemanticLossless(diffs);
  pointer2 = 1;
  while (pointer2 < diffs.length) {
    if (diffs[pointer2 - 1][0] === DIFF_DELETE && diffs[pointer2][0] === DIFF_INSERT) {
      const deletion = diffs[pointer2 - 1][1];
      const insertion = diffs[pointer2][1];
      const overlap_length1 = diff_commonOverlap_(deletion, insertion);
      const overlap_length2 = diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
          diffs[pointer2 - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer2 + 1][1] = insertion.substring(overlap_length1);
          pointer2++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer2, 0, new Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
          diffs[pointer2 - 1][0] = DIFF_INSERT;
          diffs[pointer2 - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer2 + 1][0] = DIFF_DELETE;
          diffs[pointer2 + 1][1] = deletion.substring(overlap_length2);
          pointer2++;
        }
      }
      pointer2++;
    }
    pointer2++;
  }
}
var nonAlphaNumericRegex_ = /[^a-z0-9]/i;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
function diff_cleanupSemanticLossless(diffs) {
  let pointer2 = 1;
  while (pointer2 < diffs.length - 1) {
    if (diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer2 - 1][1];
      let edit = diffs[pointer2][1];
      let equality2 = diffs[pointer2 + 1][1];
      const commonOffset = diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer2 - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer2 - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer2 - 1, 1);
          pointer2--;
        }
        diffs[pointer2][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer2 + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer2 + 1, 1);
          pointer2--;
        }
      }
    }
    pointer2++;
  }
}
function diff_cleanupMerge(diffs) {
  var _diffs$at;
  diffs.push(new Diff(DIFF_EQUAL, ""));
  let pointer2 = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  let commonlength;
  while (pointer2 < diffs.length) {
    switch (diffs[pointer2][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer2][1];
        pointer2++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer2][1];
        pointer2++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer2 - count_delete - count_insert > 0 && diffs[pointer2 - count_delete - count_insert - 1][0] === DIFF_EQUAL) {
                diffs[pointer2 - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                pointer2++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer2][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer2][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer2 -= count_delete + count_insert;
          diffs.splice(pointer2, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer2, 0, new Diff(DIFF_DELETE, text_delete));
            pointer2++;
          }
          if (text_insert.length) {
            diffs.splice(pointer2, 0, new Diff(DIFF_INSERT, text_insert));
            pointer2++;
          }
          pointer2++;
        } else if (pointer2 !== 0 && diffs[pointer2 - 1][0] === DIFF_EQUAL) {
          diffs[pointer2 - 1][1] += diffs[pointer2][1];
          diffs.splice(pointer2, 1);
        } else {
          pointer2++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (((_diffs$at = diffs.at(-1)) === null || _diffs$at === void 0 ? void 0 : _diffs$at[1]) === "") {
    diffs.pop();
  }
  let changes = false;
  pointer2 = 1;
  while (pointer2 < diffs.length - 1) {
    if (diffs[pointer2 - 1][0] === DIFF_EQUAL && diffs[pointer2 + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer2][1].substring(diffs[pointer2][1].length - diffs[pointer2 - 1][1].length) === diffs[pointer2 - 1][1]) {
        diffs[pointer2][1] = diffs[pointer2 - 1][1] + diffs[pointer2][1].substring(0, diffs[pointer2][1].length - diffs[pointer2 - 1][1].length);
        diffs[pointer2 + 1][1] = diffs[pointer2 - 1][1] + diffs[pointer2 + 1][1];
        diffs.splice(pointer2 - 1, 1);
        changes = true;
      } else if (diffs[pointer2][1].substring(0, diffs[pointer2 + 1][1].length) === diffs[pointer2 + 1][1]) {
        diffs[pointer2 - 1][1] += diffs[pointer2 + 1][1];
        diffs[pointer2][1] = diffs[pointer2][1].substring(diffs[pointer2 + 1][1].length) + diffs[pointer2 + 1][1];
        diffs.splice(pointer2 + 1, 1);
        changes = true;
      }
    }
    pointer2++;
  }
  if (changes) {
    diff_cleanupMerge(diffs);
  }
}
function diff_cleanupSemanticScore_(one, two) {
  if (!one || !two) {
    return 6;
  }
  const char1 = one.charAt(one.length - 1);
  const char2 = two.charAt(0);
  const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
  const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
  const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
  const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
  const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
  const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
  const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
  const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
  if (blankLine1 || blankLine2) {
    return 5;
  } else if (lineBreak1 || lineBreak2) {
    return 4;
  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
    return 3;
  } else if (whitespace1 || whitespace2) {
    return 2;
  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
    return 1;
  }
  return 0;
}
var NO_DIFF_MESSAGE = "Compared values have no visual difference.";
var SIMILAR_MESSAGE = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
var build = {};
var hasRequiredBuild;
function requireBuild() {
  if (hasRequiredBuild) return build;
  hasRequiredBuild = 1;
  Object.defineProperty(build, "__esModule", {
    value: true
  });
  build.default = diffSequence;
  const pkg = "diff-sequences";
  const NOT_YET_SET = 0;
  const countCommonItemsF = (aIndex, aEnd, bIndex, bEnd, isCommon) => {
    let nCommon = 0;
    while (aIndex < aEnd && bIndex < bEnd && isCommon(aIndex, bIndex)) {
      aIndex += 1;
      bIndex += 1;
      nCommon += 1;
    }
    return nCommon;
  };
  const countCommonItemsR = (aStart, aIndex, bStart, bIndex, isCommon) => {
    let nCommon = 0;
    while (aStart <= aIndex && bStart <= bIndex && isCommon(aIndex, bIndex)) {
      aIndex -= 1;
      bIndex -= 1;
      nCommon += 1;
    }
    return nCommon;
  };
  const extendPathsF = (d2, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF) => {
    let iF = 0;
    let kF = -d2;
    let aFirst = aIndexesF[iF];
    let aIndexPrev1 = aFirst;
    aIndexesF[iF] += countCommonItemsF(
      aFirst + 1,
      aEnd,
      bF + aFirst - kF + 1,
      bEnd,
      isCommon
    );
    const nF = d2 < iMaxF ? d2 : iMaxF;
    for (iF += 1, kF += 2; iF <= nF; iF += 1, kF += 2) {
      if (iF !== d2 && aIndexPrev1 < aIndexesF[iF]) {
        aFirst = aIndexesF[iF];
      } else {
        aFirst = aIndexPrev1 + 1;
        if (aEnd <= aFirst) {
          return iF - 1;
        }
      }
      aIndexPrev1 = aIndexesF[iF];
      aIndexesF[iF] = aFirst + countCommonItemsF(aFirst + 1, aEnd, bF + aFirst - kF + 1, bEnd, isCommon);
    }
    return iMaxF;
  };
  const extendPathsR = (d2, aStart, bStart, bR, isCommon, aIndexesR, iMaxR) => {
    let iR = 0;
    let kR = d2;
    let aFirst = aIndexesR[iR];
    let aIndexPrev1 = aFirst;
    aIndexesR[iR] -= countCommonItemsR(
      aStart,
      aFirst - 1,
      bStart,
      bR + aFirst - kR - 1,
      isCommon
    );
    const nR = d2 < iMaxR ? d2 : iMaxR;
    for (iR += 1, kR -= 2; iR <= nR; iR += 1, kR -= 2) {
      if (iR !== d2 && aIndexesR[iR] < aIndexPrev1) {
        aFirst = aIndexesR[iR];
      } else {
        aFirst = aIndexPrev1 - 1;
        if (aFirst < aStart) {
          return iR - 1;
        }
      }
      aIndexPrev1 = aIndexesR[iR];
      aIndexesR[iR] = aFirst - countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bR + aFirst - kR - 1,
        isCommon
      );
    }
    return iMaxR;
  };
  const extendOverlappablePathsF = (d2, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    const bF = bStart - aStart;
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength;
    const kMinOverlapF = -baDeltaLength - (d2 - 1);
    const kMaxOverlapF = -baDeltaLength + (d2 - 1);
    let aIndexPrev1 = NOT_YET_SET;
    const nF = d2 < iMaxF ? d2 : iMaxF;
    for (let iF = 0, kF = -d2; iF <= nF; iF += 1, kF += 2) {
      const insert = iF === 0 || iF !== d2 && aIndexPrev1 < aIndexesF[iF];
      const aLastPrev = insert ? aIndexesF[iF] : aIndexPrev1;
      const aFirst = insert ? aLastPrev : aLastPrev + 1;
      const bFirst = bF + aFirst - kF;
      const nCommonF = countCommonItemsF(
        aFirst + 1,
        aEnd,
        bFirst + 1,
        bEnd,
        isCommon
      );
      const aLast = aFirst + nCommonF;
      aIndexPrev1 = aIndexesF[iF];
      aIndexesF[iF] = aLast;
      if (kMinOverlapF <= kF && kF <= kMaxOverlapF) {
        const iR = (d2 - 1 - (kF + baDeltaLength)) / 2;
        if (iR <= iMaxR && aIndexesR[iR] - 1 <= aLast) {
          const bLastPrev = bF + aLastPrev - (insert ? kF + 1 : kF - 1);
          const nCommonR = countCommonItemsR(
            aStart,
            aLastPrev,
            bStart,
            bLastPrev,
            isCommon
          );
          const aIndexPrevFirst = aLastPrev - nCommonR;
          const bIndexPrevFirst = bLastPrev - nCommonR;
          const aEndPreceding = aIndexPrevFirst + 1;
          const bEndPreceding = bIndexPrevFirst + 1;
          division.nChangePreceding = d2 - 1;
          if (d2 - 1 === aEndPreceding + bEndPreceding - aStart - bStart) {
            division.aEndPreceding = aStart;
            division.bEndPreceding = bStart;
          } else {
            division.aEndPreceding = aEndPreceding;
            division.bEndPreceding = bEndPreceding;
          }
          division.nCommonPreceding = nCommonR;
          if (nCommonR !== 0) {
            division.aCommonPreceding = aEndPreceding;
            division.bCommonPreceding = bEndPreceding;
          }
          division.nCommonFollowing = nCommonF;
          if (nCommonF !== 0) {
            division.aCommonFollowing = aFirst + 1;
            division.bCommonFollowing = bFirst + 1;
          }
          const aStartFollowing = aLast + 1;
          const bStartFollowing = bFirst + nCommonF + 1;
          division.nChangeFollowing = d2 - 1;
          if (d2 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
            division.aStartFollowing = aEnd;
            division.bStartFollowing = bEnd;
          } else {
            division.aStartFollowing = aStartFollowing;
            division.bStartFollowing = bStartFollowing;
          }
          return true;
        }
      }
    }
    return false;
  };
  const extendOverlappablePathsR = (d2, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, iMaxF, aIndexesR, iMaxR, division) => {
    const bR = bEnd - aEnd;
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength;
    const kMinOverlapR = baDeltaLength - d2;
    const kMaxOverlapR = baDeltaLength + d2;
    let aIndexPrev1 = NOT_YET_SET;
    const nR = d2 < iMaxR ? d2 : iMaxR;
    for (let iR = 0, kR = d2; iR <= nR; iR += 1, kR -= 2) {
      const insert = iR === 0 || iR !== d2 && aIndexesR[iR] < aIndexPrev1;
      const aLastPrev = insert ? aIndexesR[iR] : aIndexPrev1;
      const aFirst = insert ? aLastPrev : aLastPrev - 1;
      const bFirst = bR + aFirst - kR;
      const nCommonR = countCommonItemsR(
        aStart,
        aFirst - 1,
        bStart,
        bFirst - 1,
        isCommon
      );
      const aLast = aFirst - nCommonR;
      aIndexPrev1 = aIndexesR[iR];
      aIndexesR[iR] = aLast;
      if (kMinOverlapR <= kR && kR <= kMaxOverlapR) {
        const iF = (d2 + (kR - baDeltaLength)) / 2;
        if (iF <= iMaxF && aLast - 1 <= aIndexesF[iF]) {
          const bLast = bFirst - nCommonR;
          division.nChangePreceding = d2;
          if (d2 === aLast + bLast - aStart - bStart) {
            division.aEndPreceding = aStart;
            division.bEndPreceding = bStart;
          } else {
            division.aEndPreceding = aLast;
            division.bEndPreceding = bLast;
          }
          division.nCommonPreceding = nCommonR;
          if (nCommonR !== 0) {
            division.aCommonPreceding = aLast;
            division.bCommonPreceding = bLast;
          }
          division.nChangeFollowing = d2 - 1;
          if (d2 === 1) {
            division.nCommonFollowing = 0;
            division.aStartFollowing = aEnd;
            division.bStartFollowing = bEnd;
          } else {
            const bLastPrev = bR + aLastPrev - (insert ? kR - 1 : kR + 1);
            const nCommonF = countCommonItemsF(
              aLastPrev,
              aEnd,
              bLastPrev,
              bEnd,
              isCommon
            );
            division.nCommonFollowing = nCommonF;
            if (nCommonF !== 0) {
              division.aCommonFollowing = aLastPrev;
              division.bCommonFollowing = bLastPrev;
            }
            const aStartFollowing = aLastPrev + nCommonF;
            const bStartFollowing = bLastPrev + nCommonF;
            if (d2 - 1 === aEnd + bEnd - aStartFollowing - bStartFollowing) {
              division.aStartFollowing = aEnd;
              division.bStartFollowing = bEnd;
            } else {
              division.aStartFollowing = aStartFollowing;
              division.bStartFollowing = bStartFollowing;
            }
          }
          return true;
        }
      }
    }
    return false;
  };
  const divide = (nChange, aStart, aEnd, bStart, bEnd, isCommon, aIndexesF, aIndexesR, division) => {
    const bF = bStart - aStart;
    const bR = bEnd - aEnd;
    const aLength = aEnd - aStart;
    const bLength = bEnd - bStart;
    const baDeltaLength = bLength - aLength;
    let iMaxF = aLength;
    let iMaxR = aLength;
    aIndexesF[0] = aStart - 1;
    aIndexesR[0] = aEnd;
    if (baDeltaLength % 2 === 0) {
      const dMin = (nChange || baDeltaLength) / 2;
      const dMax = (aLength + bLength) / 2;
      for (let d2 = 1; d2 <= dMax; d2 += 1) {
        iMaxF = extendPathsF(d2, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        if (d2 < dMin) {
          iMaxR = extendPathsR(d2, aStart, bStart, bR, isCommon, aIndexesR, iMaxR);
        } else if (
          // If a reverse path overlaps a forward path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsR(
            d2,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        ) {
          return;
        }
      }
    } else {
      const dMin = ((nChange || baDeltaLength) + 1) / 2;
      const dMax = (aLength + bLength + 1) / 2;
      let d2 = 1;
      iMaxF = extendPathsF(d2, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
      for (d2 += 1; d2 <= dMax; d2 += 1) {
        iMaxR = extendPathsR(
          d2 - 1,
          aStart,
          bStart,
          bR,
          isCommon,
          aIndexesR,
          iMaxR
        );
        if (d2 < dMin) {
          iMaxF = extendPathsF(d2, aEnd, bEnd, bF, isCommon, aIndexesF, iMaxF);
        } else if (
          // If a forward path overlaps a reverse path in the same diagonal,
          // return a division of the index intervals at the middle change.
          extendOverlappablePathsF(
            d2,
            aStart,
            aEnd,
            bStart,
            bEnd,
            isCommon,
            aIndexesF,
            iMaxF,
            aIndexesR,
            iMaxR,
            division
          )
        ) {
          return;
        }
      }
    }
    throw new Error(
      `${pkg}: no overlap aStart=${aStart} aEnd=${aEnd} bStart=${bStart} bEnd=${bEnd}`
    );
  };
  const findSubsequences = (nChange, aStart, aEnd, bStart, bEnd, transposed, callbacks, aIndexesF, aIndexesR, division) => {
    if (bEnd - bStart < aEnd - aStart) {
      transposed = !transposed;
      if (transposed && callbacks.length === 1) {
        const { foundSubsequence: foundSubsequence2, isCommon: isCommon2 } = callbacks[0];
        callbacks[1] = {
          foundSubsequence: (nCommon, bCommon, aCommon) => {
            foundSubsequence2(nCommon, aCommon, bCommon);
          },
          isCommon: (bIndex, aIndex) => isCommon2(aIndex, bIndex)
        };
      }
      const tStart = aStart;
      const tEnd = aEnd;
      aStart = bStart;
      aEnd = bEnd;
      bStart = tStart;
      bEnd = tEnd;
    }
    const { foundSubsequence, isCommon } = callbacks[transposed ? 1 : 0];
    divide(
      nChange,
      aStart,
      aEnd,
      bStart,
      bEnd,
      isCommon,
      aIndexesF,
      aIndexesR,
      division
    );
    const {
      nChangePreceding,
      aEndPreceding,
      bEndPreceding,
      nCommonPreceding,
      aCommonPreceding,
      bCommonPreceding,
      nCommonFollowing,
      aCommonFollowing,
      bCommonFollowing,
      nChangeFollowing,
      aStartFollowing,
      bStartFollowing
    } = division;
    if (aStart < aEndPreceding && bStart < bEndPreceding) {
      findSubsequences(
        nChangePreceding,
        aStart,
        aEndPreceding,
        bStart,
        bEndPreceding,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      );
    }
    if (nCommonPreceding !== 0) {
      foundSubsequence(nCommonPreceding, aCommonPreceding, bCommonPreceding);
    }
    if (nCommonFollowing !== 0) {
      foundSubsequence(nCommonFollowing, aCommonFollowing, bCommonFollowing);
    }
    if (aStartFollowing < aEnd && bStartFollowing < bEnd) {
      findSubsequences(
        nChangeFollowing,
        aStartFollowing,
        aEnd,
        bStartFollowing,
        bEnd,
        transposed,
        callbacks,
        aIndexesF,
        aIndexesR,
        division
      );
    }
  };
  const validateLength = (name, arg) => {
    if (typeof arg !== "number") {
      throw new TypeError(`${pkg}: ${name} typeof ${typeof arg} is not a number`);
    }
    if (!Number.isSafeInteger(arg)) {
      throw new RangeError(`${pkg}: ${name} value ${arg} is not a safe integer`);
    }
    if (arg < 0) {
      throw new RangeError(`${pkg}: ${name} value ${arg} is a negative integer`);
    }
  };
  const validateCallback = (name, arg) => {
    const type = typeof arg;
    if (type !== "function") {
      throw new TypeError(`${pkg}: ${name} typeof ${type} is not a function`);
    }
  };
  function diffSequence(aLength, bLength, isCommon, foundSubsequence) {
    validateLength("aLength", aLength);
    validateLength("bLength", bLength);
    validateCallback("isCommon", isCommon);
    validateCallback("foundSubsequence", foundSubsequence);
    const nCommonF = countCommonItemsF(0, aLength, 0, bLength, isCommon);
    if (nCommonF !== 0) {
      foundSubsequence(nCommonF, 0, 0);
    }
    if (aLength !== nCommonF || bLength !== nCommonF) {
      const aStart = nCommonF;
      const bStart = nCommonF;
      const nCommonR = countCommonItemsR(
        aStart,
        aLength - 1,
        bStart,
        bLength - 1,
        isCommon
      );
      const aEnd = aLength - nCommonR;
      const bEnd = bLength - nCommonR;
      const nCommonFR = nCommonF + nCommonR;
      if (aLength !== nCommonFR && bLength !== nCommonFR) {
        const nChange = 0;
        const transposed = false;
        const callbacks = [
          {
            foundSubsequence,
            isCommon
          }
        ];
        const aIndexesF = [NOT_YET_SET];
        const aIndexesR = [NOT_YET_SET];
        const division = {
          aCommonFollowing: NOT_YET_SET,
          aCommonPreceding: NOT_YET_SET,
          aEndPreceding: NOT_YET_SET,
          aStartFollowing: NOT_YET_SET,
          bCommonFollowing: NOT_YET_SET,
          bCommonPreceding: NOT_YET_SET,
          bEndPreceding: NOT_YET_SET,
          bStartFollowing: NOT_YET_SET,
          nChangeFollowing: NOT_YET_SET,
          nChangePreceding: NOT_YET_SET,
          nCommonFollowing: NOT_YET_SET,
          nCommonPreceding: NOT_YET_SET
        };
        findSubsequences(
          nChange,
          aStart,
          aEnd,
          bStart,
          bEnd,
          transposed,
          callbacks,
          aIndexesF,
          aIndexesR,
          division
        );
      }
      if (nCommonR !== 0) {
        foundSubsequence(nCommonR, aEnd, bEnd);
      }
    }
  }
  return build;
}
var buildExports = requireBuild();
var diffSequences = getDefaultExportFromCjs2(buildExports);
function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, (match) => trailingSpaceFormatter(match));
}
function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(`${indicator} ${formatTrailingSpaces(line, trailingSpaceFormatter)}`) : indicator !== " " ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(`${indicator} ${emptyFirstOrLastLinePlaceholder}`) : "";
}
function printDeleteLine(line, isFirstOrLast, { aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printInsertLine(line, isFirstOrLast, { bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function printCommonLine(line, isFirstOrLast, { commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder }) {
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
}
function createPatchMark(aStart, aEnd, bStart, bEnd, { patchColor }) {
  return patchColor(`@@ -${aStart + 1},${aEnd - aStart} +${bStart + 1},${bEnd - bStart} @@`);
}
function joinAlignedDiffsNoExpand(diffs, options) {
  const iLength = diffs.length;
  const nContextLines = options.contextLines;
  const nContextLines2 = nContextLines + nContextLines;
  let jLength = iLength;
  let hasExcessAtStartOrEnd = false;
  let nExcessesBetweenChanges = 0;
  let i2 = 0;
  while (i2 !== iLength) {
    const iStart = i2;
    while (i2 !== iLength && diffs[i2][0] === DIFF_EQUAL) {
      i2 += 1;
    }
    if (iStart !== i2) {
      if (iStart === 0) {
        if (i2 > nContextLines) {
          jLength -= i2 - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else if (i2 === iLength) {
        const n2 = i2 - iStart;
        if (n2 > nContextLines) {
          jLength -= n2 - nContextLines;
          hasExcessAtStartOrEnd = true;
        }
      } else {
        const n2 = i2 - iStart;
        if (n2 > nContextLines2) {
          jLength -= n2 - nContextLines2;
          nExcessesBetweenChanges += 1;
        }
      }
    }
    while (i2 !== iLength && diffs[i2][0] !== DIFF_EQUAL) {
      i2 += 1;
    }
  }
  const hasPatch = nExcessesBetweenChanges !== 0 || hasExcessAtStartOrEnd;
  if (nExcessesBetweenChanges !== 0) {
    jLength += nExcessesBetweenChanges + 1;
  } else if (hasExcessAtStartOrEnd) {
    jLength += 1;
  }
  const jLast = jLength - 1;
  const lines = [];
  let jPatchMark = 0;
  if (hasPatch) {
    lines.push("");
  }
  let aStart = 0;
  let bStart = 0;
  let aEnd = 0;
  let bEnd = 0;
  const pushCommonLine = (line) => {
    const j = lines.length;
    lines.push(printCommonLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
    bEnd += 1;
  };
  const pushDeleteLine = (line) => {
    const j = lines.length;
    lines.push(printDeleteLine(line, j === 0 || j === jLast, options));
    aEnd += 1;
  };
  const pushInsertLine = (line) => {
    const j = lines.length;
    lines.push(printInsertLine(line, j === 0 || j === jLast, options));
    bEnd += 1;
  };
  i2 = 0;
  while (i2 !== iLength) {
    let iStart = i2;
    while (i2 !== iLength && diffs[i2][0] === DIFF_EQUAL) {
      i2 += 1;
    }
    if (iStart !== i2) {
      if (iStart === 0) {
        if (i2 > nContextLines) {
          iStart = i2 - nContextLines;
          aStart = iStart;
          bStart = iStart;
          aEnd = aStart;
          bEnd = bStart;
        }
        for (let iCommon = iStart; iCommon !== i2; iCommon += 1) {
          pushCommonLine(diffs[iCommon][1]);
        }
      } else if (i2 === iLength) {
        const iEnd = i2 - iStart > nContextLines ? iStart + nContextLines : i2;
        for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {
          pushCommonLine(diffs[iCommon][1]);
        }
      } else {
        const nCommon = i2 - iStart;
        if (nCommon > nContextLines2) {
          const iEnd = iStart + nContextLines;
          for (let iCommon = iStart; iCommon !== iEnd; iCommon += 1) {
            pushCommonLine(diffs[iCommon][1]);
          }
          lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
          jPatchMark = lines.length;
          lines.push("");
          const nOmit = nCommon - nContextLines2;
          aStart = aEnd + nOmit;
          bStart = bEnd + nOmit;
          aEnd = aStart;
          bEnd = bStart;
          for (let iCommon = i2 - nContextLines; iCommon !== i2; iCommon += 1) {
            pushCommonLine(diffs[iCommon][1]);
          }
        } else {
          for (let iCommon = iStart; iCommon !== i2; iCommon += 1) {
            pushCommonLine(diffs[iCommon][1]);
          }
        }
      }
    }
    while (i2 !== iLength && diffs[i2][0] === DIFF_DELETE) {
      pushDeleteLine(diffs[i2][1]);
      i2 += 1;
    }
    while (i2 !== iLength && diffs[i2][0] === DIFF_INSERT) {
      pushInsertLine(diffs[i2][1]);
      i2 += 1;
    }
  }
  if (hasPatch) {
    lines[jPatchMark] = createPatchMark(aStart, aEnd, bStart, bEnd, options);
  }
  return lines.join("\n");
}
function joinAlignedDiffsExpand(diffs, options) {
  return diffs.map((diff2, i2, diffs2) => {
    const line = diff2[1];
    const isFirstOrLast = i2 === 0 || i2 === diffs2.length - 1;
    switch (diff2[0]) {
      case DIFF_DELETE:
        return printDeleteLine(line, isFirstOrLast, options);
      case DIFF_INSERT:
        return printInsertLine(line, isFirstOrLast, options);
      default:
        return printCommonLine(line, isFirstOrLast, options);
    }
  }).join("\n");
}
var noColor = (string) => string;
var DIFF_CONTEXT_DEFAULT = 5;
var DIFF_TRUNCATE_THRESHOLD_DEFAULT = 0;
function getDefaultOptions() {
  return {
    aAnnotation: "Expected",
    aColor: C.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: C.red,
    bIndicator: "+",
    changeColor: C.inverse,
    changeLineTrailingSpaceColor: noColor,
    commonColor: C.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: noColor,
    compareKeys: void 0,
    contextLines: DIFF_CONTEXT_DEFAULT,
    emptyFirstOrLastLinePlaceholder: "",
    expand: false,
    includeChangeCounts: false,
    omitAnnotationLines: false,
    patchColor: C.yellow,
    printBasicPrototype: false,
    truncateThreshold: DIFF_TRUNCATE_THRESHOLD_DEFAULT,
    truncateAnnotation: "... Diff result is truncated",
    truncateAnnotationColor: noColor
  };
}
function getCompareKeys(compareKeys) {
  return compareKeys && typeof compareKeys === "function" ? compareKeys : void 0;
}
function getContextLines(contextLines) {
  return typeof contextLines === "number" && Number.isSafeInteger(contextLines) && contextLines >= 0 ? contextLines : DIFF_CONTEXT_DEFAULT;
}
function normalizeDiffOptions(options = {}) {
  return {
    ...getDefaultOptions(),
    ...options,
    compareKeys: getCompareKeys(options.compareKeys),
    contextLines: getContextLines(options.contextLines)
  };
}
function isEmptyString(lines) {
  return lines.length === 1 && lines[0].length === 0;
}
function countChanges(diffs) {
  let a2 = 0;
  let b2 = 0;
  diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        a2 += 1;
        break;
      case DIFF_INSERT:
        b2 += 1;
        break;
    }
  });
  return {
    a: a2,
    b: b2
  };
}
function printAnnotation({ aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator, includeChangeCounts, omitAnnotationLines }, changeCounts) {
  if (omitAnnotationLines) {
    return "";
  }
  let aRest = "";
  let bRest = "";
  if (includeChangeCounts) {
    const aCount = String(changeCounts.a);
    const bCount = String(changeCounts.b);
    const baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
    const aAnnotationPadding = " ".repeat(Math.max(0, baAnnotationLengthDiff));
    const bAnnotationPadding = " ".repeat(Math.max(0, -baAnnotationLengthDiff));
    const baCountLengthDiff = bCount.length - aCount.length;
    const aCountPadding = " ".repeat(Math.max(0, baCountLengthDiff));
    const bCountPadding = " ".repeat(Math.max(0, -baCountLengthDiff));
    aRest = `${aAnnotationPadding}  ${aIndicator} ${aCountPadding}${aCount}`;
    bRest = `${bAnnotationPadding}  ${bIndicator} ${bCountPadding}${bCount}`;
  }
  const a2 = `${aIndicator} ${aAnnotation}${aRest}`;
  const b2 = `${bIndicator} ${bAnnotation}${bRest}`;
  return `${aColor(a2)}
${bColor(b2)}

`;
}
function printDiffLines(diffs, truncated, options) {
  return printAnnotation(options, countChanges(diffs)) + (options.expand ? joinAlignedDiffsExpand(diffs, options) : joinAlignedDiffsNoExpand(diffs, options)) + (truncated ? options.truncateAnnotationColor(`
${options.truncateAnnotation}`) : "");
}
function diffLinesUnified(aLines, bLines, options) {
  const normalizedOptions = normalizeDiffOptions(options);
  const [diffs, truncated] = diffLinesRaw(isEmptyString(aLines) ? [] : aLines, isEmptyString(bLines) ? [] : bLines, normalizedOptions);
  return printDiffLines(diffs, truncated, normalizedOptions);
}
function diffLinesUnified2(aLinesDisplay, bLinesDisplay, aLinesCompare, bLinesCompare, options) {
  if (isEmptyString(aLinesDisplay) && isEmptyString(aLinesCompare)) {
    aLinesDisplay = [];
    aLinesCompare = [];
  }
  if (isEmptyString(bLinesDisplay) && isEmptyString(bLinesCompare)) {
    bLinesDisplay = [];
    bLinesCompare = [];
  }
  if (aLinesDisplay.length !== aLinesCompare.length || bLinesDisplay.length !== bLinesCompare.length) {
    return diffLinesUnified(aLinesDisplay, bLinesDisplay, options);
  }
  const [diffs, truncated] = diffLinesRaw(aLinesCompare, bLinesCompare, options);
  let aIndex = 0;
  let bIndex = 0;
  diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        diff2[1] = aLinesDisplay[aIndex];
        aIndex += 1;
        break;
      case DIFF_INSERT:
        diff2[1] = bLinesDisplay[bIndex];
        bIndex += 1;
        break;
      default:
        diff2[1] = bLinesDisplay[bIndex];
        aIndex += 1;
        bIndex += 1;
    }
  });
  return printDiffLines(diffs, truncated, normalizeDiffOptions(options));
}
function diffLinesRaw(aLines, bLines, options) {
  const truncate2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;
  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);
  const aLength = truncate2 ? Math.min(aLines.length, truncateThreshold) : aLines.length;
  const bLength = truncate2 ? Math.min(bLines.length, truncateThreshold) : bLines.length;
  const truncated = aLength !== aLines.length || bLength !== bLines.length;
  const isCommon = (aIndex2, bIndex2) => aLines[aIndex2] === bLines[bIndex2];
  const diffs = [];
  let aIndex = 0;
  let bIndex = 0;
  const foundSubsequence = (nCommon, aCommon, bCommon) => {
    for (; aIndex !== aCommon; aIndex += 1) {
      diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
    }
    for (; bIndex !== bCommon; bIndex += 1) {
      diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
    }
    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {
      diffs.push(new Diff(DIFF_EQUAL, bLines[bIndex]));
    }
  };
  diffSequences(aLength, bLength, isCommon, foundSubsequence);
  for (; aIndex !== aLength; aIndex += 1) {
    diffs.push(new Diff(DIFF_DELETE, aLines[aIndex]));
  }
  for (; bIndex !== bLength; bIndex += 1) {
    diffs.push(new Diff(DIFF_INSERT, bLines[bIndex]));
  }
  return [diffs, truncated];
}
function getType3(value) {
  if (value === void 0) {
    return "undefined";
  } else if (value === null) {
    return "null";
  } else if (Array.isArray(value)) {
    return "array";
  } else if (typeof value === "boolean") {
    return "boolean";
  } else if (typeof value === "function") {
    return "function";
  } else if (typeof value === "number") {
    return "number";
  } else if (typeof value === "string") {
    return "string";
  } else if (typeof value === "bigint") {
    return "bigint";
  } else if (typeof value === "object") {
    if (value != null) {
      if (value.constructor === RegExp) {
        return "regexp";
      } else if (value.constructor === Map) {
        return "map";
      } else if (value.constructor === Set) {
        return "set";
      } else if (value.constructor === Date) {
        return "date";
      }
    }
    return "object";
  } else if (typeof value === "symbol") {
    return "symbol";
  }
  throw new Error(`value of unknown type: ${value}`);
}
function getNewLineSymbol(string) {
  return string.includes("\r\n") ? "\r\n" : "\n";
}
function diffStrings(a2, b2, options) {
  const truncate2 = (options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? false;
  const truncateThreshold = Math.max(Math.floor((options === null || options === void 0 ? void 0 : options.truncateThreshold) ?? 0), 0);
  let aLength = a2.length;
  let bLength = b2.length;
  if (truncate2) {
    const aMultipleLines = a2.includes("\n");
    const bMultipleLines = b2.includes("\n");
    const aNewLineSymbol = getNewLineSymbol(a2);
    const bNewLineSymbol = getNewLineSymbol(b2);
    const _a10 = aMultipleLines ? `${a2.split(aNewLineSymbol, truncateThreshold).join(aNewLineSymbol)}
` : a2;
    const _b5 = bMultipleLines ? `${b2.split(bNewLineSymbol, truncateThreshold).join(bNewLineSymbol)}
` : b2;
    aLength = _a10.length;
    bLength = _b5.length;
  }
  const truncated = aLength !== a2.length || bLength !== b2.length;
  const isCommon = (aIndex2, bIndex2) => a2[aIndex2] === b2[bIndex2];
  let aIndex = 0;
  let bIndex = 0;
  const diffs = [];
  const foundSubsequence = (nCommon, aCommon, bCommon) => {
    if (aIndex !== aCommon) {
      diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex, aCommon)));
    }
    if (bIndex !== bCommon) {
      diffs.push(new Diff(DIFF_INSERT, b2.slice(bIndex, bCommon)));
    }
    aIndex = aCommon + nCommon;
    bIndex = bCommon + nCommon;
    diffs.push(new Diff(DIFF_EQUAL, b2.slice(bCommon, bIndex)));
  };
  diffSequences(aLength, bLength, isCommon, foundSubsequence);
  if (aIndex !== aLength) {
    diffs.push(new Diff(DIFF_DELETE, a2.slice(aIndex)));
  }
  if (bIndex !== bLength) {
    diffs.push(new Diff(DIFF_INSERT, b2.slice(bIndex)));
  }
  return [diffs, truncated];
}
function concatenateRelevantDiffs(op, diffs, changeColor) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op && diff2[1].length !== 0 ? changeColor(diff2[1]) : ""), "");
}
var ChangeBuffer = class {
  constructor(op, changeColor) {
    __publicField(this, "op");
    __publicField(this, "line");
    __publicField(this, "lines");
    __publicField(this, "changeColor");
    this.op = op;
    this.line = [];
    this.lines = [];
    this.changeColor = changeColor;
  }
  pushSubstring(substring) {
    this.pushDiff(new Diff(this.op, substring));
  }
  pushLine() {
    this.lines.push(this.line.length !== 1 ? new Diff(this.op, concatenateRelevantDiffs(this.op, this.line, this.changeColor)) : this.line[0][0] === this.op ? this.line[0] : new Diff(this.op, this.line[0][1]));
    this.line.length = 0;
  }
  isLineEmpty() {
    return this.line.length === 0;
  }
  // Minor input to buffer.
  pushDiff(diff2) {
    this.line.push(diff2);
  }
  // Main input to buffer.
  align(diff2) {
    const string = diff2[1];
    if (string.includes("\n")) {
      const substrings = string.split("\n");
      const iLast = substrings.length - 1;
      substrings.forEach((substring, i2) => {
        if (i2 < iLast) {
          this.pushSubstring(substring);
          this.pushLine();
        } else if (substring.length !== 0) {
          this.pushSubstring(substring);
        }
      });
    } else {
      this.pushDiff(diff2);
    }
  }
  // Output from buffer.
  moveLinesTo(lines) {
    if (!this.isLineEmpty()) {
      this.pushLine();
    }
    lines.push(...this.lines);
    this.lines.length = 0;
  }
};
var CommonBuffer = class {
  constructor(deleteBuffer, insertBuffer) {
    __publicField(this, "deleteBuffer");
    __publicField(this, "insertBuffer");
    __publicField(this, "lines");
    this.deleteBuffer = deleteBuffer;
    this.insertBuffer = insertBuffer;
    this.lines = [];
  }
  pushDiffCommonLine(diff2) {
    this.lines.push(diff2);
  }
  pushDiffChangeLines(diff2) {
    const isDiffEmpty = diff2[1].length === 0;
    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {
      this.deleteBuffer.pushDiff(diff2);
    }
    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {
      this.insertBuffer.pushDiff(diff2);
    }
  }
  flushChangeLines() {
    this.deleteBuffer.moveLinesTo(this.lines);
    this.insertBuffer.moveLinesTo(this.lines);
  }
  // Input to buffer.
  align(diff2) {
    const op = diff2[0];
    const string = diff2[1];
    if (string.includes("\n")) {
      const substrings = string.split("\n");
      const iLast = substrings.length - 1;
      substrings.forEach((substring, i2) => {
        if (i2 === 0) {
          const subdiff = new Diff(op, substring);
          if (this.deleteBuffer.isLineEmpty() && this.insertBuffer.isLineEmpty()) {
            this.flushChangeLines();
            this.pushDiffCommonLine(subdiff);
          } else {
            this.pushDiffChangeLines(subdiff);
            this.flushChangeLines();
          }
        } else if (i2 < iLast) {
          this.pushDiffCommonLine(new Diff(op, substring));
        } else if (substring.length !== 0) {
          this.pushDiffChangeLines(new Diff(op, substring));
        }
      });
    } else {
      this.pushDiffChangeLines(diff2);
    }
  }
  // Output from buffer.
  getLines() {
    this.flushChangeLines();
    return this.lines;
  }
};
function getAlignedDiffs(diffs, changeColor) {
  const deleteBuffer = new ChangeBuffer(DIFF_DELETE, changeColor);
  const insertBuffer = new ChangeBuffer(DIFF_INSERT, changeColor);
  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);
  diffs.forEach((diff2) => {
    switch (diff2[0]) {
      case DIFF_DELETE:
        deleteBuffer.align(diff2);
        break;
      case DIFF_INSERT:
        insertBuffer.align(diff2);
        break;
      default:
        commonBuffer.align(diff2);
    }
  });
  return commonBuffer.getLines();
}
function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    const iLast = diffs.length - 1;
    return diffs.some((diff2, i2) => diff2[0] === DIFF_EQUAL && (i2 !== iLast || diff2[1] !== "\n"));
  }
  return diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
}
function diffStringsUnified(a2, b2, options) {
  if (a2 !== b2 && a2.length !== 0 && b2.length !== 0) {
    const isMultiline = a2.includes("\n") || b2.includes("\n");
    const [diffs, truncated] = diffStringsRaw(isMultiline ? `${a2}
` : a2, isMultiline ? `${b2}
` : b2, true, options);
    if (hasCommonDiff(diffs, isMultiline)) {
      const optionsNormalized = normalizeDiffOptions(options);
      const lines = getAlignedDiffs(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, truncated, optionsNormalized);
    }
  }
  return diffLinesUnified(a2.split("\n"), b2.split("\n"), options);
}
function diffStringsRaw(a2, b2, cleanup, options) {
  const [diffs, truncated] = diffStrings(a2, b2, options);
  if (cleanup) {
    diff_cleanupSemantic(diffs);
  }
  return [diffs, truncated];
}
function getCommonMessage(message, options) {
  const { commonColor } = normalizeDiffOptions(options);
  return commonColor(message);
}
var { AsymmetricMatcher: AsymmetricMatcher2, DOMCollection: DOMCollection2, DOMElement: DOMElement2, Immutable: Immutable2, ReactElement: ReactElement2, ReactTestComponent: ReactTestComponent2 } = plugins;
var PLUGINS2 = [
  ReactTestComponent2,
  ReactElement2,
  DOMElement2,
  DOMCollection2,
  Immutable2,
  AsymmetricMatcher2,
  plugins.Error
];
var FORMAT_OPTIONS = {
  maxDepth: 20,
  plugins: PLUGINS2
};
var FALLBACK_FORMAT_OPTIONS = {
  callToJSON: false,
  maxDepth: 8,
  plugins: PLUGINS2
};
function diff(a2, b2, options) {
  if (Object.is(a2, b2)) {
    return "";
  }
  const aType = getType3(a2);
  let expectedType = aType;
  let omitDifference = false;
  if (aType === "object" && typeof a2.asymmetricMatch === "function") {
    if (a2.$$typeof !== Symbol.for("jest.asymmetricMatcher")) {
      return void 0;
    }
    if (typeof a2.getExpectedType !== "function") {
      return void 0;
    }
    expectedType = a2.getExpectedType();
    omitDifference = expectedType === "string";
  }
  if (expectedType !== getType3(b2)) {
    let truncate2 = function(s) {
      return s.length <= MAX_LENGTH ? s : `${s.slice(0, MAX_LENGTH)}...`;
    };
    const { aAnnotation, aColor, aIndicator, bAnnotation, bColor, bIndicator } = normalizeDiffOptions(options);
    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    let aDisplay = format(a2, formatOptions);
    let bDisplay = format(b2, formatOptions);
    const MAX_LENGTH = 1e5;
    aDisplay = truncate2(aDisplay);
    bDisplay = truncate2(bDisplay);
    const aDiff = `${aColor(`${aIndicator} ${aAnnotation}:`)} 
${aDisplay}`;
    const bDiff = `${bColor(`${bIndicator} ${bAnnotation}:`)} 
${bDisplay}`;
    return `${aDiff}

${bDiff}`;
  }
  if (omitDifference) {
    return void 0;
  }
  switch (aType) {
    case "string":
      return diffLinesUnified(a2.split("\n"), b2.split("\n"), options);
    case "boolean":
    case "number":
      return comparePrimitive(a2, b2, options);
    case "map":
      return compareObjects(sortMap(a2), sortMap(b2), options);
    case "set":
      return compareObjects(sortSet(a2), sortSet(b2), options);
    default:
      return compareObjects(a2, b2, options);
  }
}
function comparePrimitive(a2, b2, options) {
  const aFormat = format(a2, FORMAT_OPTIONS);
  const bFormat = format(b2, FORMAT_OPTIONS);
  return aFormat === bFormat ? "" : diffLinesUnified(aFormat.split("\n"), bFormat.split("\n"), options);
}
function sortMap(map) {
  return new Map(Array.from(map.entries()).sort());
}
function sortSet(set2) {
  return new Set(Array.from(set2.values()).sort());
}
function compareObjects(a2, b2, options) {
  let difference;
  let hasThrown = false;
  try {
    const formatOptions = getFormatOptions(FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b2, formatOptions, options);
  } catch {
    hasThrown = true;
  }
  const noDiffMessage = getCommonMessage(NO_DIFF_MESSAGE, options);
  if (difference === void 0 || difference === noDiffMessage) {
    const formatOptions = getFormatOptions(FALLBACK_FORMAT_OPTIONS, options);
    difference = getObjectsDifference(a2, b2, formatOptions, options);
    if (difference !== noDiffMessage && !hasThrown) {
      difference = `${getCommonMessage(SIMILAR_MESSAGE, options)}

${difference}`;
    }
  }
  return difference;
}
function getFormatOptions(formatOptions, options) {
  const { compareKeys, printBasicPrototype, maxDepth } = normalizeDiffOptions(options);
  return {
    ...formatOptions,
    compareKeys,
    printBasicPrototype,
    maxDepth: maxDepth ?? formatOptions.maxDepth
  };
}
function getObjectsDifference(a2, b2, formatOptions, options) {
  const formatOptionsZeroIndent = {
    ...formatOptions,
    indent: 0
  };
  const aCompare = format(a2, formatOptionsZeroIndent);
  const bCompare = format(b2, formatOptionsZeroIndent);
  if (aCompare === bCompare) {
    return getCommonMessage(NO_DIFF_MESSAGE, options);
  } else {
    const aDisplay = format(a2, formatOptions);
    const bDisplay = format(b2, formatOptions);
    return diffLinesUnified2(aDisplay.split("\n"), bDisplay.split("\n"), aCompare.split("\n"), bCompare.split("\n"), options);
  }
}
var MAX_DIFF_STRING_LENGTH = 2e4;
function isAsymmetricMatcher(data) {
  const type = getType2(data);
  return type === "Object" && typeof data.asymmetricMatch === "function";
}
function isReplaceable(obj1, obj2) {
  const obj1Type = getType2(obj1);
  const obj2Type = getType2(obj2);
  return obj1Type === obj2Type && (obj1Type === "Object" || obj1Type === "Array");
}
function printDiffOrStringify(received, expected, options) {
  const { aAnnotation, bAnnotation } = normalizeDiffOptions(options);
  if (typeof expected === "string" && typeof received === "string" && expected.length > 0 && received.length > 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
    if (expected.includes("\n") || received.includes("\n")) {
      return diffStringsUnified(expected, received, options);
    }
    const [diffs] = diffStringsRaw(expected, received, true);
    const hasCommonDiff2 = diffs.some((diff2) => diff2[0] === DIFF_EQUAL);
    const printLabel = getLabelPrinter(aAnnotation, bAnnotation);
    const expectedLine = printLabel(aAnnotation) + printExpected(getCommonAndChangedSubstrings(diffs, DIFF_DELETE, hasCommonDiff2));
    const receivedLine = printLabel(bAnnotation) + printReceived(getCommonAndChangedSubstrings(diffs, DIFF_INSERT, hasCommonDiff2));
    return `${expectedLine}
${receivedLine}`;
  }
  const clonedExpected = deepClone(expected, { forceWritable: true });
  const clonedReceived = deepClone(received, { forceWritable: true });
  const { replacedExpected, replacedActual } = replaceAsymmetricMatcher(clonedReceived, clonedExpected);
  const difference = diff(replacedExpected, replacedActual, options);
  return difference;
}
function replaceAsymmetricMatcher(actual, expected, actualReplaced = /* @__PURE__ */ new WeakSet(), expectedReplaced = /* @__PURE__ */ new WeakSet()) {
  if (actual instanceof Error && expected instanceof Error && typeof actual.cause !== "undefined" && typeof expected.cause === "undefined") {
    delete actual.cause;
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  if (!isReplaceable(actual, expected)) {
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  if (actualReplaced.has(actual) || expectedReplaced.has(expected)) {
    return {
      replacedActual: actual,
      replacedExpected: expected
    };
  }
  actualReplaced.add(actual);
  expectedReplaced.add(expected);
  getOwnProperties(expected).forEach((key) => {
    const expectedValue = expected[key];
    const actualValue = actual[key];
    if (isAsymmetricMatcher(expectedValue)) {
      if (expectedValue.asymmetricMatch(actualValue)) {
        actual[key] = expectedValue;
      }
    } else if (isAsymmetricMatcher(actualValue)) {
      if (actualValue.asymmetricMatch(expectedValue)) {
        expected[key] = actualValue;
      }
    } else if (isReplaceable(actualValue, expectedValue)) {
      const replaced = replaceAsymmetricMatcher(actualValue, expectedValue, actualReplaced, expectedReplaced);
      actual[key] = replaced.replacedActual;
      expected[key] = replaced.replacedExpected;
    }
  });
  return {
    replacedActual: actual,
    replacedExpected: expected
  };
}
function getLabelPrinter(...strings) {
  const maxLength = strings.reduce((max, string) => string.length > max ? string.length : max, 0);
  return (string) => `${string}: ${" ".repeat(maxLength - string.length)}`;
}
var SPACE_SYMBOL = "·";
function replaceTrailingSpaces(text) {
  return text.replace(/\s+$/gm, (spaces) => SPACE_SYMBOL.repeat(spaces.length));
}
function printReceived(object2) {
  return C.red(replaceTrailingSpaces(stringify(object2)));
}
function printExpected(value) {
  return C.green(replaceTrailingSpaces(stringify(value)));
}
function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff2) {
  return diffs.reduce((reduced, diff2) => reduced + (diff2[0] === DIFF_EQUAL ? diff2[1] : diff2[0] === op ? hasCommonDiff2 ? C.inverse(diff2[1]) : diff2[1] : ""), "");
}

// node_modules/@vitest/utils/dist/serialize.js
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isImmutable(v2) {
  return v2 && (v2[IS_COLLECTION_SYMBOL] || v2[IS_RECORD_SYMBOL]);
}
var OBJECT_PROTO = Object.getPrototypeOf({});
function getUnserializableMessage(err) {
  if (err instanceof Error) {
    return `<unserializable>: ${err.message}`;
  }
  if (typeof err === "string") {
    return `<unserializable>: ${err}`;
  }
  return "<unserializable>";
}
function serializeValue(val, seen = /* @__PURE__ */ new WeakMap()) {
  if (!val || typeof val === "string") {
    return val;
  }
  if (val instanceof Error && "toJSON" in val && typeof val.toJSON === "function") {
    const jsonValue = val.toJSON();
    if (jsonValue && jsonValue !== val && typeof jsonValue === "object") {
      if (typeof val.message === "string") {
        safe(() => jsonValue.message ?? (jsonValue.message = normalizeErrorMessage(val.message)));
      }
      if (typeof val.stack === "string") {
        safe(() => jsonValue.stack ?? (jsonValue.stack = val.stack));
      }
      if (typeof val.name === "string") {
        safe(() => jsonValue.name ?? (jsonValue.name = val.name));
      }
      if (val.cause != null) {
        safe(() => jsonValue.cause ?? (jsonValue.cause = serializeValue(val.cause, seen)));
      }
    }
    return serializeValue(jsonValue, seen);
  }
  if (typeof val === "function") {
    return `Function<${val.name || "anonymous"}>`;
  }
  if (typeof val === "symbol") {
    return val.toString();
  }
  if (typeof val !== "object") {
    return val;
  }
  if (typeof Buffer !== "undefined" && val instanceof Buffer) {
    return `<Buffer(${val.length}) ...>`;
  }
  if (typeof Uint8Array !== "undefined" && val instanceof Uint8Array) {
    return `<Uint8Array(${val.length}) ...>`;
  }
  if (isImmutable(val)) {
    return serializeValue(val.toJSON(), seen);
  }
  if (val instanceof Promise || val.constructor && val.constructor.prototype === "AsyncFunction") {
    return "Promise";
  }
  if (typeof Element !== "undefined" && val instanceof Element) {
    return val.tagName;
  }
  if (typeof val.toJSON === "function") {
    return serializeValue(val.toJSON(), seen);
  }
  if (seen.has(val)) {
    return seen.get(val);
  }
  if (Array.isArray(val)) {
    const clone2 = new Array(val.length);
    seen.set(val, clone2);
    val.forEach((e, i2) => {
      try {
        clone2[i2] = serializeValue(e, seen);
      } catch (err) {
        clone2[i2] = getUnserializableMessage(err);
      }
    });
    return clone2;
  } else {
    const clone2 = /* @__PURE__ */ Object.create(null);
    seen.set(val, clone2);
    let obj = val;
    while (obj && obj !== OBJECT_PROTO) {
      Object.getOwnPropertyNames(obj).forEach((key) => {
        if (key in clone2) {
          return;
        }
        try {
          clone2[key] = serializeValue(val[key], seen);
        } catch (err) {
          delete clone2[key];
          clone2[key] = getUnserializableMessage(err);
        }
      });
      obj = Object.getPrototypeOf(obj);
    }
    if (val instanceof Error) {
      safe(() => val.message = normalizeErrorMessage(val.message));
    }
    return clone2;
  }
}
function safe(fn) {
  try {
    return fn();
  } catch {
  }
}
function normalizeErrorMessage(message) {
  return message.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}

// node_modules/@vitest/utils/dist/error.js
function processError(_err, diffOptions, seen = /* @__PURE__ */ new WeakSet()) {
  if (!_err || typeof _err !== "object") {
    return { message: String(_err) };
  }
  const err = _err;
  if (err.showDiff || err.showDiff === void 0 && err.expected !== void 0 && err.actual !== void 0) {
    err.diff = printDiffOrStringify(err.actual, err.expected, {
      ...diffOptions,
      ...err.diffOptions
    });
  }
  if ("expected" in err && typeof err.expected !== "string") {
    err.expected = stringify(err.expected, 10);
  }
  if ("actual" in err && typeof err.actual !== "string") {
    err.actual = stringify(err.actual, 10);
  }
  try {
    if (!seen.has(err) && typeof err.cause === "object") {
      seen.add(err);
      err.cause = processError(err.cause, diffOptions, seen);
    }
  } catch {
  }
  try {
    return serializeValue(err);
  } catch (e) {
    return serializeValue(new Error(`Failed to fully serialize error: ${e === null || e === void 0 ? void 0 : e.message}
Inner error message: ${err === null || err === void 0 ? void 0 : err.message}`));
  }
}

// node_modules/@vitest/utils/dist/chunk-pathe.M-eThtNZ.js
var _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
  if (!input) {
    return input;
  }
  return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r2) => r2.toUpperCase());
}
var _UNC_REGEX = /^[/\\]{2}/;
var _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
var _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
var normalize2 = function(path) {
  if (path.length === 0) {
    return ".";
  }
  path = normalizeWindowsPath(path);
  const isUNCPath = path.match(_UNC_REGEX);
  const isPathAbsolute = isAbsolute2(path);
  const trailingSeparator = path[path.length - 1] === "/";
  path = normalizeString(path, !isPathAbsolute);
  if (path.length === 0) {
    if (isPathAbsolute) {
      return "/";
    }
    return trailingSeparator ? "./" : ".";
  }
  if (trailingSeparator) {
    path += "/";
  }
  if (_DRIVE_LETTER_RE.test(path)) {
    path += "/";
  }
  if (isUNCPath) {
    if (!isPathAbsolute) {
      return `//./${path}`;
    }
    return `//${path}`;
  }
  return isPathAbsolute && !isAbsolute2(path) ? `/${path}` : path;
};
var join2 = function(...segments) {
  let path = "";
  for (const seg of segments) {
    if (!seg) {
      continue;
    }
    if (path.length > 0) {
      const pathTrailing = path[path.length - 1] === "/";
      const segLeading = seg[0] === "/";
      const both = pathTrailing && segLeading;
      if (both) {
        path += seg.slice(1);
      } else {
        path += pathTrailing || segLeading ? seg : `/${seg}`;
      }
    } else {
      path += seg;
    }
  }
  return normalize2(path);
};
function cwd() {
  if (typeof process !== "undefined" && typeof process.cwd === "function") {
    return process.cwd().replace(/\\/g, "/");
  }
  return "/";
}
var resolve2 = function(...arguments_) {
  arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let index2 = arguments_.length - 1; index2 >= -1 && !resolvedAbsolute; index2--) {
    const path = index2 >= 0 ? arguments_[index2] : cwd();
    if (!path || path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = isAbsolute2(path);
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute && !isAbsolute2(resolvedPath)) {
    return `/${resolvedPath}`;
  }
  return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let char = null;
  for (let index2 = 0; index2 <= path.length; ++index2) {
    if (index2 < path.length) {
      char = path[index2];
    } else if (char === "/") {
      break;
    } else {
      char = "/";
    }
    if (char === "/") {
      if (lastSlash === index2 - 1 || dots === 1) ;
      else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
            }
            lastSlash = index2;
            dots = 0;
            continue;
          } else if (res.length > 0) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path.slice(lastSlash + 1, index2)}`;
        } else {
          res = path.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (char === "." && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var isAbsolute2 = function(p2) {
  return _IS_ABSOLUTE_RE.test(p2);
};
var dirname2 = function(p2) {
  const segments = normalizeWindowsPath(p2).replace(/\/$/, "").split("/").slice(0, -1);
  if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) {
    segments[0] += "/";
  }
  return segments.join("/") || (isAbsolute2(p2) ? "/" : ".");
};

// node_modules/@vitest/utils/dist/source-map.js
var comma = ",".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i2 = 0; i2 < chars.length; i2++) {
  const c2 = chars.charCodeAt(i2);
  intToChar[i2] = c2;
  charToInt[c2] = i2;
}
function decodeInteger(reader, relative2) {
  let value = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c2 = reader.next();
    integer = charToInt[c2];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  return relative2 + value;
}
function hasMoreVlq(reader, max) {
  if (reader.pos >= max) return false;
  return reader.peek() !== comma;
}
var StringReader = class {
  constructor(buffer) {
    this.pos = 0;
    this.buffer = buffer;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    const { buffer, pos } = this;
    const idx = buffer.indexOf(char, pos);
    return idx === -1 ? buffer.length : idx;
  }
};
function decode(mappings) {
  const { length } = mappings;
  const reader = new StringReader(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader.indexOf(";");
    const line = [];
    let sorted = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader.pos < semi) {
      let seg;
      genColumn = decodeInteger(reader, genColumn);
      if (genColumn < lastCol) sorted = false;
      lastCol = genColumn;
      if (hasMoreVlq(reader, semi)) {
        sourcesIndex = decodeInteger(reader, sourcesIndex);
        sourceLine = decodeInteger(reader, sourceLine);
        sourceColumn = decodeInteger(reader, sourceColumn);
        if (hasMoreVlq(reader, semi)) {
          namesIndex = decodeInteger(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted) sort(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos <= length);
  return decoded;
}
function sort(line) {
  line.sort(sortComparator);
}
function sortComparator(a2, b2) {
  return a2[0] - b2[0];
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
var found = false;
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index2) {
  for (let i2 = index2 + 1; i2 < haystack.length; index2 = i2++) {
    if (haystack[i2][COLUMN] !== needle) break;
  }
  return index2;
}
function lowerBound(haystack, needle, index2) {
  for (let i2 = index2 - 1; i2 >= 0; index2 = i2--) {
    if (haystack[i2][COLUMN] !== needle) break;
  }
  return index2;
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
function cast(map) {
  return map;
}
function decodedMappings(map) {
  var _a10;
  return (_a10 = cast(map))._decoded || (_a10._decoded = decode(cast(map)._encoded));
}
function originalPositionFor(map, needle) {
  let { line, column, bias } = needle;
  line--;
  if (line < 0) throw new Error(LINE_GTR_ZERO);
  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
  const decoded = decodedMappings(map);
  if (line >= decoded.length) return OMapping(null, null, null, null);
  const segments = decoded[line];
  const index2 = traceSegmentInternal(
    segments,
    cast(map)._decodedMemo,
    line,
    column,
    bias || GREATEST_LOWER_BOUND
  );
  if (index2 === -1) return OMapping(null, null, null, null);
  const segment = segments[index2];
  if (segment.length === 1) return OMapping(null, null, null, null);
  const { names, resolvedSources } = map;
  return OMapping(
    resolvedSources[segment[SOURCES_INDEX]],
    segment[SOURCE_LINE] + 1,
    segment[SOURCE_COLUMN],
    segment.length === 5 ? names[segment[NAMES_INDEX]] : null
  );
}
function OMapping(source, line, column, name) {
  return { source, line, column, name };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index2 = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index2);
  } else if (bias === LEAST_UPPER_BOUND) index2++;
  if (index2 === -1 || index2 === segments.length) return -1;
  return index2;
}
var CHROME_IE_STACK_REGEXP = /^\s*at .*(?:\S:\d+|\(native\))/m;
var SAFARI_NATIVE_CODE_REGEXP = /^(?:eval@)?(?:\[native code\])?$/;
var stackIgnorePatterns = [
  "node:internal",
  /\/packages\/\w+\/dist\//,
  /\/@vitest\/\w+\/dist\//,
  "/vitest/dist/",
  "/vitest/src/",
  "/node_modules/chai/",
  "/node_modules/tinyspy/",
  "/vite/dist/node/module-runner",
  "/rolldown-vite/dist/node/module-runner",
  "/deps/chunk-",
  "/deps/@vitest",
  "/deps/loupe",
  "/deps/chai",
  "/browser-playwright/dist/locators.js",
  "/browser-webdriverio/dist/locators.js",
  "/browser-preview/dist/locators.js",
  /node:\w+/,
  /__vitest_test__/,
  /__vitest_browser__/,
  /\/deps\/vitest_/
];
function extractLocation(urlLike) {
  if (!urlLike.includes(":")) {
    return [urlLike];
  }
  const regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
  const parts = regExp.exec(urlLike.replace(/^\(|\)$/g, ""));
  if (!parts) {
    return [urlLike];
  }
  let url2 = parts[1];
  if (url2.startsWith("async ")) {
    url2 = url2.slice(6);
  }
  if (url2.startsWith("http:") || url2.startsWith("https:")) {
    const urlObj = new URL(url2);
    urlObj.searchParams.delete("import");
    urlObj.searchParams.delete("browserv");
    url2 = urlObj.pathname + urlObj.hash + urlObj.search;
  }
  if (url2.startsWith("/@fs/")) {
    const isWindows2 = /^\/@fs\/[a-zA-Z]:\//.test(url2);
    url2 = url2.slice(isWindows2 ? 5 : 4);
  }
  return [
    url2,
    parts[2] || void 0,
    parts[3] || void 0
  ];
}
function parseSingleFFOrSafariStack(raw) {
  let line = raw.trim();
  if (SAFARI_NATIVE_CODE_REGEXP.test(line)) {
    return null;
  }
  if (line.includes(" > eval")) {
    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
  }
  if (!line.includes("@")) {
    return null;
  }
  let atIndex = -1;
  let locationPart = "";
  let functionName;
  for (let i2 = 0; i2 < line.length; i2++) {
    if (line[i2] === "@") {
      const candidateLocation = line.slice(i2 + 1);
      if (candidateLocation.includes(":") && candidateLocation.length >= 3) {
        atIndex = i2;
        locationPart = candidateLocation;
        functionName = i2 > 0 ? line.slice(0, i2) : void 0;
        break;
      }
    }
  }
  if (atIndex === -1 || !locationPart.includes(":") || locationPart.length < 3) {
    return null;
  }
  const [url2, lineNumber, columnNumber] = extractLocation(locationPart);
  if (!url2 || !lineNumber || !columnNumber) {
    return null;
  }
  return {
    file: url2,
    method: functionName || "",
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  };
}
function parseSingleV8Stack(raw) {
  let line = raw.trim();
  if (!CHROME_IE_STACK_REGEXP.test(line)) {
    return null;
  }
  if (line.includes("(eval ")) {
    line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
  }
  let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
  const location = sanitizedLine.match(/ (\(.+\)$)/);
  sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
  const [url2, lineNumber, columnNumber] = extractLocation(location ? location[1] : sanitizedLine);
  let method = location && sanitizedLine || "";
  let file = url2 && ["eval", "<anonymous>"].includes(url2) ? void 0 : url2;
  if (!file || !lineNumber || !columnNumber) {
    return null;
  }
  if (method.startsWith("async ")) {
    method = method.slice(6);
  }
  if (file.startsWith("file://")) {
    file = file.slice(7);
  }
  file = file.startsWith("node:") || file.startsWith("internal:") ? file : resolve2(file);
  if (method) {
    method = method.replace(/__vite_ssr_import_\d+__\./g, "").replace(/(Object\.)?__vite_ssr_export_default__\s?/g, "");
  }
  return {
    method,
    file,
    line: Number.parseInt(lineNumber),
    column: Number.parseInt(columnNumber)
  };
}
function parseStacktrace(stack, options = {}) {
  const { ignoreStackEntries = stackIgnorePatterns } = options;
  const stacks = !CHROME_IE_STACK_REGEXP.test(stack) ? parseFFOrSafariStackTrace(stack) : parseV8Stacktrace(stack);
  return stacks.map((stack2) => {
    var _options$getSourceMap;
    if (options.getUrlId) {
      stack2.file = options.getUrlId(stack2.file);
    }
    const map = (_options$getSourceMap = options.getSourceMap) === null || _options$getSourceMap === void 0 ? void 0 : _options$getSourceMap.call(options, stack2.file);
    if (!map || typeof map !== "object" || !map.version) {
      return shouldFilter(ignoreStackEntries, stack2.file) ? null : stack2;
    }
    const traceMap = new DecodedMap(map, stack2.file);
    const position = getOriginalPosition(traceMap, stack2);
    if (!position) {
      return stack2;
    }
    const { line, column, source, name } = position;
    let file = source || stack2.file;
    if (file.match(/\/\w:\//)) {
      file = file.slice(1);
    }
    if (shouldFilter(ignoreStackEntries, file)) {
      return null;
    }
    if (line != null && column != null) {
      return {
        line,
        column,
        file,
        method: name || stack2.method
      };
    }
    return stack2;
  }).filter((s) => s != null);
}
function shouldFilter(ignoreStackEntries, file) {
  return ignoreStackEntries.some((p2) => file.match(p2));
}
function parseFFOrSafariStackTrace(stack) {
  return stack.split("\n").map((line) => parseSingleFFOrSafariStack(line)).filter(notNullish);
}
function parseV8Stacktrace(stack) {
  return stack.split("\n").map((line) => parseSingleV8Stack(line)).filter(notNullish);
}
function parseErrorStacktrace(e, options = {}) {
  if (!e || isPrimitive(e)) {
    return [];
  }
  if ("stacks" in e && e.stacks) {
    return e.stacks;
  }
  const stackStr = e.stack || "";
  let stackFrames = typeof stackStr === "string" ? parseStacktrace(stackStr, options) : [];
  if (!stackFrames.length) {
    const e_ = e;
    if (e_.fileName != null && e_.lineNumber != null && e_.columnNumber != null) {
      stackFrames = parseStacktrace(`${e_.fileName}:${e_.lineNumber}:${e_.columnNumber}`, options);
    }
    if (e_.sourceURL != null && e_.line != null && e_._column != null) {
      stackFrames = parseStacktrace(`${e_.sourceURL}:${e_.line}:${e_.column}`, options);
    }
  }
  if (options.frameFilter) {
    stackFrames = stackFrames.filter((f2) => options.frameFilter(e, f2) !== false);
  }
  e.stacks = stackFrames;
  return stackFrames;
}
var DecodedMap = class {
  constructor(map, from) {
    __publicField(this, "_encoded");
    __publicField(this, "_decoded");
    __publicField(this, "_decodedMemo");
    __publicField(this, "url");
    __publicField(this, "version");
    __publicField(this, "names", []);
    __publicField(this, "resolvedSources");
    this.map = map;
    const { mappings, names, sources } = map;
    this.version = map.version;
    this.names = names || [];
    this._encoded = mappings || "";
    this._decodedMemo = memoizedState();
    this.url = from;
    this.resolvedSources = (sources || []).map((s) => resolve2(s || "", from));
  }
};
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function getOriginalPosition(map, needle) {
  const result = originalPositionFor(map, needle);
  if (result.column == null) {
    return null;
  }
  return result;
}

// node_modules/@vitest/runner/dist/chunk-tasks.js
function interpretTaskModes(file, namePattern, testLocations, onlyMode, parentIsOnly, allowOnly) {
  const matchedLocations = [];
  const traverseSuite = (suite, parentIsOnly2, parentMatchedWithLocation) => {
    const suiteIsOnly = parentIsOnly2 || suite.mode === "only";
    suite.tasks.forEach((t2) => {
      const includeTask = suiteIsOnly || t2.mode === "only";
      if (onlyMode) {
        if (t2.type === "suite" && (includeTask || someTasksAreOnly(t2))) {
          if (t2.mode === "only") {
            checkAllowOnly(t2, allowOnly);
            t2.mode = "run";
          }
        } else if (t2.mode === "run" && !includeTask) {
          t2.mode = "skip";
        } else if (t2.mode === "only") {
          checkAllowOnly(t2, allowOnly);
          t2.mode = "run";
        }
      }
      let hasLocationMatch = parentMatchedWithLocation;
      if (testLocations !== void 0 && testLocations.length !== 0) {
        if (t2.location && (testLocations === null || testLocations === void 0 ? void 0 : testLocations.includes(t2.location.line))) {
          t2.mode = "run";
          matchedLocations.push(t2.location.line);
          hasLocationMatch = true;
        } else if (parentMatchedWithLocation) {
          t2.mode = "run";
        } else if (t2.type === "test") {
          t2.mode = "skip";
        }
      }
      if (t2.type === "test") {
        if (namePattern && !getTaskFullName(t2).match(namePattern)) {
          t2.mode = "skip";
        }
      } else if (t2.type === "suite") {
        if (t2.mode === "skip") {
          skipAllTasks(t2);
        } else if (t2.mode === "todo") {
          todoAllTasks(t2);
        } else {
          traverseSuite(t2, includeTask, hasLocationMatch);
        }
      }
    });
    if (suite.mode === "run" || suite.mode === "queued") {
      if (suite.tasks.length && suite.tasks.every((i2) => i2.mode !== "run" && i2.mode !== "queued")) {
        suite.mode = "skip";
      }
    }
  };
  traverseSuite(file, parentIsOnly, false);
  const nonMatching = testLocations === null || testLocations === void 0 ? void 0 : testLocations.filter((loc) => !matchedLocations.includes(loc));
  if (nonMatching && nonMatching.length !== 0) {
    const message = nonMatching.length === 1 ? `line ${nonMatching[0]}` : `lines ${nonMatching.join(", ")}`;
    if (file.result === void 0) {
      file.result = {
        state: "fail",
        errors: []
      };
    }
    if (file.result.errors === void 0) {
      file.result.errors = [];
    }
    file.result.errors.push(processError(new Error(`No test found in ${file.name} in ${message}`)));
  }
}
function getTaskFullName(task) {
  return `${task.suite ? `${getTaskFullName(task.suite)} ` : ""}${task.name}`;
}
function someTasksAreOnly(suite) {
  return suite.tasks.some((t2) => t2.mode === "only" || t2.type === "suite" && someTasksAreOnly(t2));
}
function skipAllTasks(suite) {
  suite.tasks.forEach((t2) => {
    if (t2.mode === "run" || t2.mode === "queued") {
      t2.mode = "skip";
      if (t2.type === "suite") {
        skipAllTasks(t2);
      }
    }
  });
}
function todoAllTasks(suite) {
  suite.tasks.forEach((t2) => {
    if (t2.mode === "run" || t2.mode === "queued") {
      t2.mode = "todo";
      if (t2.type === "suite") {
        todoAllTasks(t2);
      }
    }
  });
}
function checkAllowOnly(task, allowOnly) {
  if (allowOnly) {
    return;
  }
  const error = processError(new Error("[Vitest] Unexpected .only modifier. Remove it or pass --allowOnly argument to bypass this error"));
  task.result = {
    state: "fail",
    errors: [error]
  };
}
function generateHash(str) {
  let hash = 0;
  if (str.length === 0) {
    return `${hash}`;
  }
  for (let i2 = 0; i2 < str.length; i2++) {
    const char = str.charCodeAt(i2);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return `${hash}`;
}
function calculateSuiteHash(parent) {
  parent.tasks.forEach((t2, idx) => {
    t2.id = `${parent.id}_${idx}`;
    if (t2.type === "suite") {
      calculateSuiteHash(t2);
    }
  });
}
function createFileTask(filepath, root, projectName, pool) {
  const path = relative(root, filepath);
  const file = {
    id: generateFileHash(path, projectName),
    name: path,
    type: "suite",
    mode: "queued",
    filepath,
    tasks: [],
    meta: /* @__PURE__ */ Object.create(null),
    projectName,
    file: void 0,
    pool
  };
  file.file = file;
  return file;
}
function generateFileHash(file, projectName) {
  return generateHash(`${file}${projectName || ""}`);
}
function limitConcurrency(concurrency = Infinity) {
  let count = 0;
  let head;
  let tail;
  const finish = () => {
    count--;
    if (head) {
      head[0]();
      head = head[1];
      tail = head && tail;
    }
  };
  return (func, ...args) => {
    return new Promise((resolve5) => {
      if (count++ < concurrency) {
        resolve5();
      } else if (tail) {
        tail = tail[1] = [resolve5];
      } else {
        head = tail = [resolve5];
      }
    }).then(() => {
      return func(...args);
    }).finally(finish);
  };
}
function isTestCase(s) {
  return s.type === "test";
}
function getTests(suite) {
  const tests = [];
  const arraySuites = toArray(suite);
  for (const s of arraySuites) {
    if (isTestCase(s)) {
      tests.push(s);
    } else {
      for (const task of s.tasks) {
        if (isTestCase(task)) {
          tests.push(task);
        } else {
          const taskTests = getTests(task);
          for (const test2 of taskTests) {
            tests.push(test2);
          }
        }
      }
    }
  }
  return tests;
}
function getTasks(tasks = []) {
  return toArray(tasks).flatMap((s) => isTestCase(s) ? [s] : [s, ...getTasks(s.tasks)]);
}
function getSuites(suite) {
  return toArray(suite).flatMap((s) => s.type === "suite" ? [s, ...getSuites(s.tasks)] : []);
}
function hasFailed(suite) {
  return toArray(suite).some((s) => {
    var _s$result;
    return ((_s$result = s.result) === null || _s$result === void 0 ? void 0 : _s$result.state) === "fail" || s.type === "suite" && hasFailed(s.tasks);
  });
}
function getNames(task) {
  const names = [task.name];
  let current = task;
  while (current === null || current === void 0 ? void 0 : current.suite) {
    current = current.suite;
    if (current === null || current === void 0 ? void 0 : current.name) {
      names.unshift(current.name);
    }
  }
  if (current !== task.file) {
    names.unshift(task.file.name);
  }
  return names;
}
function getFullName(task, separator2 = " > ") {
  return getNames(task).join(separator2);
}
function getTestName(task, separator2 = " > ") {
  return getNames(task).slice(1).join(separator2);
}

// node_modules/std-env/dist/index.mjs
var r = /* @__PURE__ */ Object.create(null);
var i = (e) => {
  var _a10, _b5;
  return ((_a10 = globalThis.process) == null ? void 0 : _a10.env) || import.meta.env || ((_b5 = globalThis.Deno) == null ? void 0 : _b5.env.toObject()) || globalThis.__env__ || (e ? r : globalThis);
};
var o = new Proxy(r, { get(e, s) {
  return i()[s] ?? r[s];
}, has(e, s) {
  const E = i();
  return s in E || s in r;
}, set(e, s, E) {
  const B = i(true);
  return B[s] = E, true;
}, deleteProperty(e, s) {
  if (!s) return false;
  const E = i(true);
  return delete E[s], true;
}, ownKeys() {
  const e = i(true);
  return Object.keys(e);
} });
var t = typeof process < "u" && process.env && "development" || "";
var f = [["APPVEYOR"], ["AWS_AMPLIFY", "AWS_APP_ID", { ci: true }], ["AZURE_PIPELINES", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"], ["AZURE_STATIC", "INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"], ["APPCIRCLE", "AC_APPCIRCLE"], ["BAMBOO", "bamboo_planKey"], ["BITBUCKET", "BITBUCKET_COMMIT"], ["BITRISE", "BITRISE_IO"], ["BUDDY", "BUDDY_WORKSPACE_ID"], ["BUILDKITE"], ["CIRCLE", "CIRCLECI"], ["CIRRUS", "CIRRUS_CI"], ["CLOUDFLARE_PAGES", "CF_PAGES", { ci: true }], ["CLOUDFLARE_WORKERS", "WORKERS_CI", { ci: true }], ["CODEBUILD", "CODEBUILD_BUILD_ARN"], ["CODEFRESH", "CF_BUILD_ID"], ["DRONE"], ["DRONE", "DRONE_BUILD_EVENT"], ["DSARI"], ["GITHUB_ACTIONS"], ["GITLAB", "GITLAB_CI"], ["GITLAB", "CI_MERGE_REQUEST_ID"], ["GOCD", "GO_PIPELINE_LABEL"], ["LAYERCI"], ["HUDSON", "HUDSON_URL"], ["JENKINS", "JENKINS_URL"], ["MAGNUM"], ["NETLIFY"], ["NETLIFY", "NETLIFY_LOCAL", { ci: false }], ["NEVERCODE"], ["RENDER"], ["SAIL", "SAILCI"], ["SEMAPHORE"], ["SCREWDRIVER"], ["SHIPPABLE"], ["SOLANO", "TDDIUM"], ["STRIDER"], ["TEAMCITY", "TEAMCITY_VERSION"], ["TRAVIS"], ["VERCEL", "NOW_BUILDER"], ["VERCEL", "VERCEL", { ci: false }], ["VERCEL", "VERCEL_ENV", { ci: false }], ["APPCENTER", "APPCENTER_BUILD_ID"], ["CODESANDBOX", "CODESANDBOX_SSE", { ci: false }], ["CODESANDBOX", "CODESANDBOX_HOST", { ci: false }], ["STACKBLITZ"], ["STORMKIT"], ["CLEAVR"], ["ZEABUR"], ["CODESPHERE", "CODESPHERE_APP_ID", { ci: true }], ["RAILWAY", "RAILWAY_PROJECT_ID"], ["RAILWAY", "RAILWAY_SERVICE_ID"], ["DENO-DEPLOY", "DENO_DEPLOYMENT_ID"], ["FIREBASE_APP_HOSTING", "FIREBASE_APP_HOSTING", { ci: true }]];
function b() {
  var _a10, _b5, _c, _d, _e, _f;
  if ((_a10 = globalThis.process) == null ? void 0 : _a10.env) for (const e of f) {
    const s = e[1] || e[0];
    if ((_b5 = globalThis.process) == null ? void 0 : _b5.env[s]) return { name: e[0].toLowerCase(), ...e[2] };
  }
  return ((_d = (_c = globalThis.process) == null ? void 0 : _c.env) == null ? void 0 : _d.SHELL) === "/bin/jsh" && ((_f = (_e = globalThis.process) == null ? void 0 : _e.versions) == null ? void 0 : _f.webcontainer) ? { name: "stackblitz", ci: false } : { name: "", ci: false };
}
var l = b();
var p = l.name;
function n(e) {
  return e ? e !== "false" : false;
}
var _a;
var I = ((_a = globalThis.process) == null ? void 0 : _a.platform) || "";
var T = n(o.CI) || l.ci !== false;
var _a2, _b;
var R = n(((_a2 = globalThis.process) == null ? void 0 : _a2.stdout) && ((_b = globalThis.process) == null ? void 0 : _b.stdout.isTTY));
var d = n(o.DEBUG);
var a = t === "test" || n(o.TEST);
var v = n(o.MINIMAL) || T || a || !R;
var A = /^win/i.test(I);
var M = /^linux/i.test(I);
var m = /^darwin/i.test(I);
var Y = !n(o.NO_COLOR) && (n(o.FORCE_COLOR) || (R || A) && o.TERM !== "dumb" || T);
var _a3, _b2;
var C2 = (((_b2 = (_a3 = globalThis.process) == null ? void 0 : _a3.versions) == null ? void 0 : _b2.node) || "").replace(/^v/, "") || null;
var V = Number(C2 == null ? void 0 : C2.split(".")[0]) || null;
var W = globalThis.process || /* @__PURE__ */ Object.create(null);
var _ = { versions: {} };
var y = new Proxy(W, { get(e, s) {
  if (s === "env") return o;
  if (s in e) return e[s];
  if (s in _) return _[s];
} });
var _a4, _b3;
var O = ((_b3 = (_a4 = globalThis.process) == null ? void 0 : _a4.release) == null ? void 0 : _b3.name) === "node";
var _a5, _b4;
var c = !!globalThis.Bun || !!((_b4 = (_a5 = globalThis.process) == null ? void 0 : _a5.versions) == null ? void 0 : _b4.bun);
var D = !!globalThis.Deno;
var L = !!globalThis.fastly;
var S = !!globalThis.Netlify;
var u = !!globalThis.EdgeRuntime;
var _a6;
var N = ((_a6 = globalThis.navigator) == null ? void 0 : _a6.userAgent) === "Cloudflare-Workers";
var F = [[S, "netlify"], [u, "edge-light"], [N, "workerd"], [L, "fastly"], [D, "deno"], [c, "bun"], [O, "node"]];
function G() {
  const e = F.find((s) => s[0]);
  if (e) return { name: e[1] };
}
var P = G();
var K = (P == null ? void 0 : P.name) || "";

// node_modules/vitest/dist/chunks/env.D4Lgay0q.js
var _a7;
var isNode = typeof process < "u" && typeof process.stdout < "u" && !((_a7 = process.versions) == null ? void 0 : _a7.deno) && !globalThis.window;
var _a8;
var isDeno = typeof process < "u" && typeof process.stdout < "u" && ((_a8 = process.versions) == null ? void 0 : _a8.deno) !== void 0;
var isWindows = (isNode || isDeno) && process.platform === "win32";
var _a9;
var isTTY = (isNode || isDeno) && ((_a9 = process.stdout) == null ? void 0 : _a9.isTTY) && !T;

// node_modules/vitest/dist/chunks/index.CcRZ6fUh.js
var import_node_util = __toESM(require_node_util(), 1);
var import_node_console = __toESM(require_node_console(), 1);
var import_node_stream = __toESM(require_node_stream(), 1);
var import_node_os = __toESM(require_node_os(), 1);

// node_modules/vitest/dist/path.js
var import_node_path = __toESM(require_node_path(), 1);
var import_node_url = __toESM(require_node_url(), 1);
var rootDir = (0, import_node_path.resolve)(import_node_url.default.fileURLToPath(import.meta.url), "../../");
var distDir = (0, import_node_path.resolve)(import_node_url.default.fileURLToPath(import.meta.url), "../../dist");

// node_modules/vitest/node_modules/vite/dist/node/index.js
var node_exports = {};
__export(node_exports, {
  BuildEnvironment: () => BuildEnvironment,
  DevEnvironment: () => DevEnvironment,
  build: () => build$1,
  buildErrorMessage: () => buildErrorMessage,
  createBuilder: () => createBuilder,
  createFetchableDevEnvironment: () => createFetchableDevEnvironment,
  createFilter: () => createFilter,
  createIdResolver: () => createIdResolver,
  createLogger: () => createLogger,
  createRunnableDevEnvironment: () => createRunnableDevEnvironment,
  createServer: () => createServer$2,
  createServerHotChannel: () => createServerHotChannel,
  createServerModuleRunner: () => createServerModuleRunner,
  createServerModuleRunnerTransport: () => createServerModuleRunnerTransport,
  defaultAllowedOrigins: () => defaultAllowedOrigins,
  defaultClientConditions: () => DEFAULT_CLIENT_CONDITIONS,
  defaultClientMainFields: () => DEFAULT_CLIENT_MAIN_FIELDS,
  defaultExternalConditions: () => DEFAULT_EXTERNAL_CONDITIONS,
  defaultServerConditions: () => DEFAULT_SERVER_CONDITIONS,
  defaultServerMainFields: () => DEFAULT_SERVER_MAIN_FIELDS,
  defineConfig: () => defineConfig,
  esbuildVersion: () => import_esbuild.version,
  fetchModule: () => fetchModule,
  formatPostcssSourceMap: () => formatPostcssSourceMap,
  isCSSRequest: () => isCSSRequest,
  isFetchableDevEnvironment: () => isFetchableDevEnvironment,
  isFileLoadingAllowed: () => isFileLoadingAllowed,
  isFileServingAllowed: () => isFileServingAllowed,
  isRunnableDevEnvironment: () => isRunnableDevEnvironment,
  loadConfigFromFile: () => loadConfigFromFile,
  loadEnv: () => loadEnv,
  mergeAlias: () => mergeAlias,
  mergeConfig: () => mergeConfig,
  moduleRunnerTransform: () => ssrTransform,
  normalizePath: () => normalizePath,
  optimizeDeps: () => optimizeDeps,
  parseAst: () => parseAst,
  parseAstAsync: () => parseAstAsync,
  perEnvironmentPlugin: () => perEnvironmentPlugin,
  perEnvironmentState: () => perEnvironmentState,
  preprocessCSS: () => preprocessCSS,
  preview: () => preview,
  resolveConfig: () => resolveConfig,
  resolveEnvPrefix: () => resolveEnvPrefix,
  rollupVersion: () => rollupVersion,
  runnerImport: () => runnerImport,
  searchForWorkspaceRoot: () => searchForWorkspaceRoot,
  send: () => send,
  sortUserPlugins: () => sortUserPlugins,
  transformWithEsbuild: () => transformWithEsbuild,
  version: () => VERSION
});
var import_esbuild = __toESM(require_main());
function createFetchableDevEnvironment(name, config, context) {
  if (typeof Request === "undefined" || typeof Response === "undefined") throw new TypeError("FetchableDevEnvironment requires a global `Request` and `Response` object.");
  if (!context.handleRequest) throw new TypeError("FetchableDevEnvironment requires a `handleRequest` method during initialisation.");
  return new FetchableDevEnvironment(name, config, context);
}
function isFetchableDevEnvironment(environment) {
  return environment instanceof FetchableDevEnvironment;
}
var FetchableDevEnvironment = class extends DevEnvironment {
  constructor(name, config, context) {
    super(name, config, context);
    __publicField(this, "_handleRequest");
    this._handleRequest = context.handleRequest;
  }
  async dispatchFetch(request) {
    if (!(request instanceof Request)) throw new TypeError("FetchableDevEnvironment `dispatchFetch` must receive a `Request` object.");
    const response = await this._handleRequest(request);
    if (!(response instanceof Response)) throw new TypeError("FetchableDevEnvironment `context.handleRequest` must return a `Response` object.");
    return response;
  }
};

// node_modules/@vitest/utils/dist/offset.js
var lineSplitRE = /\r?\n/;
function positionToOffset(source, lineNumber, columnNumber) {
  const lines = source.split(lineSplitRE);
  const nl = /\r\n/.test(source) ? 2 : 1;
  let start = 0;
  if (lineNumber > lines.length) {
    return source.length;
  }
  for (let i2 = 0; i2 < lineNumber - 1; i2++) {
    start += lines[i2].length + nl;
  }
  return start + columnNumber;
}

// node_modules/vitest/dist/chunks/index.CcRZ6fUh.js
var import_node_module = __toESM(require_node_module(), 1);
var { parse: $parse, stringify: $stringify } = JSON;
var { keys } = Object;
var Primitive = String;
var primitive = "string";
var ignore$1 = {};
var object = "object";
var noop2 = (_2, value) => value;
var primitives = (value) => value instanceof Primitive ? Primitive(value) : value;
var Primitives = (_2, value) => typeof value === primitive ? new Primitive(value) : value;
var revive = (input, parsed, output, $) => {
  const lazy = [];
  for (let ke = keys(output), { length } = ke, y2 = 0; y2 < length; y2++) {
    const k = ke[y2];
    const value = output[k];
    if (value instanceof Primitive) {
      const tmp = input[value];
      if (typeof tmp === object && !parsed.has(tmp)) {
        parsed.add(tmp);
        output[k] = ignore$1;
        lazy.push({ k, a: [input, parsed, tmp, $] });
      } else
        output[k] = $.call(output, k, tmp);
    } else if (output[k] !== ignore$1)
      output[k] = $.call(output, k, value);
  }
  for (let { length } = lazy, i2 = 0; i2 < length; i2++) {
    const { k, a: a2 } = lazy[i2];
    output[k] = $.call(output, k, revive.apply(null, a2));
  }
  return output;
};
var set = (known, input, value) => {
  const index2 = Primitive(input.push(value) - 1);
  known.set(value, index2);
  return index2;
};
var parse$1 = (text, reviver) => {
  const input = $parse(text, Primitives).map(primitives);
  const value = input[0];
  const $ = reviver || noop2;
  const tmp = typeof value === object && value ? revive(input, /* @__PURE__ */ new Set(), value, $) : value;
  return $.call({ "": tmp }, "", tmp);
};
var stringify2 = (value, replacer, space) => {
  const $ = replacer && typeof replacer === object ? (k, v2) => k === "" || -1 < replacer.indexOf(k) ? v2 : void 0 : replacer || noop2;
  const known = /* @__PURE__ */ new Map();
  const input = [];
  const output = [];
  let i2 = +set(known, input, $.call({ "": value }, "", value));
  let firstRun = !i2;
  while (i2 < input.length) {
    firstRun = true;
    output[i2] = $stringify(input[i2++], replace, space);
  }
  return "[" + output.join(",") + "]";
  function replace(key, value2) {
    if (firstRun) {
      firstRun = !firstRun;
      return value2;
    }
    const after = $.call(this, key, value2);
    switch (typeof after) {
      case object:
        if (after === null) return after;
      case primitive:
        return known.get(after) || set(known, input, after);
    }
    return after;
  }
};
function getOutputFile(config, reporter) {
  if (config == null ? void 0 : config.outputFile) return typeof config.outputFile === "string" ? config.outputFile : config.outputFile[reporter];
}
function createDefinesScript(define) {
  return !define || serializeDefine(define) === "{}" ? "" : `
const defines = ${serializeDefine(define)}
Object.keys(defines).forEach((key) => {
  const segments = key.split('.')
  let target = globalThis
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i]
    if (i === segments.length - 1) {
      target[segment] = defines[key]
    } else {
      target = target[segment] || (target[segment] = {})
    }
  }
})
  `;
}
function serializeDefine(define) {
  const userDefine = {};
  for (const key in define) {
    if (key === "process.env.NODE_ENV" && define[key] === "process.env.NODE_ENV") continue;
    if (!key.startsWith("import.meta.env.")) userDefine[key] = define[key];
  }
  let res = `{`;
  const keys2 = Object.keys(userDefine).sort();
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const key = keys2[i2], val = userDefine[key];
    if (res += `${JSON.stringify(key)}: ${handleDefineValue(val)}`, i2 !== keys2.length - 1) res += `, `;
  }
  return `${res}}`;
}
function handleDefineValue(value) {
  return typeof value === "undefined" ? "undefined" : typeof value === "string" ? value : JSON.stringify(value);
}
var BlobReporter = class {
  constructor(options) {
    __publicField(this, "start", 0);
    __publicField(this, "ctx");
    __publicField(this, "options");
    __publicField(this, "coverage");
    this.options = options;
  }
  onInit(ctx) {
    if (ctx.config.watch) throw new Error("Blob reporter is not supported in watch mode");
    this.ctx = ctx, this.start = performance.now(), this.coverage = void 0;
  }
  onCoverage(coverage) {
    this.coverage = coverage;
  }
  async onTestRunEnd(testModules, unhandledErrors) {
    const executionTime2 = performance.now() - this.start, files = testModules.map((testModule) => testModule.task), errors = [...unhandledErrors], coverage = this.coverage;
    let outputFile = this.options.outputFile ?? getOutputFile(this.ctx.config, "blob");
    if (!outputFile) {
      const shard = this.ctx.config.shard;
      outputFile = shard ? `.vitest-reports/blob-${shard.index}-${shard.count}.json` : ".vitest-reports/blob.json";
    }
    const modules = this.ctx.projects.map((project) => {
      return [project.name, [...project.vite.moduleGraph.idToModuleMap.entries()].map((mod) => {
        return mod[1].file ? [
          mod[0],
          mod[1].file,
          mod[1].url
        ] : null;
      }).filter((x) => x != null)];
    }), report = [
      this.ctx.version,
      files,
      errors,
      modules,
      coverage,
      executionTime2
    ], reportFile = resolve(this.ctx.config.root, outputFile);
    await writeBlob(report, reportFile), this.ctx.logger.log("blob report written to", reportFile);
  }
};
async function writeBlob(content, filename) {
  const report = stringify2(content), dir = dirname(filename);
  if (!(0, import_node_fs.existsSync)(dir)) await (0, import_promises.mkdir)(dir, { recursive: true });
  await (0, import_promises.writeFile)(filename, report, "utf-8");
}
async function readBlobs(currentVersion, blobsDirectory, projectsArray) {
  const resolvedDir = resolve(process.cwd(), blobsDirectory), promises2 = (await (0, import_promises.readdir)(resolvedDir)).map(async (filename) => {
    const fullPath = resolve(resolvedDir, filename);
    if (!(await (0, import_promises.stat)(fullPath)).isFile()) throw new TypeError(`vitest.mergeReports() expects all paths in "${blobsDirectory}" to be files generated by the blob reporter, but "${filename}" is not a file`);
    const content = await (0, import_promises.readFile)(fullPath, "utf-8"), [version, files2, errors2, moduleKeys, coverage, executionTime2] = parse$1(content);
    if (!version) throw new TypeError(`vitest.mergeReports() expects all paths in "${blobsDirectory}" to be files generated by the blob reporter, but "${filename}" is not a valid blob file`);
    return {
      version,
      files: files2,
      errors: errors2,
      moduleKeys,
      coverage,
      file: filename,
      executionTime: executionTime2
    };
  }), blobs = await Promise.all(promises2);
  if (!blobs.length) throw new Error(`vitest.mergeReports() requires at least one blob file in "${blobsDirectory}" directory, but none were found`);
  const versions = new Set(blobs.map((blob) => blob.version));
  if (versions.size > 1) throw new Error(`vitest.mergeReports() requires all blob files to be generated by the same Vitest version, received

${blobs.map((b2) => `- "${b2.file}" uses v${b2.version}`).join("\n")}`);
  if (!versions.has(currentVersion)) throw new Error(`the blobs in "${blobsDirectory}" were generated by a different version of Vitest. Expected v${currentVersion}, but received v${blobs[0].version}`);
  const projects = Object.fromEntries(projectsArray.map((p2) => [p2.name, p2]));
  blobs.forEach((blob) => {
    blob.moduleKeys.forEach(([projectName, moduleIds]) => {
      const project = projects[projectName];
      project && moduleIds.forEach(([moduleId, file, url2]) => {
        const moduleNode = project.vite.moduleGraph.createFileOnlyEntry(file);
        moduleNode.url = url2, moduleNode.id = moduleId, moduleNode.transformResult = {
          code: " ",
          map: null
        }, project.vite.moduleGraph.idToModuleMap.set(moduleId, moduleNode);
      });
    });
  });
  const files = blobs.flatMap((blob) => blob.files).sort((f1, f2) => {
    var _a10, _b5;
    const time1 = ((_a10 = f1.result) == null ? void 0 : _a10.startTime) || 0, time2 = ((_b5 = f2.result) == null ? void 0 : _b5.startTime) || 0;
    return time1 - time2;
  }), errors = blobs.flatMap((blob) => blob.errors), coverages = blobs.map((blob) => blob.coverage), executionTimes = blobs.map((blob) => blob.executionTime);
  return {
    files,
    errors,
    coverages,
    executionTimes
  };
}
function hasFailedSnapshot(suite) {
  return getTests(suite).some((s) => {
    var _a10, _b5;
    return (_b5 = (_a10 = s.result) == null ? void 0 : _a10.errors) == null ? void 0 : _b5.some((e) => typeof (e == null ? void 0 : e.message) === "string" && e.message.match(/Snapshot .* mismatched/));
  });
}
function convertTasksToEvents(file, onTask) {
  const packs = [], events = [];
  function visit(suite) {
    onTask == null ? void 0 : onTask(suite), packs.push([
      suite.id,
      suite.result,
      suite.meta
    ]), events.push([
      suite.id,
      "suite-prepare",
      void 0
    ]), suite.tasks.forEach((task) => {
      if (task.type === "suite") visit(task);
      else if (onTask == null ? void 0 : onTask(task), suite.mode !== "skip" && suite.mode !== "todo") packs.push([
        task.id,
        task.result,
        task.meta
      ]), events.push([
        task.id,
        "test-prepare",
        void 0
      ]), task.annotations.forEach((annotation) => {
        events.push([
          task.id,
          "test-annotation",
          { annotation }
        ]);
      }), events.push([
        task.id,
        "test-finished",
        void 0
      ]);
    }), events.push([
      suite.id,
      "suite-finished",
      void 0
    ]);
  }
  return visit(file), {
    packs,
    events
  };
}
var F_RIGHT = "→";
var F_DOWN = "↓";
var F_DOWN_RIGHT = "↳";
var F_POINTER = "❯";
var F_DOT = "·";
var F_CHECK = "✓";
var F_CROSS = "×";
var F_LONG_DASH = "⎯";
var F_TREE_NODE_MIDDLE = "├──";
var F_TREE_NODE_END = "└──";
var pointer = C.yellow(F_POINTER);
var skipped = C.dim(C.gray(F_DOWN));
var benchmarkPass = C.green(F_DOT);
var testPass = C.green(F_CHECK);
var taskFail = C.red(F_CROSS);
var suiteFail = C.red(F_POINTER);
var pending$1 = C.gray("·");
var separator = C.dim(" > ");
var labelDefaultColors = [
  C.bgYellow,
  C.bgCyan,
  C.bgGreen,
  C.bgMagenta
];
function getCols(delta = 0) {
  var _a10;
  let length = (_a10 = process.stdout) == null ? void 0 : _a10.columns;
  if (!length || Number.isNaN(length)) length = 30;
  return Math.max(length + delta, 0);
}
function errorBanner(message) {
  return divider(C.bold(C.bgRed(` ${message} `)), null, null, C.red);
}
function divider(text, left, right, color) {
  const cols = getCols(), c2 = color || ((text2) => text2);
  if (text) {
    const textLength = (0, import_node_util.stripVTControlCharacters)(text).length;
    if (left == null && right != null) left = cols - textLength - right;
    else left = left ?? Math.floor((cols - textLength) / 2), right = cols - textLength - left;
    return left = Math.max(0, left), right = Math.max(0, right), `${c2(F_LONG_DASH.repeat(left))}${text}${c2(F_LONG_DASH.repeat(right))}`;
  }
  return F_LONG_DASH.repeat(cols);
}
function formatTestPath(root, path) {
  var _a10;
  if (isAbsolute(path)) path = relative(root, path);
  const dir = dirname(path), ext = ((_a10 = path.match(/(\.(spec|test)\.[cm]?[tj]sx?)$/)) == null ? void 0 : _a10[0]) || "", base2 = basename(path, ext);
  return slash(C.dim(`${dir}/`) + C.bold(base2)) + C.dim(ext);
}
function renderSnapshotSummary(rootDir2, snapshots) {
  const summary = [];
  if (snapshots.added) summary.push(C.bold(C.green(`${snapshots.added} written`)));
  if (snapshots.unmatched) summary.push(C.bold(C.red(`${snapshots.unmatched} failed`)));
  if (snapshots.updated) summary.push(C.bold(C.green(`${snapshots.updated} updated `)));
  if (snapshots.filesRemoved) if (snapshots.didUpdate) summary.push(C.bold(C.green(`${snapshots.filesRemoved} files removed `)));
  else summary.push(C.bold(C.yellow(`${snapshots.filesRemoved} files obsolete `)));
  if (snapshots.filesRemovedList && snapshots.filesRemovedList.length) {
    const [head, ...tail] = snapshots.filesRemovedList;
    summary.push(`${C.gray(F_DOWN_RIGHT)} ${formatTestPath(rootDir2, head)}`), tail.forEach((key) => {
      summary.push(`  ${C.gray(F_DOT)} ${formatTestPath(rootDir2, key)}`);
    });
  }
  if (snapshots.unchecked) {
    if (snapshots.didUpdate) summary.push(C.bold(C.green(`${snapshots.unchecked} removed`)));
    else summary.push(C.bold(C.yellow(`${snapshots.unchecked} obsolete`)));
    snapshots.uncheckedKeysByFile.forEach((uncheckedFile) => {
      summary.push(`${C.gray(F_DOWN_RIGHT)} ${formatTestPath(rootDir2, uncheckedFile.filePath)}`), uncheckedFile.keys.forEach((key) => summary.push(`  ${C.gray(F_DOT)} ${key}`));
    });
  }
  return summary;
}
function countTestErrors(tasks) {
  return tasks.reduce((c2, i2) => {
    var _a10, _b5;
    return c2 + (((_b5 = (_a10 = i2.result) == null ? void 0 : _a10.errors) == null ? void 0 : _b5.length) || 0);
  }, 0);
}
function getStateString$1(tasks, name = "tests", showTotal = true) {
  if (tasks.length === 0) return C.dim(`no ${name}`);
  const passed = tasks.filter((i2) => {
    var _a10;
    return ((_a10 = i2.result) == null ? void 0 : _a10.state) === "pass";
  }), failed = tasks.filter((i2) => {
    var _a10;
    return ((_a10 = i2.result) == null ? void 0 : _a10.state) === "fail";
  }), skipped2 = tasks.filter((i2) => i2.mode === "skip"), todo = tasks.filter((i2) => i2.mode === "todo");
  return [
    failed.length ? C.bold(C.red(`${failed.length} failed`)) : null,
    passed.length ? C.bold(C.green(`${passed.length} passed`)) : null,
    skipped2.length ? C.yellow(`${skipped2.length} skipped`) : null,
    todo.length ? C.gray(`${todo.length} todo`) : null
  ].filter(Boolean).join(C.dim(" | ")) + (showTotal ? C.gray(` (${tasks.length})`) : "");
}
function getStateSymbol(task) {
  var _a10;
  if (task.mode === "skip" || task.mode === "todo") return skipped;
  if (!task.result) return pending$1;
  if (task.result.state === "run" || task.result.state === "queued") {
    if (task.type === "suite") return pointer;
  }
  return task.result.state === "pass" ? ((_a10 = task.meta) == null ? void 0 : _a10.benchmark) ? benchmarkPass : testPass : task.result.state === "fail" ? task.type === "suite" ? suiteFail : taskFail : " ";
}
function formatTimeString(date) {
  return date.toTimeString().split(" ")[0];
}
function formatTime(time) {
  return time > 1e3 ? `${(time / 1e3).toFixed(2)}s` : `${Math.round(time)}ms`;
}
function formatProjectName(project, suffix = " ") {
  if (!(project == null ? void 0 : project.name)) return "";
  if (!C.isColorSupported) return `|${project.name}|${suffix}`;
  let background = project.color && C[`bg${capitalize(project.color)}`];
  if (!background) {
    const index2 = project.name.split("").reduce((acc, v2, idx) => acc + v2.charCodeAt(0) + idx, 0);
    background = labelDefaultColors[index2 % labelDefaultColors.length];
  }
  return C.black(background(` ${project.name} `)) + suffix;
}
function withLabel(color, label, message) {
  const bgColor = `bg${color.charAt(0).toUpperCase()}${color.slice(1)}`;
  return `${C.bold(C[bgColor](` ${label} `))} ${message ? C[color](message) : ""}`;
}
function padSummaryTitle(str) {
  return C.dim(`${str.padStart(11)} `);
}
function truncateString(text, maxLength) {
  const plainText = (0, import_node_util.stripVTControlCharacters)(text);
  return plainText.length <= maxLength ? text : `${plainText.slice(0, maxLength - 1)}…`;
}
function capitalize(text) {
  return `${text[0].toUpperCase()}${text.slice(1)}`;
}
var utils = Object.freeze({
  __proto__: null,
  benchmarkPass,
  countTestErrors,
  divider,
  errorBanner,
  formatProjectName,
  formatTestPath,
  formatTime,
  formatTimeString,
  getStateString: getStateString$1,
  getStateSymbol,
  padSummaryTitle,
  pending: pending$1,
  pointer,
  renderSnapshotSummary,
  separator,
  skipped,
  suiteFail,
  taskFail,
  testPass,
  truncateString,
  withLabel
});
var BADGE_PADDING = "       ";
var BaseReporter = class {
  constructor(options = {}) {
    __publicField(this, "start", 0);
    __publicField(this, "end", 0);
    __publicField(this, "watchFilters");
    __publicField(this, "failedUnwatchedFiles", []);
    __publicField(this, "isTTY");
    __publicField(this, "ctx");
    __publicField(this, "renderSucceed", false);
    __publicField(this, "verbose", false);
    __publicField(this, "_filesInWatchMode", /* @__PURE__ */ new Map());
    __publicField(this, "_timeStart", formatTimeString(/* @__PURE__ */ new Date()));
    this.isTTY = options.isTTY ?? isTTY;
  }
  onInit(ctx) {
    this.ctx = ctx, this.ctx.logger.printBanner(), this.start = import_node_perf_hooks.performance.now();
  }
  log(...messages) {
    this.ctx.logger.log(...messages);
  }
  error(...messages) {
    this.ctx.logger.error(...messages);
  }
  relative(path) {
    return relative(this.ctx.config.root, path);
  }
  onTestRunEnd(testModules, unhandledErrors, _reason) {
    const files = testModules.map((testModule) => testModule.task), errors = [...unhandledErrors];
    if (this.end = import_node_perf_hooks.performance.now(), !files.length && !errors.length) this.ctx.logger.printNoTestFound(this.ctx.filenamePattern);
    else this.reportSummary(files, errors);
  }
  onTestCaseResult(testCase) {
    if (testCase.result().state === "failed") this.logFailedTask(testCase.task);
  }
  onTestSuiteResult(testSuite) {
    if (testSuite.state() === "failed") this.logFailedTask(testSuite.task);
  }
  onTestModuleEnd(testModule) {
    if (testModule.state() === "failed") this.logFailedTask(testModule.task);
    this.printTestModule(testModule);
  }
  logFailedTask(task) {
    if (this.ctx.config.silent === "passed-only") for (const log of task.logs || []) this.onUserConsoleLog(log, "failed");
  }
  printTestModule(testModule) {
    const moduleState = testModule.state();
    if (moduleState === "queued" || moduleState === "pending") return;
    let testsCount = 0, failedCount = 0, skippedCount = 0;
    const logs = [], originalLog = this.log.bind(this);
    this.log = (msg) => logs.push(msg);
    const visit = (suiteState, children) => {
      for (const child of children) if (child.type === "suite") {
        const suiteState2 = child.state();
        if (!this.ctx.config.hideSkippedTests || suiteState2 !== "skipped") this.printTestSuite(child);
        visit(suiteState2, child.children);
      } else {
        const testResult = child.result();
        if (testsCount++, testResult.state === "failed") failedCount++;
        else if (testResult.state === "skipped") skippedCount++;
        if (this.ctx.config.hideSkippedTests && suiteState === "skipped")
          continue;
        this.printTestCase(moduleState, child);
      }
    };
    try {
      visit(moduleState, testModule.children);
    } finally {
      this.log = originalLog;
    }
    this.log(this.getModuleLog(testModule, {
      tests: testsCount,
      failed: failedCount,
      skipped: skippedCount
    })), logs.forEach((log) => this.log(log));
  }
  printTestCase(moduleState, test2) {
    const testResult = test2.result(), { duration = 0 } = test2.diagnostic() || {}, padding = this.getTestIndentation(test2.task), suffix = this.getTestCaseSuffix(test2);
    if (testResult.state === "failed") this.log(C.red(` ${padding}${taskFail} ${this.getTestName(test2.task, separator)}`) + suffix);
    else if (duration > this.ctx.config.slowTestThreshold) this.log(` ${padding}${C.yellow(C.dim(F_CHECK))} ${this.getTestName(test2.task, separator)} ${suffix}`);
    else if (this.ctx.config.hideSkippedTests && testResult.state === "skipped") ;
    else if (this.renderSucceed || moduleState === "failed") this.log(` ${padding}${this.getStateSymbol(test2)} ${this.getTestName(test2.task, separator)}${suffix}`);
  }
  getModuleLog(testModule, counts) {
    let state = C.dim(`${counts.tests} test${counts.tests > 1 ? "s" : ""}`);
    if (counts.failed) state += C.dim(" | ") + C.red(`${counts.failed} failed`);
    if (counts.skipped) state += C.dim(" | ") + C.yellow(`${counts.skipped} skipped`);
    let suffix = C.dim("(") + state + C.dim(")") + this.getDurationPrefix(testModule.task);
    const diagnostic = testModule.diagnostic();
    if (diagnostic.heap != null) suffix += C.magenta(` ${Math.floor(diagnostic.heap / 1024 / 1024)} MB heap used`);
    return ` ${this.getEntityPrefix(testModule)} ${testModule.task.name} ${suffix}`;
  }
  printTestSuite(testSuite) {
    if (!this.renderSucceed) return;
    const indentation = "  ".repeat(getIndentation(testSuite.task)), tests = Array.from(testSuite.children.allTests()), state = this.getStateSymbol(testSuite);
    this.log(` ${indentation}${state} ${testSuite.name} ${C.dim(`(${tests.length})`)}`);
  }
  getTestName(test2, _separator) {
    return test2.name;
  }
  getFullName(test2, separator2) {
    if (test2 === test2.file) return test2.name;
    let name = test2.file.name;
    if (test2.location) name += C.dim(`:${test2.location.line}:${test2.location.column}`);
    return name += separator2, name += getTestName(test2, separator2), name;
  }
  getTestIndentation(test2) {
    return "  ".repeat(getIndentation(test2));
  }
  printAnnotations(test2, console2, padding = 0) {
    const annotations = test2.annotations();
    if (!annotations.length) return;
    const PADDING = " ".repeat(padding), groupedAnnotations = {};
    for (const group in annotations.forEach((annotation) => {
      const { location, type } = annotation;
      let group2;
      if (location) {
        const file = relative(test2.project.config.root, location.file);
        group2 = `${C.gray(`${file}:${location.line}:${location.column}`)} ${C.bold(type)}`;
      } else group2 = C.bold(type);
      groupedAnnotations[group2] ?? (groupedAnnotations[group2] = []), groupedAnnotations[group2].push(annotation);
    }), groupedAnnotations) this[console2](`${PADDING}${C.blue(F_POINTER)} ${group}`), groupedAnnotations[group].forEach(({ message }) => {
      this[console2](`${PADDING}  ${C.blue(F_DOWN_RIGHT)} ${message}`);
    });
  }
  getEntityPrefix(entity) {
    let title = this.getStateSymbol(entity);
    if (entity.project.name) title += ` ${formatProjectName(entity.project, "")}`;
    if (entity.meta().typecheck) title += ` ${C.bgBlue(C.bold(" TS "))}`;
    return title;
  }
  getTestCaseSuffix(testCase) {
    const { heap, retryCount, repeatCount } = testCase.diagnostic() || {}, testResult = testCase.result();
    let suffix = this.getDurationPrefix(testCase.task);
    if (retryCount != null && retryCount > 0) suffix += C.yellow(` (retry x${retryCount})`);
    if (repeatCount != null && repeatCount > 0) suffix += C.yellow(` (repeat x${repeatCount})`);
    if (heap != null) suffix += C.magenta(` ${Math.floor(heap / 1024 / 1024)} MB heap used`);
    if (testResult.state === "skipped" && testResult.note) suffix += C.dim(C.gray(` [${testResult.note}]`));
    return suffix;
  }
  getStateSymbol(test2) {
    return getStateSymbol(test2.task);
  }
  getDurationPrefix(task) {
    var _a10, _b5;
    const duration = ((_a10 = task.result) == null ? void 0 : _a10.duration) && Math.round((_b5 = task.result) == null ? void 0 : _b5.duration);
    return duration == null ? "" : (duration > this.ctx.config.slowTestThreshold ? C.yellow : C.green)(` ${duration}${C.dim("ms")}`);
  }
  onWatcherStart(files = this.ctx.state.getFiles(), errors = this.ctx.state.getUnhandledErrors()) {
    if (errors.length > 0 || hasFailed(files)) this.log(withLabel("red", "FAIL", "Tests failed. Watching for file changes..."));
    else if (this.ctx.isCancelling) this.log(withLabel("red", "CANCELLED", "Test run cancelled. Watching for file changes..."));
    else this.log(withLabel("green", "PASS", "Waiting for file changes..."));
    const hints = [C.dim("press ") + C.bold("h") + C.dim(" to show help")];
    if (hasFailedSnapshot(files)) hints.unshift(C.dim("press ") + C.bold(C.yellow("u")) + C.dim(" to update snapshot"));
    else hints.push(C.dim("press ") + C.bold("q") + C.dim(" to quit"));
    this.log(BADGE_PADDING + hints.join(C.dim(", ")));
  }
  onWatcherRerun(files, trigger) {
    this.watchFilters = files, this.failedUnwatchedFiles = this.ctx.state.getTestModules().filter((testModule) => !files.includes(testModule.task.filepath) && testModule.state() === "failed"), files.forEach((filepath) => {
      let reruns = this._filesInWatchMode.get(filepath) ?? 0;
      this._filesInWatchMode.set(filepath, ++reruns);
    });
    let banner = trigger ? C.dim(`${this.relative(trigger)} `) : "";
    if (files.length === 1) {
      const rerun = this._filesInWatchMode.get(files[0]) ?? 1;
      banner += C.blue(`x${rerun} `);
    }
    if (this.ctx.logger.clearFullScreen(), this.log(withLabel("blue", "RERUN", banner)), this.ctx.configOverride.project) this.log(BADGE_PADDING + C.dim(" Project name: ") + C.blue(toArray(this.ctx.configOverride.project).join(", ")));
    if (this.ctx.filenamePattern) this.log(BADGE_PADDING + C.dim(" Filename pattern: ") + C.blue(this.ctx.filenamePattern.join(", ")));
    if (this.ctx.configOverride.testNamePattern) this.log(BADGE_PADDING + C.dim(" Test name pattern: ") + C.blue(String(this.ctx.configOverride.testNamePattern)));
    this.log("");
    for (const testModule of this.failedUnwatchedFiles) this.printTestModule(testModule);
    this._timeStart = formatTimeString(/* @__PURE__ */ new Date()), this.start = import_node_perf_hooks.performance.now();
  }
  onUserConsoleLog(log, taskState) {
    var _a10;
    if (!this.shouldLog(log, taskState)) return;
    const output = log.type === "stdout" ? this.ctx.logger.outputStream : this.ctx.logger.errorStream, write = (msg) => output.write(msg);
    let headerText = "unknown test";
    const task = log.taskId ? this.ctx.state.idMap.get(log.taskId) : void 0;
    if (task) headerText = this.getFullName(task, separator);
    else if (log.taskId && log.taskId !== "__vitest__unknown_test__") headerText = log.taskId;
    if (write(C.gray(log.type + C.dim(` | ${headerText}
`)) + log.content), log.origin) {
      if (log.browser) write("\n");
      const project = task ? this.ctx.getProjectByName(task.file.projectName || "") : this.ctx.getRootProject(), stack = log.browser ? ((_a10 = project.browser) == null ? void 0 : _a10.parseStacktrace(log.origin)) || [] : parseStacktrace(log.origin), highlight = task && stack.find((i2) => i2.file === task.file.filepath);
      for (const frame of stack) {
        const color = frame === highlight ? C.cyan : C.gray, path = relative(project.config.root, frame.file), positions = [frame.method, `${path}:${C.dim(`${frame.line}:${frame.column}`)}`].filter(Boolean).join(" ");
        write(color(` ${C.dim(F_POINTER)} ${positions}
`));
      }
    }
    write("\n");
  }
  onTestRemoved(trigger) {
    this.log(C.yellow("Test removed...") + (trigger ? C.dim(` [ ${this.relative(trigger)} ]
`) : ""));
  }
  shouldLog(log, taskState) {
    if (this.ctx.config.silent === true || this.ctx.config.silent === "passed-only" && taskState !== "failed") return false;
    if (this.ctx.config.onConsoleLog) {
      const task = log.taskId ? this.ctx.state.idMap.get(log.taskId) : void 0, entity = task && this.ctx.state.getReportedEntity(task);
      if (this.ctx.config.onConsoleLog(log.content, log.type, entity) === false) return false;
    }
    return true;
  }
  onServerRestart(reason) {
    this.log(C.bold(C.magenta(reason === "config" ? "\nRestarting due to config changes..." : "\nRestarting Vitest...")));
  }
  reportSummary(files, errors) {
    if (this.printErrorsSummary(files, errors), this.ctx.config.mode === "benchmark") this.reportBenchmarkSummary(files);
    else this.reportTestSummary(files, errors);
  }
  reportTestSummary(files, errors) {
    this.log();
    const affectedFiles = [...this.failedUnwatchedFiles.map((m2) => m2.task), ...files], tests = getTests(affectedFiles), snapshotOutput = renderSnapshotSummary(this.ctx.config.root, this.ctx.snapshot.summary);
    for (const [index2, snapshot] of snapshotOutput.entries()) {
      const title = index2 === 0 ? "Snapshots" : "";
      this.log(`${padSummaryTitle(title)} ${snapshot}`);
    }
    if (snapshotOutput.length > 1) this.log();
    if (this.log(padSummaryTitle("Test Files"), getStateString$1(affectedFiles)), this.log(padSummaryTitle("Tests"), getStateString$1(tests)), this.ctx.projects.some((c2) => c2.config.typecheck.enabled)) {
      const failed = tests.filter((t2) => {
        var _a10, _b5, _c;
        return ((_a10 = t2.meta) == null ? void 0 : _a10.typecheck) && ((_c = (_b5 = t2.result) == null ? void 0 : _b5.errors) == null ? void 0 : _c.length);
      });
      this.log(padSummaryTitle("Type Errors"), failed.length ? C.bold(C.red(`${failed.length} failed`)) : C.dim("no errors"));
    }
    if (errors.length) this.log(padSummaryTitle("Errors"), C.bold(C.red(`${errors.length} error${errors.length > 1 ? "s" : ""}`)));
    this.log(padSummaryTitle("Start at"), this._timeStart);
    const collectTime = sum(files, (file) => file.collectDuration), testsTime = sum(files, (file) => {
      var _a10;
      return (_a10 = file.result) == null ? void 0 : _a10.duration;
    }), setupTime = sum(files, (file) => file.setupDuration);
    if (this.watchFilters) this.log(padSummaryTitle("Duration"), formatTime(collectTime + testsTime + setupTime));
    else {
      const blobs = this.ctx.state.blobs, executionTime2 = (blobs == null ? void 0 : blobs.executionTimes) ? sum(blobs.executionTimes, (time) => time) : this.end - this.start, environmentTime = sum(files, (file) => file.environmentLoad), prepareTime = sum(files, (file) => file.prepareDuration), transformTime = this.ctx.state.transformTime, typecheck = sum(this.ctx.projects, (project) => {
        var _a10;
        return (_a10 = project.typechecker) == null ? void 0 : _a10.getResult().time;
      }), timers = [
        `transform ${formatTime(transformTime)}`,
        `setup ${formatTime(setupTime)}`,
        `collect ${formatTime(collectTime)}`,
        `tests ${formatTime(testsTime)}`,
        `environment ${formatTime(environmentTime)}`,
        `prepare ${formatTime(prepareTime)}`,
        typecheck && `typecheck ${formatTime(typecheck)}`
      ].filter(Boolean).join(", ");
      if (this.log(padSummaryTitle("Duration"), formatTime(executionTime2) + C.dim(` (${timers})`)), blobs == null ? void 0 : blobs.executionTimes) this.log(padSummaryTitle("Per blob") + blobs.executionTimes.map((time) => ` ${formatTime(time)}`).join(""));
    }
    this.log();
  }
  printErrorsSummary(files, errors) {
    const suites = getSuites(files), tests = getTests(files), failedSuites = suites.filter((i2) => {
      var _a10;
      return (_a10 = i2.result) == null ? void 0 : _a10.errors;
    }), failedTests = tests.filter((i2) => {
      var _a10;
      return ((_a10 = i2.result) == null ? void 0 : _a10.state) === "fail";
    }), failedTotal = countTestErrors(failedSuites) + countTestErrors(failedTests);
    let current = 1;
    const errorDivider = () => this.error(`${C.red(C.dim(divider(`[${current++}/${failedTotal}]`, void 0, 1)))}
`);
    if (failedSuites.length) this.error(`
${errorBanner(`Failed Suites ${failedSuites.length}`)}
`), this.printTaskErrors(failedSuites, errorDivider);
    if (failedTests.length) this.error(`
${errorBanner(`Failed Tests ${failedTests.length}`)}
`), this.printTaskErrors(failedTests, errorDivider);
    if (errors.length) this.ctx.logger.printUnhandledErrors(errors), this.error();
  }
  reportBenchmarkSummary(files) {
    const topBenches = getTests(files).filter((i2) => {
      var _a10, _b5;
      return ((_b5 = (_a10 = i2.result) == null ? void 0 : _a10.benchmark) == null ? void 0 : _b5.rank) === 1;
    });
    this.log(`
${withLabel("cyan", "BENCH", "Summary\n")}`);
    for (const bench of topBenches) {
      const group = bench.suite || bench.file;
      if (!group) continue;
      const groupName = this.getFullName(group, separator), project = this.ctx.projects.find((p2) => p2.name === bench.file.projectName);
      this.log(`  ${formatProjectName(project)}${bench.name}${C.dim(` - ${groupName}`)}`);
      const siblings = group.tasks.filter((i2) => {
        var _a10;
        return i2.meta.benchmark && ((_a10 = i2.result) == null ? void 0 : _a10.benchmark) && i2 !== bench;
      }).sort((a2, b2) => a2.result.benchmark.rank - b2.result.benchmark.rank);
      for (const sibling of siblings) {
        const number = (sibling.result.benchmark.mean / bench.result.benchmark.mean).toFixed(2);
        this.log(C.green(`    ${number}x `) + C.gray("faster than ") + sibling.name);
      }
      this.log("");
    }
  }
  printTaskErrors(tasks, errorDivider) {
    var _a10, _b5, _c;
    const errorsQueue = [];
    for (const task of tasks)
      (_b5 = (_a10 = task.result) == null ? void 0 : _a10.errors) == null ? void 0 : _b5.forEach((error) => {
        let previous;
        if (error == null ? void 0 : error.stack) previous = errorsQueue.find((i2) => {
          var _a11, _b6, _c2, _d;
          if (((_a11 = i2[0]) == null ? void 0 : _a11.stack) !== error.stack) return false;
          const currentProjectName = (task == null ? void 0 : task.projectName) || ((_b6 = task.file) == null ? void 0 : _b6.projectName) || "", projectName = ((_c2 = i2[1][0]) == null ? void 0 : _c2.projectName) || ((_d = i2[1][0].file) == null ? void 0 : _d.projectName) || "", currentAnnotations = task.type === "test" && task.annotations, itemAnnotations = i2[1][0].type === "test" && i2[1][0].annotations;
          return projectName === currentProjectName && deepEqual(currentAnnotations, itemAnnotations);
        });
        if (previous) previous[1].push(task);
        else errorsQueue.push([error, [task]]);
      });
    for (const [error, tasks2] of errorsQueue) {
      for (const task of tasks2) {
        const filepath = (task == null ? void 0 : task.filepath) || "", projectName = (task == null ? void 0 : task.projectName) || ((_c = task.file) == null ? void 0 : _c.projectName) || "", project = this.ctx.projects.find((p2) => p2.name === projectName);
        let name = this.getFullName(task, separator);
        if (filepath) name += C.dim(` [ ${this.relative(filepath)} ]`);
        this.ctx.logger.error(`${C.bgRed(C.bold(" FAIL "))} ${formatProjectName(project)}${name}`);
      }
      const screenshotPaths = tasks2.map((t2) => {
        var _a11;
        return (_a11 = t2.meta) == null ? void 0 : _a11.failScreenshotPath;
      }).filter((screenshot) => screenshot != null);
      if (this.ctx.logger.printError(error, {
        project: this.ctx.getProjectByName(tasks2[0].file.projectName || ""),
        verbose: this.verbose,
        screenshotPaths,
        task: tasks2[0]
      }), tasks2[0].type === "test" && tasks2[0].annotations.length) {
        const test2 = this.ctx.state.getReportedEntity(tasks2[0]);
        this.printAnnotations(test2, "error", 1), this.error();
      }
      errorDivider();
    }
  }
};
function deepEqual(a2, b2) {
  if (a2 === b2) return true;
  if (typeof a2 !== "object" || typeof b2 !== "object" || a2 === null || b2 === null) return false;
  const keysA = Object.keys(a2), keysB = Object.keys(b2);
  if (keysA.length !== keysB.length) return false;
  for (const key of keysA) if (!keysB.includes(key) || !deepEqual(a2[key], b2[key])) return false;
  return true;
}
function sum(items, cb) {
  return items.reduce((total, next) => {
    return total + Math.max(cb(next) || 0, 0);
  }, 0);
}
function getIndentation(suite, level = 1) {
  return suite.suite && !("filepath" in suite.suite) ? getIndentation(suite.suite, level + 1) : level;
}
var DEFAULT_RENDER_INTERVAL_MS = 1e3;
var ESC = "\x1B[";
var CLEAR_LINE = `${ESC}K`;
var MOVE_CURSOR_ONE_ROW_UP = `${ESC}1A`;
var SYNC_START = `${ESC}?2026h`;
var SYNC_END = `${ESC}?2026l`;
var WindowRenderer = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "streams");
    __publicField(this, "buffer", []);
    __publicField(this, "renderInterval");
    __publicField(this, "renderScheduled", false);
    __publicField(this, "windowHeight", 0);
    __publicField(this, "started", false);
    __publicField(this, "finished", false);
    __publicField(this, "cleanups", []);
    this.options = {
      interval: DEFAULT_RENDER_INTERVAL_MS,
      ...options
    }, this.streams = {
      output: options.logger.outputStream.write.bind(options.logger.outputStream),
      error: options.logger.errorStream.write.bind(options.logger.errorStream)
    }, this.cleanups.push(this.interceptStream(process.stdout, "output"), this.interceptStream(process.stderr, "error")), this.options.logger.onTerminalCleanup(() => {
      this.flushBuffer(), this.stop();
    });
  }
  start() {
    this.started = true, this.finished = false, this.renderInterval = setInterval(() => this.schedule(), this.options.interval).unref();
  }
  stop() {
    this.cleanups.splice(0).map((fn) => fn()), clearInterval(this.renderInterval);
  }
  /**
  * Write all buffered output and stop buffering.
  * All intercepted writes are forwarded to actual write after this.
  */
  finish() {
    this.finished = true, this.flushBuffer(), clearInterval(this.renderInterval);
  }
  /**
  * Queue new render update
  */
  schedule() {
    if (!this.renderScheduled) this.renderScheduled = true, this.flushBuffer(), setTimeout(() => {
      this.renderScheduled = false;
    }, 100).unref();
  }
  flushBuffer() {
    if (this.buffer.length === 0) return this.render();
    let current;
    for (const next of this.buffer.splice(0)) {
      if (!current) {
        current = next;
        continue;
      }
      if (current.type !== next.type) {
        this.render(current.message, current.type), current = next;
        continue;
      }
      current.message += next.message;
    }
    if (current) this.render(current == null ? void 0 : current.message, current == null ? void 0 : current.type);
  }
  render(message, type = "output") {
    if (this.finished) return this.clearWindow(), this.write(message || "", type);
    const windowContent = this.options.getWindow(), rowCount = getRenderedRowCount(windowContent, this.options.logger.getColumns());
    let padding = this.windowHeight - rowCount;
    if (padding > 0 && message) padding -= getRenderedRowCount([message], this.options.logger.getColumns());
    if (this.write(SYNC_START), this.clearWindow(), message) this.write(message, type);
    if (padding > 0) this.write("\n".repeat(padding));
    this.write(windowContent.join("\n")), this.write(SYNC_END), this.windowHeight = rowCount + Math.max(0, padding);
  }
  clearWindow() {
    if (this.windowHeight !== 0) {
      this.write(CLEAR_LINE);
      for (let i2 = 1; i2 < this.windowHeight; i2++) this.write(`${MOVE_CURSOR_ONE_ROW_UP}${CLEAR_LINE}`);
      this.windowHeight = 0;
    }
  }
  interceptStream(stream, type) {
    const original = stream.write;
    return stream.write = (chunk, _2, callback) => {
      if (chunk) if (this.finished || !this.started) this.write(chunk.toString(), type);
      else this.buffer.push({
        type,
        message: chunk.toString()
      });
      callback == null ? void 0 : callback();
    }, function restore() {
      stream.write = original;
    };
  }
  write(message, type = "output") {
    this.streams[type](message);
  }
};
function getRenderedRowCount(rows, columns) {
  let count = 0;
  for (const row of rows) {
    const text = (0, import_node_util.stripVTControlCharacters)(row);
    count += Math.max(1, Math.ceil(text.length / columns));
  }
  return count;
}
var DURATION_UPDATE_INTERVAL_MS = 100;
var FINISHED_TEST_CLEANUP_TIME_MS = 1e3;
var SummaryReporter = class {
  constructor() {
    __publicField(this, "ctx");
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "modules", emptyCounters());
    __publicField(this, "tests", emptyCounters());
    __publicField(this, "maxParallelTests", 0);
    /** Currently running test modules, may include finished test modules too */
    __publicField(this, "runningModules", /* @__PURE__ */ new Map());
    /** ID of finished `this.runningModules` that are currently being shown */
    __publicField(this, "finishedModules", /* @__PURE__ */ new Map());
    __publicField(this, "startTime", "");
    __publicField(this, "currentTime", 0);
    __publicField(this, "duration", 0);
    __publicField(this, "durationInterval");
  }
  onInit(ctx, options = {}) {
    this.ctx = ctx, this.options = {
      verbose: false,
      ...options
    }, this.renderer = new WindowRenderer({
      logger: ctx.logger,
      getWindow: () => this.createSummary()
    }), this.ctx.onClose(() => {
      clearInterval(this.durationInterval), this.renderer.stop();
    });
  }
  onTestRunStart(specifications) {
    this.runningModules.clear(), this.finishedModules.clear(), this.modules = emptyCounters(), this.tests = emptyCounters(), this.startTimers(), this.renderer.start(), this.modules.total = specifications.length;
  }
  onTestRunEnd() {
    this.runningModules.clear(), this.finishedModules.clear(), this.renderer.finish(), clearInterval(this.durationInterval);
  }
  onTestModuleQueued(module) {
    if (this.finishedModules.size) {
      const finished = this.finishedModules.keys().next().value;
      this.removeTestModule(finished);
    }
    this.runningModules.set(module.id, initializeStats(module)), this.renderer.schedule();
  }
  onTestModuleCollected(module) {
    let stats = this.runningModules.get(module.id);
    if (!stats) stats = initializeStats(module), this.runningModules.set(module.id, stats);
    const total = Array.from(module.children.allTests()).length;
    this.tests.total += total, stats.total = total, this.maxParallelTests = Math.max(this.maxParallelTests, this.runningModules.size), this.renderer.schedule();
  }
  onHookStart(options) {
    var _a10, _b5;
    const stats = this.getHookStats(options);
    if (!stats) return;
    const hook = {
      name: options.name,
      visible: false,
      startTime: performance.now(),
      onFinish: () => {
      }
    };
    (_b5 = (_a10 = stats.hook) == null ? void 0 : _a10.onFinish) == null ? void 0 : _b5.call(_a10), stats.hook = hook;
    const timeout = setTimeout(() => {
      hook.visible = true;
    }, this.ctx.config.slowTestThreshold).unref();
    hook.onFinish = () => clearTimeout(timeout);
  }
  onHookEnd(options) {
    var _a10;
    const stats = this.getHookStats(options);
    ((_a10 = stats == null ? void 0 : stats.hook) == null ? void 0 : _a10.name) === options.name && (stats.hook.onFinish(), stats.hook.visible = false);
  }
  onTestCaseReady(test2) {
    if (!this.options.verbose) return;
    const stats = this.runningModules.get(test2.module.id);
    if (!stats || stats.tests.has(test2.id)) return;
    const slowTest = {
      name: test2.name,
      visible: false,
      startTime: performance.now(),
      onFinish: () => {
      }
    }, timeout = setTimeout(() => {
      slowTest.visible = true;
    }, this.ctx.config.slowTestThreshold).unref();
    slowTest.onFinish = () => {
      var _a10;
      (_a10 = slowTest.hook) == null ? void 0 : _a10.onFinish(), clearTimeout(timeout);
    }, stats.tests.set(test2.id, slowTest);
  }
  onTestCaseResult(test2) {
    var _a10;
    const stats = this.runningModules.get(test2.module.id);
    if (!stats) return;
    (_a10 = stats.tests.get(test2.id)) == null ? void 0 : _a10.onFinish(), stats.tests.delete(test2.id), stats.completed++;
    const result = test2.result();
    if ((result == null ? void 0 : result.state) === "passed") this.tests.passed++;
    else if ((result == null ? void 0 : result.state) === "failed") this.tests.failed++;
    else if (!(result == null ? void 0 : result.state) || (result == null ? void 0 : result.state) === "skipped") this.tests.skipped++;
    this.renderer.schedule();
  }
  onTestModuleEnd(module) {
    const state = module.state();
    if (this.modules.completed++, state === "passed") this.modules.passed++;
    else if (state === "failed") this.modules.failed++;
    else if (module.task.mode === "todo" && state === "skipped") this.modules.todo++;
    else if (state === "skipped") this.modules.skipped++;
    if (this.modules.total - this.modules.completed > this.maxParallelTests) this.finishedModules.set(module.id, setTimeout(() => {
      this.removeTestModule(module.id);
    }, FINISHED_TEST_CLEANUP_TIME_MS).unref());
    else
      this.removeTestModule(module.id);
    this.renderer.schedule();
  }
  getHookStats({ entity }) {
    if (!this.options.verbose) return;
    const module = entity.type === "module" ? entity : entity.module, stats = this.runningModules.get(module.id);
    if (stats) return entity.type === "test" ? stats.tests.get(entity.id) : stats;
  }
  createSummary() {
    var _a10;
    const summary = [""];
    for (const testFile of Array.from(this.runningModules.values()).sort(sortRunningModules)) {
      const typecheck = testFile.typecheck ? `${C.bgBlue(C.bold(" TS "))} ` : "";
      summary.push(C.bold(C.yellow(` ${F_POINTER} `)) + formatProjectName({
        name: testFile.projectName,
        color: testFile.projectColor
      }) + typecheck + testFile.filename + C.dim(!testFile.completed && !testFile.total ? " [queued]" : ` ${testFile.completed}/${testFile.total}`));
      const slowTasks = [testFile.hook, ...Array.from(testFile.tests.values())].filter((t2) => t2 != null && t2.visible);
      for (const [index2, task] of slowTasks.entries()) {
        const elapsed = this.currentTime - task.startTime, icon = index2 === slowTasks.length - 1 ? F_TREE_NODE_END : F_TREE_NODE_MIDDLE;
        if (summary.push(C.bold(C.yellow(`   ${icon} `)) + task.name + C.bold(C.yellow(` ${formatTime(Math.max(0, elapsed))}`))), (_a10 = task.hook) == null ? void 0 : _a10.visible) summary.push(C.bold(C.yellow(`      ${F_TREE_NODE_END} `)) + task.hook.name);
      }
    }
    if (this.runningModules.size > 0) summary.push("");
    return summary.push(padSummaryTitle("Test Files") + getStateString(this.modules)), summary.push(padSummaryTitle("Tests") + getStateString(this.tests)), summary.push(padSummaryTitle("Start at") + this.startTime), summary.push(padSummaryTitle("Duration") + formatTime(this.duration)), summary.push(""), summary;
  }
  startTimers() {
    const start = performance.now();
    this.startTime = formatTimeString(/* @__PURE__ */ new Date()), this.durationInterval = setInterval(() => {
      this.currentTime = performance.now(), this.duration = this.currentTime - start;
    }, DURATION_UPDATE_INTERVAL_MS).unref();
  }
  removeTestModule(id) {
    var _a10, _b5;
    if (!id) return;
    const testFile = this.runningModules.get(id);
    (_a10 = testFile == null ? void 0 : testFile.hook) == null ? void 0 : _a10.onFinish(), (_b5 = testFile == null ? void 0 : testFile.tests) == null ? void 0 : _b5.forEach((test2) => test2.onFinish()), this.runningModules.delete(id), clearTimeout(this.finishedModules.get(id)), this.finishedModules.delete(id);
  }
};
function emptyCounters() {
  return {
    completed: 0,
    passed: 0,
    failed: 0,
    skipped: 0,
    todo: 0,
    total: 0
  };
}
function getStateString(entry) {
  return [
    entry.failed ? C.bold(C.red(`${entry.failed} failed`)) : null,
    C.bold(C.green(`${entry.passed} passed`)),
    entry.skipped ? C.yellow(`${entry.skipped} skipped`) : null,
    entry.todo ? C.gray(`${entry.todo} todo`) : null
  ].filter(Boolean).join(C.dim(" | ")) + C.gray(` (${entry.total})`);
}
function sortRunningModules(a2, b2) {
  return (a2.projectName || "") > (b2.projectName || "") ? 1 : (a2.projectName || "") < (b2.projectName || "") ? -1 : a2.filename.localeCompare(b2.filename);
}
function initializeStats(module) {
  return {
    total: 0,
    completed: 0,
    filename: module.task.name,
    projectName: module.project.name,
    projectColor: module.project.color,
    tests: /* @__PURE__ */ new Map(),
    typecheck: !!module.task.meta.typecheck
  };
}
var DefaultReporter = class extends BaseReporter {
  constructor(options = {}) {
    super(options);
    __publicField(this, "options");
    __publicField(this, "summary");
    if (this.options = {
      summary: true,
      ...options
    }, !this.isTTY) this.options.summary = false;
    if (this.options.summary) this.summary = new SummaryReporter();
  }
  onTestRunStart(specifications) {
    var _a10;
    if (this.isTTY) {
      if (this.renderSucceed === void 0) this.renderSucceed = !!this.renderSucceed;
      if (this.renderSucceed !== true) this.renderSucceed = specifications.length <= 1;
    }
    (_a10 = this.summary) == null ? void 0 : _a10.onTestRunStart(specifications);
  }
  onTestRunEnd(testModules, unhandledErrors, reason) {
    var _a10;
    super.onTestRunEnd(testModules, unhandledErrors, reason), (_a10 = this.summary) == null ? void 0 : _a10.onTestRunEnd();
  }
  onTestModuleQueued(file) {
    var _a10;
    (_a10 = this.summary) == null ? void 0 : _a10.onTestModuleQueued(file);
  }
  onTestModuleCollected(module) {
    var _a10;
    (_a10 = this.summary) == null ? void 0 : _a10.onTestModuleCollected(module);
  }
  onTestModuleEnd(module) {
    var _a10;
    super.onTestModuleEnd(module), (_a10 = this.summary) == null ? void 0 : _a10.onTestModuleEnd(module);
  }
  onTestCaseReady(test2) {
    var _a10;
    (_a10 = this.summary) == null ? void 0 : _a10.onTestCaseReady(test2);
  }
  onTestCaseResult(test2) {
    var _a10;
    super.onTestCaseResult(test2), (_a10 = this.summary) == null ? void 0 : _a10.onTestCaseResult(test2);
  }
  onHookStart(hook) {
    var _a10;
    (_a10 = this.summary) == null ? void 0 : _a10.onHookStart(hook);
  }
  onHookEnd(hook) {
    var _a10;
    (_a10 = this.summary) == null ? void 0 : _a10.onHookEnd(hook);
  }
  onInit(ctx) {
    var _a10;
    super.onInit(ctx), (_a10 = this.summary) == null ? void 0 : _a10.onInit(ctx, { verbose: this.verbose });
  }
};
var DotReporter = class extends BaseReporter {
  constructor() {
    super(...arguments);
    __publicField(this, "renderer");
    __publicField(this, "tests", /* @__PURE__ */ new Map());
    __publicField(this, "finishedTests", /* @__PURE__ */ new Set());
  }
  onInit(ctx) {
    if (super.onInit(ctx), this.isTTY) this.renderer = new WindowRenderer({
      logger: ctx.logger,
      getWindow: () => this.createSummary()
    }), this.ctx.onClose(() => {
      var _a10;
      return (_a10 = this.renderer) == null ? void 0 : _a10.stop();
    });
  }
  // Ignore default logging of base reporter
  printTestModule() {
  }
  onWatcherRerun(files, trigger) {
    var _a10;
    this.tests.clear(), (_a10 = this.renderer) == null ? void 0 : _a10.start(), super.onWatcherRerun(files, trigger);
  }
  onTestRunEnd(testModules, unhandledErrors, reason) {
    var _a10;
    if (this.isTTY) {
      const finalLog = formatTests(Array.from(this.tests.values()));
      this.ctx.logger.log(finalLog);
    } else this.ctx.logger.log();
    this.tests.clear(), (_a10 = this.renderer) == null ? void 0 : _a10.finish(), super.onTestRunEnd(testModules, unhandledErrors, reason);
  }
  onTestModuleCollected(module) {
    for (const test2 of module.children.allTests())
      this.onTestCaseReady(test2);
  }
  onTestCaseReady(test2) {
    var _a10;
    this.finishedTests.has(test2.id) || (this.tests.set(test2.id, test2.result().state || "run"), (_a10 = this.renderer) == null ? void 0 : _a10.schedule());
  }
  onTestCaseResult(test2) {
    var _a10;
    const result = test2.result().state;
    if (!this.isTTY && result !== "pending") this.ctx.logger.outputStream.write(formatTests([result]));
    super.onTestCaseResult(test2), this.finishedTests.add(test2.id), this.tests.set(test2.id, result || "skipped"), (_a10 = this.renderer) == null ? void 0 : _a10.schedule();
  }
  onTestModuleEnd(testModule) {
    var _a10;
    if (super.onTestModuleEnd(testModule), !this.isTTY) return;
    const columns = this.ctx.logger.getColumns();
    if (this.tests.size < columns) return;
    const finishedTests = Array.from(this.tests).filter((entry) => entry[1] !== "pending");
    if (finishedTests.length < columns) return;
    const states = [];
    let count = 0;
    for (const [id, state] of finishedTests) {
      if (count++ >= columns) break;
      this.tests.delete(id), states.push(state);
    }
    this.ctx.logger.log(formatTests(states)), (_a10 = this.renderer) == null ? void 0 : _a10.schedule();
  }
  createSummary() {
    return [formatTests(Array.from(this.tests.values())), ""];
  }
};
var pass = {
  char: "·",
  color: C.green
};
var fail = {
  char: "x",
  color: C.red
};
var pending = {
  char: "*",
  color: C.yellow
};
var skip = {
  char: "-",
  color: (char) => C.dim(C.gray(char))
};
function getIcon(state) {
  switch (state) {
    case "passed":
      return pass;
    case "failed":
      return fail;
    case "skipped":
      return skip;
    default:
      return pending;
  }
}
function formatTests(states) {
  let currentIcon = pending, count = 0, output = "";
  for (const state of states) {
    const icon = getIcon(state);
    if (currentIcon === icon) {
      count++;
      continue;
    }
    output += currentIcon.color(currentIcon.char.repeat(count)), count = 1, currentIcon = icon;
  }
  return output += currentIcon.color(currentIcon.char.repeat(count)), output;
}
var comma2 = ",".charCodeAt(0);
var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar2 = new Uint8Array(64);
var charToInt2 = new Uint8Array(128);
for (let i2 = 0; i2 < chars2.length; i2++) {
  const c2 = chars2.charCodeAt(i2);
  intToChar2[i2] = c2;
  charToInt2[c2] = i2;
}
function decodeInteger2(reader, relative2) {
  let value = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c2 = reader.next();
    integer = charToInt2[c2];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  return relative2 + value;
}
function hasMoreVlq2(reader, max) {
  if (reader.pos >= max) return false;
  return reader.peek() !== comma2;
}
var StringReader2 = class {
  constructor(buffer) {
    this.pos = 0;
    this.buffer = buffer;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    const { buffer, pos } = this;
    const idx = buffer.indexOf(char, pos);
    return idx === -1 ? buffer.length : idx;
  }
};
function decode2(mappings) {
  const { length } = mappings;
  const reader = new StringReader2(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader.indexOf(";");
    const line = [];
    let sorted = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader.pos < semi) {
      let seg;
      genColumn = decodeInteger2(reader, genColumn);
      if (genColumn < lastCol) sorted = false;
      lastCol = genColumn;
      if (hasMoreVlq2(reader, semi)) {
        sourcesIndex = decodeInteger2(reader, sourcesIndex);
        sourceLine = decodeInteger2(reader, sourceLine);
        sourceColumn = decodeInteger2(reader, sourceColumn);
        if (hasMoreVlq2(reader, semi)) {
          namesIndex = decodeInteger2(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted) sort2(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos <= length);
  return decoded;
}
function sort2(line) {
  line.sort(sortComparator$1);
}
function sortComparator$1(a2, b2) {
  return a2[0] - b2[0];
}
var schemeRegex = /^[\w+.-]+:\/\//;
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith("//");
}
function isAbsolutePath(input) {
  return input.startsWith("/");
}
function isFileUrl(input) {
  return input.startsWith("file:");
}
function isRelative(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
  const match = urlRegex.exec(input);
  return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl(input) {
  const match = fileRegex.exec(input);
  const path = match[2];
  return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
}
function makeUrl(scheme, user, host, port, path, query, hash) {
  return {
    scheme,
    user,
    host,
    port,
    path,
    query,
    hash,
    type: 7
  };
}
function parseUrl(input) {
  if (isSchemeRelativeUrl(input)) {
    const url3 = parseAbsoluteUrl("http:" + input);
    url3.scheme = "";
    url3.type = 6;
    return url3;
  }
  if (isAbsolutePath(input)) {
    const url3 = parseAbsoluteUrl("http://foo.com" + input);
    url3.scheme = "";
    url3.host = "";
    url3.type = 5;
    return url3;
  }
  if (isFileUrl(input))
    return parseFileUrl(input);
  if (isAbsoluteUrl(input))
    return parseAbsoluteUrl(input);
  const url2 = parseAbsoluteUrl("http://foo.com/" + input);
  url2.scheme = "";
  url2.host = "";
  url2.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
  return url2;
}
function stripPathFilename(path) {
  if (path.endsWith("/.."))
    return path;
  const index2 = path.lastIndexOf("/");
  return path.slice(0, index2 + 1);
}
function mergePaths(url2, base2) {
  normalizePath2(base2, base2.type);
  if (url2.path === "/") {
    url2.path = base2.path;
  } else {
    url2.path = stripPathFilename(base2.path) + url2.path;
  }
}
function normalizePath2(url2, type) {
  const rel = type <= 4;
  const pieces = url2.path.split("/");
  let pointer2 = 1;
  let positive = 0;
  let addTrailingSlash = false;
  for (let i2 = 1; i2 < pieces.length; i2++) {
    const piece = pieces[i2];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === ".")
      continue;
    if (piece === "..") {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer2--;
      } else if (rel) {
        pieces[pointer2++] = piece;
      }
      continue;
    }
    pieces[pointer2++] = piece;
    positive++;
  }
  let path = "";
  for (let i2 = 1; i2 < pointer2; i2++) {
    path += "/" + pieces[i2];
  }
  if (!path || addTrailingSlash && !path.endsWith("/..")) {
    path += "/";
  }
  url2.path = path;
}
function resolve4(input, base2) {
  if (!input && !base2)
    return "";
  const url2 = parseUrl(input);
  let inputType = url2.type;
  if (base2 && inputType !== 7) {
    const baseUrl = parseUrl(base2);
    const baseType = baseUrl.type;
    switch (inputType) {
      case 1:
        url2.hash = baseUrl.hash;
      case 2:
        url2.query = baseUrl.query;
      case 3:
      case 4:
        mergePaths(url2, baseUrl);
      case 5:
        url2.user = baseUrl.user;
        url2.host = baseUrl.host;
        url2.port = baseUrl.port;
      case 6:
        url2.scheme = baseUrl.scheme;
    }
    if (baseType > inputType)
      inputType = baseType;
  }
  normalizePath2(url2, inputType);
  const queryHash = url2.query + url2.hash;
  switch (inputType) {
    case 2:
    case 3:
      return queryHash;
    case 4: {
      const path = url2.path.slice(1);
      if (!path)
        return queryHash || ".";
      if (isRelative(base2 || input) && !isRelative(path)) {
        return "./" + path + queryHash;
      }
      return path + queryHash;
    }
    case 5:
      return url2.path + queryHash;
    default:
      return url2.scheme + "//" + url2.user + url2.host + url2.port + url2.path + queryHash;
  }
}
function stripFilename(path) {
  if (!path) return "";
  const index2 = path.lastIndexOf("/");
  return path.slice(0, index2 + 1);
}
function resolver(mapUrl, sourceRoot) {
  const from = stripFilename(mapUrl);
  const prefix = sourceRoot ? sourceRoot + "/" : "";
  return (source) => resolve4(prefix + (source || ""), from);
}
var COLUMN2 = 0;
var SOURCES_INDEX2 = 1;
var SOURCE_LINE2 = 2;
var SOURCE_COLUMN2 = 3;
var NAMES_INDEX2 = 4;
var REV_GENERATED_LINE = 1;
var REV_GENERATED_COLUMN = 2;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length) return mappings;
  if (!owned) mappings = mappings.slice();
  for (let i2 = unsortedIndex; i2 < mappings.length; i2 = nextUnsortedSegmentLine(mappings, i2 + 1)) {
    mappings[i2] = sortSegments(mappings[i2], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i2 = start; i2 < mappings.length; i2++) {
    if (!isSorted(mappings[i2])) return i2;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN2] < line[j - 1][COLUMN2]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned) line = line.slice();
  return line.sort(sortComparator2);
}
function sortComparator2(a2, b2) {
  return a2[COLUMN2] - b2[COLUMN2];
}
function buildBySources(decoded, memos) {
  const sources = memos.map(() => []);
  for (let i2 = 0; i2 < decoded.length; i2++) {
    const line = decoded[i2];
    for (let j = 0; j < line.length; j++) {
      const seg = line[j];
      if (seg.length === 1) continue;
      const sourceIndex2 = seg[SOURCES_INDEX2];
      const sourceLine = seg[SOURCE_LINE2];
      const sourceColumn = seg[SOURCE_COLUMN2];
      const source = sources[sourceIndex2];
      const segs = source[sourceLine] || (source[sourceLine] = []);
      segs.push([sourceColumn, i2, seg[COLUMN2]]);
    }
  }
  for (let i2 = 0; i2 < sources.length; i2++) {
    const source = sources[i2];
    for (let j = 0; j < source.length; j++) {
      const line = source[j];
      if (line) line.sort(sortComparator2);
    }
  }
  return sources;
}
var found2 = false;
function binarySearch2(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN2] - needle;
    if (cmp === 0) {
      found2 = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found2 = false;
  return low - 1;
}
function upperBound2(haystack, needle, index2) {
  for (let i2 = index2 + 1; i2 < haystack.length; index2 = i2++) {
    if (haystack[i2][COLUMN2] !== needle) break;
  }
  return index2;
}
function lowerBound2(haystack, needle, index2) {
  for (let i2 = index2 - 1; i2 >= 0; index2 = i2--) {
    if (haystack[i2][COLUMN2] !== needle) break;
  }
  return index2;
}
function memoizedState2() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch2(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found2 = lastIndex !== -1 && haystack[lastIndex][COLUMN2] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch2(haystack, needle, low, high);
}
function parse(map) {
  return typeof map === "string" ? JSON.parse(map) : map;
}
var LINE_GTR_ZERO2 = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO2 = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND2 = -1;
var GREATEST_LOWER_BOUND2 = 1;
var TraceMap = class {
  constructor(map, mapUrl) {
    const isString = typeof map === "string";
    if (!isString && map._decodedMemo) return map;
    const parsed = parse(map);
    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version;
    this.file = file;
    this.names = names || [];
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
    const resolve5 = resolver(mapUrl, sourceRoot);
    this.resolvedSources = sources.map(resolve5);
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else if (Array.isArray(mappings)) {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString);
    } else if (parsed.sections) {
      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
    } else {
      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
    }
    this._decodedMemo = memoizedState2();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
function cast2(map) {
  return map;
}
function decodedMappings2(map) {
  var _a10;
  return (_a10 = cast2(map))._decoded || (_a10._decoded = decode2(cast2(map)._encoded));
}
function originalPositionFor2(map, needle) {
  let { line, column, bias } = needle;
  line--;
  if (line < 0) throw new Error(LINE_GTR_ZERO2);
  if (column < 0) throw new Error(COL_GTR_EQ_ZERO2);
  const decoded = decodedMappings2(map);
  if (line >= decoded.length) return OMapping2(null, null, null, null);
  const segments = decoded[line];
  const index2 = traceSegmentInternal2(
    segments,
    cast2(map)._decodedMemo,
    line,
    column,
    bias || GREATEST_LOWER_BOUND2
  );
  if (index2 === -1) return OMapping2(null, null, null, null);
  const segment = segments[index2];
  if (segment.length === 1) return OMapping2(null, null, null, null);
  const { names, resolvedSources } = map;
  return OMapping2(
    resolvedSources[segment[SOURCES_INDEX2]],
    segment[SOURCE_LINE2] + 1,
    segment[SOURCE_COLUMN2],
    segment.length === 5 ? names[segment[NAMES_INDEX2]] : null
  );
}
function generatedPositionFor(map, needle) {
  const { source, line, column, bias } = needle;
  return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND2, false);
}
function eachMapping(map, cb) {
  const decoded = decodedMappings2(map);
  const { names, resolvedSources } = map;
  for (let i2 = 0; i2 < decoded.length; i2++) {
    const line = decoded[i2];
    for (let j = 0; j < line.length; j++) {
      const seg = line[j];
      const generatedLine = i2 + 1;
      const generatedColumn = seg[0];
      let source = null;
      let originalLine = null;
      let originalColumn = null;
      let name = null;
      if (seg.length !== 1) {
        source = resolvedSources[seg[1]];
        originalLine = seg[2] + 1;
        originalColumn = seg[3];
      }
      if (seg.length === 5) name = names[seg[4]];
      cb({
        generatedLine,
        generatedColumn,
        source,
        originalLine,
        originalColumn,
        name
      });
    }
  }
}
function OMapping2(source, line, column, name) {
  return { source, line, column, name };
}
function GMapping(line, column) {
  return { line, column };
}
function traceSegmentInternal2(segments, memo, line, column, bias) {
  let index2 = memoizedBinarySearch2(segments, column, memo, line);
  if (found2) {
    index2 = (bias === LEAST_UPPER_BOUND2 ? upperBound2 : lowerBound2)(segments, column, index2);
  } else if (bias === LEAST_UPPER_BOUND2) index2++;
  if (index2 === -1 || index2 === segments.length) return -1;
  return index2;
}
function generatedPosition(map, source, line, column, bias, all) {
  var _a10, _b5;
  line--;
  if (line < 0) throw new Error(LINE_GTR_ZERO2);
  if (column < 0) throw new Error(COL_GTR_EQ_ZERO2);
  const { sources, resolvedSources } = map;
  let sourceIndex2 = sources.indexOf(source);
  if (sourceIndex2 === -1) sourceIndex2 = resolvedSources.indexOf(source);
  if (sourceIndex2 === -1) return all ? [] : GMapping(null, null);
  const bySourceMemos = (_a10 = cast2(map))._bySourceMemos || (_a10._bySourceMemos = sources.map(memoizedState2));
  const generated = (_b5 = cast2(map))._bySources || (_b5._bySources = buildBySources(decodedMappings2(map), bySourceMemos));
  const segments = generated[sourceIndex2][line];
  if (segments == null) return all ? [] : GMapping(null, null);
  const memo = bySourceMemos[sourceIndex2];
  const index2 = traceSegmentInternal2(segments, memo, line, column, bias);
  if (index2 === -1) return GMapping(null, null);
  const segment = segments[index2];
  return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
}
function ancestor(node, visitors, baseVisitor, state, override) {
  var ancestors = [];
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c2(node2, st, override2) {
    var type = override2 || node2.type;
    var isNew = node2 !== ancestors[ancestors.length - 1];
    if (isNew) {
      ancestors.push(node2);
    }
    baseVisitor[type](node2, st, c2);
    if (visitors[type]) {
      visitors[type](node2, st || ancestors, ancestors);
    }
    if (isNew) {
      ancestors.pop();
    }
  })(node, state, override);
}
function skipThrough(node, st, c2) {
  c2(node, st);
}
function ignore(_node, _st, _c) {
}
var base = {};
base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c2) {
  for (var i2 = 0, list = node.body; i2 < list.length; i2 += 1) {
    var stmt = list[i2];
    c2(stmt, st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c2) {
  return c2(node.expression, st, "Expression");
};
base.IfStatement = function(node, st, c2) {
  c2(node.test, st, "Expression");
  c2(node.consequent, st, "Statement");
  if (node.alternate) {
    c2(node.alternate, st, "Statement");
  }
};
base.LabeledStatement = function(node, st, c2) {
  return c2(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function(node, st, c2) {
  c2(node.object, st, "Expression");
  c2(node.body, st, "Statement");
};
base.SwitchStatement = function(node, st, c2) {
  c2(node.discriminant, st, "Expression");
  for (var i2 = 0, list = node.cases; i2 < list.length; i2 += 1) {
    var cs = list[i2];
    c2(cs, st);
  }
};
base.SwitchCase = function(node, st, c2) {
  if (node.test) {
    c2(node.test, st, "Expression");
  }
  for (var i2 = 0, list = node.consequent; i2 < list.length; i2 += 1) {
    var cons = list[i2];
    c2(cons, st, "Statement");
  }
};
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c2) {
  if (node.argument) {
    c2(node.argument, st, "Expression");
  }
};
base.ThrowStatement = base.SpreadElement = function(node, st, c2) {
  return c2(node.argument, st, "Expression");
};
base.TryStatement = function(node, st, c2) {
  c2(node.block, st, "Statement");
  if (node.handler) {
    c2(node.handler, st);
  }
  if (node.finalizer) {
    c2(node.finalizer, st, "Statement");
  }
};
base.CatchClause = function(node, st, c2) {
  if (node.param) {
    c2(node.param, st, "Pattern");
  }
  c2(node.body, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function(node, st, c2) {
  c2(node.test, st, "Expression");
  c2(node.body, st, "Statement");
};
base.ForStatement = function(node, st, c2) {
  if (node.init) {
    c2(node.init, st, "ForInit");
  }
  if (node.test) {
    c2(node.test, st, "Expression");
  }
  if (node.update) {
    c2(node.update, st, "Expression");
  }
  c2(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function(node, st, c2) {
  c2(node.left, st, "ForInit");
  c2(node.right, st, "Expression");
  c2(node.body, st, "Statement");
};
base.ForInit = function(node, st, c2) {
  if (node.type === "VariableDeclaration") {
    c2(node, st);
  } else {
    c2(node, st, "Expression");
  }
};
base.DebuggerStatement = ignore;
base.FunctionDeclaration = function(node, st, c2) {
  return c2(node, st, "Function");
};
base.VariableDeclaration = function(node, st, c2) {
  for (var i2 = 0, list = node.declarations; i2 < list.length; i2 += 1) {
    var decl = list[i2];
    c2(decl, st);
  }
};
base.VariableDeclarator = function(node, st, c2) {
  c2(node.id, st, "Pattern");
  if (node.init) {
    c2(node.init, st, "Expression");
  }
};
base.Function = function(node, st, c2) {
  if (node.id) {
    c2(node.id, st, "Pattern");
  }
  for (var i2 = 0, list = node.params; i2 < list.length; i2 += 1) {
    var param = list[i2];
    c2(param, st, "Pattern");
  }
  c2(node.body, st, node.expression ? "Expression" : "Statement");
};
base.Pattern = function(node, st, c2) {
  if (node.type === "Identifier") {
    c2(node, st, "VariablePattern");
  } else if (node.type === "MemberExpression") {
    c2(node, st, "MemberPattern");
  } else {
    c2(node, st);
  }
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function(node, st, c2) {
  return c2(node.argument, st, "Pattern");
};
base.ArrayPattern = function(node, st, c2) {
  for (var i2 = 0, list = node.elements; i2 < list.length; i2 += 1) {
    var elt = list[i2];
    if (elt) {
      c2(elt, st, "Pattern");
    }
  }
};
base.ObjectPattern = function(node, st, c2) {
  for (var i2 = 0, list = node.properties; i2 < list.length; i2 += 1) {
    var prop = list[i2];
    if (prop.type === "Property") {
      if (prop.computed) {
        c2(prop.key, st, "Expression");
      }
      c2(prop.value, st, "Pattern");
    } else if (prop.type === "RestElement") {
      c2(prop.argument, st, "Pattern");
    }
  }
};
base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function(node, st, c2) {
  for (var i2 = 0, list = node.elements; i2 < list.length; i2 += 1) {
    var elt = list[i2];
    if (elt) {
      c2(elt, st, "Expression");
    }
  }
};
base.ObjectExpression = function(node, st, c2) {
  for (var i2 = 0, list = node.properties; i2 < list.length; i2 += 1) {
    var prop = list[i2];
    c2(prop, st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = function(node, st, c2) {
  for (var i2 = 0, list = node.expressions; i2 < list.length; i2 += 1) {
    var expr = list[i2];
    c2(expr, st, "Expression");
  }
};
base.TemplateLiteral = function(node, st, c2) {
  for (var i2 = 0, list = node.quasis; i2 < list.length; i2 += 1) {
    var quasi = list[i2];
    c2(quasi, st);
  }
  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
    var expr = list$1[i$1];
    c2(expr, st, "Expression");
  }
};
base.TemplateElement = ignore;
base.UnaryExpression = base.UpdateExpression = function(node, st, c2) {
  c2(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function(node, st, c2) {
  c2(node.left, st, "Expression");
  c2(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function(node, st, c2) {
  c2(node.left, st, "Pattern");
  c2(node.right, st, "Expression");
};
base.ConditionalExpression = function(node, st, c2) {
  c2(node.test, st, "Expression");
  c2(node.consequent, st, "Expression");
  c2(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function(node, st, c2) {
  c2(node.callee, st, "Expression");
  if (node.arguments) {
    for (var i2 = 0, list = node.arguments; i2 < list.length; i2 += 1) {
      var arg = list[i2];
      c2(arg, st, "Expression");
    }
  }
};
base.MemberExpression = function(node, st, c2) {
  c2(node.object, st, "Expression");
  if (node.computed) {
    c2(node.property, st, "Expression");
  }
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c2) {
  if (node.declaration) {
    c2(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
  }
  if (node.source) {
    c2(node.source, st, "Expression");
  }
};
base.ExportAllDeclaration = function(node, st, c2) {
  if (node.exported) {
    c2(node.exported, st);
  }
  c2(node.source, st, "Expression");
};
base.ImportDeclaration = function(node, st, c2) {
  for (var i2 = 0, list = node.specifiers; i2 < list.length; i2 += 1) {
    var spec = list[i2];
    c2(spec, st);
  }
  c2(node.source, st, "Expression");
};
base.ImportExpression = function(node, st, c2) {
  c2(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
base.TaggedTemplateExpression = function(node, st, c2) {
  c2(node.tag, st, "Expression");
  c2(node.quasi, st, "Expression");
};
base.ClassDeclaration = base.ClassExpression = function(node, st, c2) {
  return c2(node, st, "Class");
};
base.Class = function(node, st, c2) {
  if (node.id) {
    c2(node.id, st, "Pattern");
  }
  if (node.superClass) {
    c2(node.superClass, st, "Expression");
  }
  c2(node.body, st);
};
base.ClassBody = function(node, st, c2) {
  for (var i2 = 0, list = node.body; i2 < list.length; i2 += 1) {
    var elt = list[i2];
    c2(elt, st);
  }
};
base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c2) {
  if (node.computed) {
    c2(node.key, st, "Expression");
  }
  if (node.value) {
    c2(node.value, st, "Expression");
  }
};
async function collectTests(ctx, filepath) {
  const request = await ctx.vite.environments.ssr.transformRequest(filepath);
  if (!request) return null;
  const ast = await parseAstAsync(request.code), testFilepath = relative(ctx.config.root, filepath), projectName = ctx.name, typecheckSubprojectName = projectName ? `${projectName}:__typecheck__` : "__typecheck__", file = {
    filepath,
    type: "suite",
    id: generateHash(`${testFilepath}${typecheckSubprojectName}`),
    name: testFilepath,
    mode: "run",
    tasks: [],
    start: ast.start,
    end: ast.end,
    projectName,
    meta: { typecheck: true },
    file: null
  };
  file.file = file;
  const definitions = [], getName = (callee) => {
    var _a10, _b5, _c, _d, _e;
    if (!callee) return null;
    if (callee.type === "Identifier") return callee.name;
    if (callee.type === "CallExpression") return getName(callee.callee);
    if (callee.type === "TaggedTemplateExpression") return getName(callee.tag);
    if (callee.type === "MemberExpression")
      return ((_a10 = callee.object) == null ? void 0 : _a10.type) === "Identifier" && [
        "it",
        "test",
        "describe",
        "suite"
      ].includes(callee.object.name) ? (_b5 = callee.object) == null ? void 0 : _b5.name : ((_d = (_c = callee.object) == null ? void 0 : _c.name) == null ? void 0 : _d.startsWith("__vite_ssr_")) ? getName(callee.property) : getName((_e = callee.object) == null ? void 0 : _e.property);
    if (callee.type === "SequenceExpression" && callee.expressions.length === 2) {
      const [e0, e1] = callee.expressions;
      if (e0.type === "Literal" && e0.value === 0) return getName(e1);
    }
    return null;
  };
  ancestor(ast, { CallExpression(node) {
    var _a10;
    const { callee } = node, name = getName(callee);
    if (!name || ![
      "it",
      "test",
      "describe",
      "suite"
    ].includes(name)) return;
    const property = (_a10 = callee == null ? void 0 : callee.property) == null ? void 0 : _a10.name;
    let mode = !property || property === name ? "run" : property;
    if ([
      "each",
      "for",
      "skipIf",
      "runIf"
    ].includes(mode)) return;
    let start;
    const end = node.end;
    if (callee.type === "CallExpression") start = callee.end;
    else if (callee.type === "TaggedTemplateExpression") start = callee.end + 1;
    else start = node.start;
    const { arguments: [messageNode] } = node, message = (messageNode == null ? void 0 : messageNode.type) === "Literal" || (messageNode == null ? void 0 : messageNode.type) === "TemplateLiteral" ? request.code.slice(messageNode.start + 1, messageNode.end - 1) : request.code.slice(messageNode.start, messageNode.end);
    if (mode === "skipIf" || mode === "runIf") mode = "skip";
    definitions.push({
      start,
      end,
      name: message,
      type: name === "it" || name === "test" ? "test" : "suite",
      mode,
      task: null
    });
  } });
  let lastSuite = file;
  const updateLatestSuite = (index2) => {
    while (lastSuite.suite && lastSuite.end < index2) lastSuite = lastSuite.suite;
    return lastSuite;
  };
  definitions.sort((a2, b2) => a2.start - b2.start).forEach((definition) => {
    const latestSuite = updateLatestSuite(definition.start);
    let mode = definition.mode;
    if (latestSuite.mode !== "run")
      mode = latestSuite.mode;
    if (definition.type === "suite") {
      const task2 = {
        type: definition.type,
        id: "",
        suite: latestSuite,
        file,
        tasks: [],
        mode,
        name: definition.name,
        end: definition.end,
        start: definition.start,
        meta: { typecheck: true }
      };
      definition.task = task2, latestSuite.tasks.push(task2), lastSuite = task2;
      return;
    }
    const task = {
      type: definition.type,
      id: "",
      suite: latestSuite,
      file,
      mode,
      timeout: 0,
      context: {},
      name: definition.name,
      end: definition.end,
      start: definition.start,
      annotations: [],
      meta: { typecheck: true }
    };
    definition.task = task, latestSuite.tasks.push(task);
  }), calculateSuiteHash(file);
  const hasOnly = someTasksAreOnly(file);
  return interpretTaskModes(file, ctx.config.testNamePattern, void 0, hasOnly, false, ctx.config.allowOnly), {
    file,
    parsed: request.code,
    filepath,
    map: request.map,
    definitions
  };
}
var newLineRegExp = /\r?\n/;
var errCodeRegExp = /error TS(?<errCode>\d+)/;
async function makeTscErrorInfo(errInfo) {
  var _a10;
  const [errFilePathPos = "", ...errMsgRawArr] = errInfo.split(":");
  if (!errFilePathPos || errMsgRawArr.length === 0 || errMsgRawArr.join("").length === 0) return ["unknown filepath", null];
  const errMsgRaw = errMsgRawArr.join("").trim(), [errFilePath, errPos] = errFilePathPos.slice(0, -1).split("(");
  if (!errFilePath || !errPos) return ["unknown filepath", null];
  const [errLine, errCol] = errPos.split(",");
  if (!errLine || !errCol) return [errFilePath, null];
  const execArr = errCodeRegExp.exec(errMsgRaw);
  if (!execArr) return [errFilePath, null];
  const errCodeStr = ((_a10 = execArr.groups) == null ? void 0 : _a10.errCode) ?? "";
  if (!errCodeStr) return [errFilePath, null];
  const line = Number(errLine), col = Number(errCol), errCode = Number(errCodeStr);
  return [errFilePath, {
    filePath: errFilePath,
    errCode,
    line,
    column: col,
    errMsg: errMsgRaw.slice(`error TS${errCode} `.length)
  }];
}
async function getRawErrsMapFromTsCompile(tscErrorStdout) {
  const rawErrsMap = /* @__PURE__ */ new Map();
  return (await Promise.all(tscErrorStdout.split(newLineRegExp).reduce((prev, next) => {
    if (!next) return prev;
    if (next[0] !== " ") prev.push(next);
    else prev[prev.length - 1] += `
${next}`;
    return prev;
  }, []).map((errInfoLine) => makeTscErrorInfo(errInfoLine)))).forEach(([errFilePath, errInfo]) => {
    var _a10;
    if (errInfo) if (!rawErrsMap.has(errFilePath)) rawErrsMap.set(errFilePath, [errInfo]);
    else (_a10 = rawErrsMap.get(errFilePath)) == null ? void 0 : _a10.push(errInfo);
  }), rawErrsMap;
}
function createIndexMap(source) {
  const map = /* @__PURE__ */ new Map();
  let index2 = 0, line = 1, column = 1;
  for (const char of source) if (map.set(`${line}:${column}`, index2++), char === "\n" || char === "\r\n") line++, column = 0;
  else column++;
  return map;
}
var TypeCheckError = class extends Error {
  constructor(message, stacks) {
    super(message);
    __publicField(this, "name", "TypeCheckError");
    this.message = message, this.stacks = stacks;
  }
};
var Typechecker = class {
  constructor(project) {
    __publicField(this, "_onParseStart");
    __publicField(this, "_onParseEnd");
    __publicField(this, "_onWatcherRerun");
    __publicField(this, "_result", {
      files: [],
      sourceErrors: [],
      time: 0
    });
    __publicField(this, "_startTime", 0);
    __publicField(this, "_output", "");
    __publicField(this, "_tests", {});
    __publicField(this, "process");
    __publicField(this, "files", []);
    this.project = project;
  }
  setFiles(files) {
    this.files = files;
  }
  onParseStart(fn) {
    this._onParseStart = fn;
  }
  onParseEnd(fn) {
    this._onParseEnd = fn;
  }
  onWatcherRerun(fn) {
    this._onWatcherRerun = fn;
  }
  async collectFileTests(filepath) {
    return collectTests(this.project, filepath);
  }
  getFiles() {
    return this.files;
  }
  async collectTests() {
    const tests = (await Promise.all(this.getFiles().map((filepath) => this.collectFileTests(filepath)))).reduce((acc, data) => {
      return data && (acc[data.filepath] = data), acc;
    }, {});
    return this._tests = tests, tests;
  }
  markPassed(file) {
    var _a10;
    if (!((_a10 = file.result) == null ? void 0 : _a10.state)) file.result = { state: "pass" };
    const markTasks = (tasks) => {
      var _a11;
      for (const task of tasks) {
        if ("tasks" in task) markTasks(task.tasks);
        if (!((_a11 = task.result) == null ? void 0 : _a11.state) && (task.mode === "run" || task.mode === "queued")) task.result = { state: "pass" };
      }
    };
    markTasks(file.tasks);
  }
  async prepareResults(output) {
    const typeErrors = await this.parseTscLikeOutput(output), testFiles = new Set(this.getFiles());
    if (!this._tests) this._tests = await this.collectTests();
    const sourceErrors = [], files = [];
    return testFiles.forEach((path) => {
      const { file, definitions, map, parsed } = this._tests[path], errors = typeErrors.get(path);
      if (files.push(file), !errors) {
        this.markPassed(file);
        return;
      }
      const sortedDefinitions = [...definitions.sort((a2, b2) => b2.start - a2.start)], traceMap = map && new TraceMap(map), indexMap = createIndexMap(parsed), markState = (task, state) => {
        if (task.result = { state: task.mode === "run" || task.mode === "only" ? state : task.mode }, task.suite) markState(task.suite, state);
        else if (task.file && task !== task.file) markState(task.file, state);
      };
      errors.forEach(({ error, originalError }) => {
        var _a10;
        const processedPos = traceMap ? findGeneratedPosition(traceMap, {
          line: originalError.line,
          column: originalError.column,
          source: basename(path)
        }) : originalError, line = processedPos.line ?? originalError.line, column = processedPos.column ?? originalError.column, index2 = indexMap.get(`${line}:${column}`), definition = index2 != null && sortedDefinitions.find((def) => def.start <= index2 && def.end >= index2), suite = definition ? definition.task : file, state = suite.mode === "run" || suite.mode === "only" ? "fail" : suite.mode, errors2 = ((_a10 = suite.result) == null ? void 0 : _a10.errors) || [];
        if (suite.result = {
          state,
          errors: errors2
        }, errors2.push(error), state === "fail") {
          if (suite.suite) markState(suite.suite, "fail");
          else if (suite.file && suite !== suite.file) markState(suite.file, "fail");
        }
      }), this.markPassed(file);
    }), typeErrors.forEach((errors, path) => {
      if (!testFiles.has(path)) sourceErrors.push(...errors.map(({ error }) => error));
    }), {
      files,
      sourceErrors,
      time: import_node_perf_hooks.performance.now() - this._startTime
    };
  }
  async parseTscLikeOutput(output) {
    const errorsMap = await getRawErrsMapFromTsCompile(output), typesErrors = /* @__PURE__ */ new Map();
    return errorsMap.forEach((errors, path) => {
      const filepath = resolve(this.project.config.root, path), suiteErrors = errors.map((info) => {
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        const errMsg = info.errMsg.replace(/\r?\n\s*(Type .* has no call signatures)/g, " $1"), error = new TypeCheckError(errMsg, [{
          file: filepath,
          line: info.line,
          column: info.column,
          method: ""
        }]);
        return Error.stackTraceLimit = limit, {
          originalError: info,
          error: {
            name: error.name,
            message: errMsg,
            stacks: error.stacks,
            stack: ""
          }
        };
      });
      typesErrors.set(filepath, suiteErrors);
    }), typesErrors;
  }
  async stop() {
    var _a10;
    (_a10 = this.process) == null ? void 0 : _a10.kill(), this.process = void 0;
  }
  async ensurePackageInstalled(ctx, checker) {
    if (checker !== "tsc" && checker !== "vue-tsc") return;
    const packageName = checker === "tsc" ? "typescript" : "vue-tsc";
    await ctx.packageInstaller.ensureInstalled(packageName, ctx.config.root);
  }
  getExitCode() {
    var _a10;
    return ((_a10 = this.process) == null ? void 0 : _a10.exitCode) != null && this.process.exitCode;
  }
  getOutput() {
    return this._output;
  }
  async spawn() {
    const { root, watch, typecheck } = this.project.config, args = [
      "--noEmit",
      "--pretty",
      "false",
      "--incremental",
      "--tsBuildInfoFile",
      join(process.versions.pnp ? join(import_node_os.default.tmpdir(), this.project.hash) : distDir, "tsconfig.tmp.tsbuildinfo")
    ];
    if (watch) args.push("--watch");
    if (typecheck.allowJs) args.push("--allowJs", "--checkJs");
    if (typecheck.tsconfig) args.push("-p", resolve(root, typecheck.tsconfig));
    this._output = "", this._startTime = import_node_perf_hooks.performance.now();
    const child = ve(typecheck.checker, args, {
      nodeOptions: {
        cwd: root,
        stdio: "pipe"
      },
      throwOnError: false
    });
    this.process = child.process;
    let rerunTriggered = false, dataReceived = false;
    return new Promise((resolve5, reject) => {
      if (!child.process || !child.process.stdout) {
        reject(new Error(`Failed to initialize ${typecheck.checker}. This is a bug in Vitest - please, open an issue with reproduction.`));
        return;
      }
      child.process.stdout.on("data", (chunk) => {
        var _a10;
        if (dataReceived = true, this._output += chunk, watch) {
          if (this._output.includes("File change detected") && !rerunTriggered) (_a10 = this._onWatcherRerun) == null ? void 0 : _a10.call(this), this._startTime = import_node_perf_hooks.performance.now(), this._result.sourceErrors = [], this._result.files = [], this._tests = null, rerunTriggered = true;
          if (/Found \w+ errors*. Watching for/.test(this._output)) rerunTriggered = false, this.prepareResults(this._output).then((result) => {
            var _a11;
            this._result = result, (_a11 = this._onParseEnd) == null ? void 0 : _a11.call(this, result);
          }), this._output = "";
        }
      });
      const timeout = setTimeout(() => reject(new Error(`${typecheck.checker} spawn timed out`)), this.project.config.typecheck.spawnTimeout);
      function onError(cause) {
        clearTimeout(timeout), reject(new Error("Spawning typechecker failed - is typescript installed?", { cause }));
      }
      if (child.process.once("spawn", () => {
        var _a10, _b5;
        if ((_a10 = this._onParseStart) == null ? void 0 : _a10.call(this), (_b5 = child.process) == null ? void 0 : _b5.off("error", onError), clearTimeout(timeout), process.platform === "win32")
          setTimeout(() => {
            resolve5({ result: child });
          }, 200);
        else resolve5({ result: child });
      }), process.platform === "win32") child.process.once("close", (code) => {
        if (code != null && code !== 0 && !dataReceived) onError(new Error(`The ${typecheck.checker} command exited with code ${code}.`));
      });
      child.process.once("error", onError);
    });
  }
  async start() {
    var _a10;
    if (this.process) return;
    const { watch } = this.project.config, { result: child } = await this.spawn();
    if (!watch) await child, this._result = await this.prepareResults(this._output), await ((_a10 = this._onParseEnd) == null ? void 0 : _a10.call(this, this._result));
  }
  getResult() {
    return this._result;
  }
  getTestFiles() {
    return Object.values(this._tests || {}).map((i2) => i2.file);
  }
  getTestPacksAndEvents() {
    const packs = [], events = [];
    for (const { file } of Object.values(this._tests || {})) {
      const result = convertTasksToEvents(file);
      packs.push(...result.packs), events.push(...result.events);
    }
    return {
      packs,
      events
    };
  }
};
function findGeneratedPosition(traceMap, { line, column, source }) {
  const found3 = generatedPositionFor(traceMap, {
    line,
    column,
    source
  });
  if (found3.line !== null) return found3;
  const mappings = [];
  eachMapping(traceMap, (m2) => {
    if (m2.source === source && m2.originalLine !== null && m2.originalColumn !== null && (line === m2.originalLine ? column < m2.originalColumn : line < m2.originalLine)) mappings.push(m2);
  });
  const next = mappings.sort((a2, b2) => a2.originalLine === b2.originalLine ? a2.originalColumn - b2.originalColumn : a2.originalLine - b2.originalLine).at(0);
  return next ? {
    line: next.generatedLine,
    column: next.generatedColumn
  } : {
    line: null,
    column: null
  };
}
function capturePrintError(error, ctx, options) {
  var _a10;
  let output = "";
  const writable = new import_node_stream.Writable({ write(chunk, _encoding, callback) {
    output += String(chunk), callback();
  } }), console2 = new import_node_console.Console(writable), logger = {
    error: console2.error.bind(console2),
    highlight: ctx.logger.highlight.bind(ctx.logger)
  };
  return {
    nearest: (_a10 = printError2(error, ctx, logger, {
      showCodeFrame: false,
      ...options
    })) == null ? void 0 : _a10.nearest,
    output
  };
}
function printError2(error, ctx, logger, options) {
  const project = options.project ?? ctx.coreWorkspaceProject ?? ctx.projects[0];
  return printErrorInner(error, project, {
    logger,
    type: options.type,
    showCodeFrame: options.showCodeFrame,
    screenshotPaths: options.screenshotPaths,
    printProperties: options.verbose,
    parseErrorStacktrace(error2) {
      var _a10;
      return error2.stacks ? options.fullStack ? error2.stacks : error2.stacks.filter((stack) => {
        return !stackIgnorePatterns.some((p2) => stack.file.match(p2));
      }) : ((_a10 = options.task) == null ? void 0 : _a10.file.pool) === "browser" && project.browser ? project.browser.parseErrorStacktrace(error2, {
        frameFilter: project.config.onStackTrace,
        ignoreStackEntries: options.fullStack ? [] : void 0
      }) : parseErrorStacktrace(error2, {
        frameFilter: project.config.onStackTrace,
        ignoreStackEntries: options.fullStack ? [] : void 0
      });
    }
  });
}
function printErrorInner(error, project, options) {
  var _a10;
  const { showCodeFrame = true, type, printProperties = true } = options, logger = options.logger;
  let e = error;
  if (isPrimitive(e)) e = {
    message: String(error).split(/\n/g)[0],
    stack: String(error)
  };
  if (!e) {
    const error2 = new Error("unknown error");
    e = {
      message: e ?? error2.message,
      stack: error2.stack
    };
  }
  if (!project) {
    printErrorMessage(e, logger);
    return;
  }
  const stacks = options.parseErrorStacktrace(e), nearest = error instanceof TypeCheckError ? error.stacks[0] : stacks.find((stack) => {
    var _a11, _b5;
    try {
      return [...Object.values(((_a11 = project._vite) == null ? void 0 : _a11.environments) || {}), ...Object.values(((_b5 = project.browser) == null ? void 0 : _b5.vite.environments) || {})].some((environment) => {
        var _a12;
        return [...((_a12 = environment.moduleGraph.getModulesByFile(stack.file)) == null ? void 0 : _a12.values()) || []].some((module) => !!module.transformResult);
      }) && (0, import_node_fs.existsSync)(stack.file);
    } catch {
      return false;
    }
  });
  if (type) printErrorType(type, project.vitest);
  if (printErrorMessage(e, logger), (_a10 = options.screenshotPaths) == null ? void 0 : _a10.length) {
    const uniqueScreenshots = Array.from(new Set(options.screenshotPaths)), length = uniqueScreenshots.length;
    if (logger.error(`
Failure screenshot${length > 1 ? "s" : ""}:`), logger.error(uniqueScreenshots.map((p2) => `  - ${C.dim(relative(process.cwd(), p2))}`).join("\n")), !e.diff) logger.error();
  }
  if (e.codeFrame) logger.error(`${e.codeFrame}
`);
  if ("__vitest_rollup_error__" in e) {
    const err = e.__vitest_rollup_error__;
    logger.error([
      err.plugin && `  Plugin: ${C.magenta(err.plugin)}`,
      err.id && `  File: ${C.cyan(err.id)}${err.loc ? `:${err.loc.line}:${err.loc.column}` : ""}`,
      err.frame && C.yellow(err.frame.split(/\r?\n/g).map((l2) => ` `.repeat(2) + l2).join(`
`))
    ].filter(Boolean).join("\n"));
  }
  if (e.diff) logger.error(`
${e.diff}
`);
  if (e.frame) logger.error(C.yellow(e.frame));
  else {
    const errorProperties = printProperties ? getErrorProperties(e) : {};
    printStack(logger, project, stacks, nearest, errorProperties, (s) => {
      if (showCodeFrame && s === nearest && nearest) {
        const sourceCode = (0, import_node_fs.readFileSync)(nearest.file, "utf-8");
        logger.error(generateCodeFrame(sourceCode.length > 1e5 ? sourceCode : logger.highlight(nearest.file, sourceCode), 4, s));
      }
    });
  }
  const testPath = e.VITEST_TEST_PATH, testName2 = e.VITEST_TEST_NAME, afterEnvTeardown = e.VITEST_AFTER_ENV_TEARDOWN;
  if (testPath) logger.error(C.red(`This error originated in "${C.bold(relative(project.config.root, testPath))}" test file. It doesn't mean the error was thrown inside the file itself, but while it was running.`));
  if (testName2) logger.error(C.red(`The latest test that might've caused the error is "${C.bold(testName2)}". It might mean one of the following:
- The error was thrown, while Vitest was running this test.
- If the error occurred after the test had been completed, this was the last documented test before it was thrown.`));
  if (afterEnvTeardown) logger.error(C.red("This error was caught after test environment was torn down. Make sure to cancel any running tasks before test finishes:\n- cancel timeouts using clearTimeout and clearInterval\n- wait for promises to resolve using the await keyword"));
  if (typeof e.cause === "object" && e.cause && "name" in e.cause) e.cause.name = `Caused by: ${e.cause.name}`, printErrorInner(e.cause, project, {
    showCodeFrame: false,
    logger: options.logger,
    parseErrorStacktrace: options.parseErrorStacktrace
  });
  return handleImportOutsideModuleError(e.stack || "", logger), { nearest };
}
function printErrorType(type, ctx) {
  ctx.logger.error(`
${errorBanner(type)}`);
}
var skipErrorProperties = /* @__PURE__ */ new Set([
  "cause",
  "stacks",
  "type",
  "showDiff",
  "ok",
  "operator",
  "diff",
  "codeFrame",
  "actual",
  "expected",
  "diffOptions",
  "runnerError",
  "sourceURL",
  "column",
  "line",
  "fileName",
  "lineNumber",
  "columnNumber",
  "VITEST_TEST_NAME",
  "VITEST_TEST_PATH",
  "VITEST_AFTER_ENV_TEARDOWN",
  "__vitest_rollup_error__",
  ...Object.getOwnPropertyNames(Error.prototype),
  ...Object.getOwnPropertyNames(Object.prototype)
]);
function getErrorProperties(e) {
  const errorObject = /* @__PURE__ */ Object.create(null);
  if (e.name === "AssertionError") return errorObject;
  for (const key of Object.getOwnPropertyNames(e))
    if (key === "stack" && e[key] != null && typeof e[key] !== "string") errorObject[key] = e[key];
    else if (key !== "stack" && !skipErrorProperties.has(key)) errorObject[key] = e[key];
  return errorObject;
}
var esmErrors = ["Cannot use import statement outside a module", "Unexpected token 'export'"];
function handleImportOutsideModuleError(stack, logger) {
  if (!esmErrors.some((e) => stack.includes(e))) return;
  const path = normalize(stack.split("\n")[0].trim());
  let name = path.split("/node_modules/").pop() || "";
  if (name[0] === "@") name = name.split("/").slice(0, 2).join("/");
  else name = name.split("/")[0];
  if (name) printModuleWarningForPackage(logger, path, name);
  else printModuleWarningForSourceCode(logger, path);
}
function printModuleWarningForPackage(logger, path, name) {
  logger.error(C.yellow(`Module ${path} seems to be an ES Module but shipped in a CommonJS package. You might want to create an issue to the package ${C.bold(`"${name}"`)} asking them to ship the file in .mjs extension or add "type": "module" in their package.json.

As a temporary workaround you can try to inline the package by updating your config:

` + C.gray(C.dim("// vitest.config.js")) + "\n" + C.green(`export default {
  test: {
    server: {
      deps: {
        inline: [
          ${C.yellow(C.bold(`"${name}"`))}
        ]
      }
    }
  }
}
`)));
}
function printModuleWarningForSourceCode(logger, path) {
  logger.error(C.yellow(`Module ${path} seems to be an ES Module but shipped in a CommonJS package. To fix this issue, change the file extension to .mjs or add "type": "module" in your package.json.`));
}
function printErrorMessage(error, logger) {
  const errorName = error.name || "Unknown Error";
  if (!error.message) {
    logger.error(error);
    return;
  }
  if (error.message.length > 5e3)
    logger.error(`${C.red(C.bold(errorName))}: ${error.message}`);
  else logger.error(C.red(`${C.bold(errorName)}: ${error.message}`));
}
function printStack(logger, project, stack, highlight, errorProperties, onStack) {
  for (const frame of stack) {
    const color = frame === highlight ? C.cyan : C.gray, path = relative(project.config.root, frame.file);
    logger.error(color(` ${C.dim(F_POINTER)} ${[frame.method, `${path}:${C.dim(`${frame.line}:${frame.column}`)}`].filter(Boolean).join(" ")}`)), onStack == null ? void 0 : onStack(frame);
  }
  if (stack.length) logger.error();
  if (hasProperties(errorProperties)) {
    logger.error(C.red(C.dim(divider())));
    const propertiesString = inspect(errorProperties);
    logger.error(C.red(C.bold("Serialized Error:")), C.gray(propertiesString));
  }
}
function hasProperties(obj) {
  for (const _key in obj) return true;
  return false;
}
function generateCodeFrame(source, indent = 0, loc, range = 2) {
  var _a10;
  const start = typeof loc === "object" ? positionToOffset(source, loc.line, loc.column) : loc, end = start, lines = source.split(lineSplitRE), nl = /\r\n/.test(source) ? 2 : 1;
  let count = 0, res = [];
  const columns = ((_a10 = process.stdout) == null ? void 0 : _a10.columns) || 80;
  for (let i2 = 0; i2 < lines.length; i2++) if (count += lines[i2].length + nl, count >= start) {
    for (let j = i2 - range; j <= i2 + range || end > count; j++) {
      if (j < 0 || j >= lines.length) continue;
      const lineLength = lines[j].length, strippedContent = (0, import_node_util.stripVTControlCharacters)(lines[j]);
      if (!strippedContent.startsWith("//# sourceMappingURL")) {
        if (strippedContent.length > 200) return "";
        if (res.push(lineNo(j + 1) + truncateString(lines[j].replace(/\t/g, " "), columns - 5 - indent)), j === i2) {
          const pad = start - (count - lineLength) + (nl - 1), length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(lineNo() + " ".repeat(pad) + C.red("^".repeat(length)));
        } else if (j > i2) {
          if (end > count) {
            const length = Math.max(1, Math.min(end - count, lineLength));
            res.push(lineNo() + C.red("^".repeat(length)));
          }
          count += lineLength + 1;
        }
      }
    }
    break;
  }
  if (indent) res = res.map((line) => " ".repeat(indent) + line);
  return res.join("\n");
}
function lineNo(no = "") {
  return C.gray(`${String(no).padStart(3, " ")}| `);
}
var GithubActionsReporter = class {
  constructor(options = {}) {
    __publicField(this, "ctx");
    __publicField(this, "options");
    this.options = options;
  }
  onInit(ctx) {
    this.ctx = ctx;
  }
  onTestCaseAnnotate(testCase, annotation) {
    if (!annotation.location || this.options.displayAnnotations === false) return;
    const type = getTitle(annotation.type), formatted = formatMessage({
      command: getType4(annotation.type),
      properties: {
        file: annotation.location.file,
        line: String(annotation.location.line),
        column: String(annotation.location.column),
        ...type && { title: type }
      },
      message: (0, import_node_util.stripVTControlCharacters)(annotation.message)
    });
    this.ctx.logger.log(`
${formatted}`);
  }
  onTestRunEnd(testModules, unhandledErrors) {
    var _a10, _b5;
    const files = testModules.map((testModule) => testModule.task), errors = [...unhandledErrors], projectErrors = new Array();
    for (const error of errors) projectErrors.push({
      project: this.ctx.getRootProject(),
      title: "Unhandled error",
      error
    });
    for (const file of files) {
      const tasks = getTasks(file), project = this.ctx.getProjectByName(file.projectName || "");
      for (const task of tasks) {
        if (((_a10 = task.result) == null ? void 0 : _a10.state) !== "fail") continue;
        const title = getFullName(task, " > ");
        for (const error of ((_b5 = task.result) == null ? void 0 : _b5.errors) ?? []) projectErrors.push({
          project,
          title,
          error,
          file
        });
      }
    }
    const onWritePath = this.options.onWritePath ?? defaultOnWritePath;
    for (const { project, title, error, file } of projectErrors) {
      const result = capturePrintError(error, this.ctx, {
        project,
        task: file
      }), stack = result == null ? void 0 : result.nearest;
      if (!stack) continue;
      const formatted = formatMessage({
        command: "error",
        properties: {
          file: onWritePath(stack.file),
          title,
          line: String(stack.line),
          column: String(stack.column)
        },
        message: (0, import_node_util.stripVTControlCharacters)(result.output)
      });
      this.ctx.logger.log(`
${formatted}`);
    }
  }
};
var BUILT_IN_TYPES = [
  "notice",
  "error",
  "warning"
];
function getTitle(type) {
  if (!BUILT_IN_TYPES.includes(type)) return type;
}
function getType4(type) {
  return BUILT_IN_TYPES.includes(type) ? type : "notice";
}
function defaultOnWritePath(path) {
  return path;
}
function formatMessage({ command, properties, message }) {
  let result = `::${command}`;
  return Object.entries(properties).forEach(([k, v2], i2) => {
    result += i2 === 0 ? " " : ",", result += `${k}=${escapeProperty(v2)}`;
  }), result += `::${escapeData(message)}`, result;
}
function escapeData(s) {
  return s.replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
}
function escapeProperty(s) {
  return s.replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
}
var HangingProcessReporter = class {
  constructor() {
    __publicField(this, "whyRunning");
  }
  onInit() {
    this.whyRunning = (0, import_node_module.createRequire)(import.meta.url)("why-is-node-running");
  }
  onProcessTimeout() {
    var _a10;
    (_a10 = this.whyRunning) == null ? void 0 : _a10.call(this);
  }
};
var StatusMap = {
  fail: "failed",
  only: "pending",
  pass: "passed",
  run: "pending",
  skip: "skipped",
  todo: "todo",
  queued: "pending"
};
var JsonReporter = class {
  constructor(options) {
    __publicField(this, "start", 0);
    __publicField(this, "ctx");
    __publicField(this, "options");
    __publicField(this, "coverageMap");
    this.options = options;
  }
  onInit(ctx) {
    this.ctx = ctx, this.start = Date.now(), this.coverageMap = void 0;
  }
  onCoverage(coverageMap) {
    this.coverageMap = coverageMap;
  }
  async onTestRunEnd(testModules) {
    var _a10, _b5, _c, _d;
    const files = testModules.map((testModule) => testModule.task), suites = getSuites(files), numTotalTestSuites = suites.length, tests = getTests(files), numTotalTests = tests.length, numFailedTestSuites = suites.filter((s) => {
      var _a11;
      return ((_a11 = s.result) == null ? void 0 : _a11.state) === "fail";
    }).length, numPendingTestSuites = suites.filter((s) => {
      var _a11, _b6;
      return ((_a11 = s.result) == null ? void 0 : _a11.state) === "run" || ((_b6 = s.result) == null ? void 0 : _b6.state) === "queued" || s.mode === "todo";
    }).length, numPassedTestSuites = numTotalTestSuites - numFailedTestSuites - numPendingTestSuites, numFailedTests = tests.filter((t2) => {
      var _a11;
      return ((_a11 = t2.result) == null ? void 0 : _a11.state) === "fail";
    }).length, numPassedTests = tests.filter((t2) => {
      var _a11;
      return ((_a11 = t2.result) == null ? void 0 : _a11.state) === "pass";
    }).length, numPendingTests = tests.filter((t2) => {
      var _a11, _b6, _c2;
      return ((_a11 = t2.result) == null ? void 0 : _a11.state) === "run" || ((_b6 = t2.result) == null ? void 0 : _b6.state) === "queued" || t2.mode === "skip" || ((_c2 = t2.result) == null ? void 0 : _c2.state) === "skip";
    }).length, numTodoTests = tests.filter((t2) => t2.mode === "todo").length, testResults = [], success = !!(files.length > 0 || this.ctx.config.passWithNoTests) && numFailedTestSuites === 0 && numFailedTests === 0;
    for (const file of files) {
      const tests2 = getTests([file]);
      let startTime = tests2.reduce((prev, next) => {
        var _a11;
        return Math.min(prev, ((_a11 = next.result) == null ? void 0 : _a11.startTime) ?? Number.POSITIVE_INFINITY);
      }, Number.POSITIVE_INFINITY);
      if (startTime === Number.POSITIVE_INFINITY) startTime = this.start;
      const endTime = tests2.reduce((prev, next) => {
        var _a11, _b6;
        return Math.max(prev, (((_a11 = next.result) == null ? void 0 : _a11.startTime) ?? 0) + (((_b6 = next.result) == null ? void 0 : _b6.duration) ?? 0));
      }, startTime), assertionResults = tests2.map((t2) => {
        var _a11, _b6, _c2, _d2;
        const ancestorTitles = [];
        let iter = t2.suite;
        while (iter) ancestorTitles.push(iter.name), iter = iter.suite;
        return ancestorTitles.reverse(), {
          ancestorTitles,
          fullName: t2.name ? [...ancestorTitles, t2.name].join(" ") : ancestorTitles.join(" "),
          status: StatusMap[((_a11 = t2.result) == null ? void 0 : _a11.state) || t2.mode] || "skipped",
          title: t2.name,
          duration: (_b6 = t2.result) == null ? void 0 : _b6.duration,
          failureMessages: ((_d2 = (_c2 = t2.result) == null ? void 0 : _c2.errors) == null ? void 0 : _d2.map((e) => e.stack || e.message)) || [],
          location: t2.location,
          meta: t2.meta
        };
      });
      if (tests2.some((t2) => {
        var _a11, _b6;
        return ((_a11 = t2.result) == null ? void 0 : _a11.state) === "run" || ((_b6 = t2.result) == null ? void 0 : _b6.state) === "queued";
      })) this.ctx.logger.warn("WARNING: Some tests are still running when generating the JSON report.This is likely an internal bug in Vitest.Please report it to https://github.com/vitest-dev/vitest/issues");
      const hasFailedTests = tests2.some((t2) => {
        var _a11;
        return ((_a11 = t2.result) == null ? void 0 : _a11.state) === "fail";
      });
      testResults.push({
        assertionResults,
        startTime,
        endTime,
        status: ((_a10 = file.result) == null ? void 0 : _a10.state) === "fail" || hasFailedTests ? "failed" : "passed",
        message: ((_d = (_c = (_b5 = file.result) == null ? void 0 : _b5.errors) == null ? void 0 : _c[0]) == null ? void 0 : _d.message) ?? "",
        name: file.filepath
      });
    }
    const result = {
      numTotalTestSuites,
      numPassedTestSuites,
      numFailedTestSuites,
      numPendingTestSuites,
      numTotalTests,
      numPassedTests,
      numFailedTests,
      numPendingTests,
      numTodoTests,
      snapshot: this.ctx.snapshot.summary,
      startTime: this.start,
      success,
      testResults,
      coverageMap: this.coverageMap
    };
    await this.writeReport(JSON.stringify(result));
  }
  /**
  * Writes the report to an output file if specified in the config,
  * or logs it to the console otherwise.
  * @param report
  */
  async writeReport(report) {
    const outputFile = this.options.outputFile ?? getOutputFile(this.ctx.config, "json");
    if (outputFile) {
      const reportFile = resolve(this.ctx.config.root, outputFile), outputDirectory = dirname(reportFile);
      if (!(0, import_node_fs.existsSync)(outputDirectory)) await import_node_fs.promises.mkdir(outputDirectory, { recursive: true });
      await import_node_fs.promises.writeFile(reportFile, report, "utf-8"), this.ctx.logger.log(`JSON report written to ${reportFile}`);
    } else this.ctx.logger.log(report);
  }
};
var IndentedLogger = class {
  constructor(baseLog) {
    __publicField(this, "currentIndent", "");
    this.baseLog = baseLog;
  }
  indent() {
    this.currentIndent += "    ";
  }
  unindent() {
    this.currentIndent = this.currentIndent.substring(0, this.currentIndent.length - 4);
  }
  log(text) {
    return this.baseLog(this.currentIndent + text);
  }
};
function flattenTasks$1(task, baseName = "") {
  const base2 = baseName ? `${baseName} > ` : "";
  return task.type === "suite" ? task.tasks.flatMap((child) => flattenTasks$1(child, `${base2}${task.name}`)) : [{
    ...task,
    name: `${base2}${task.name}`
  }];
}
function removeInvalidXMLCharacters(value, removeDiscouragedChars) {
  let regex = /([\0-\x08\v\f\x0E-\x1F\uFFFD\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
  if (value = String(value || "").replace(regex, ""), removeDiscouragedChars) regex = new RegExp(
    /* eslint-disable regexp/prefer-character-class, regexp/no-obscure-range, regexp/no-useless-non-capturing-group */
    "([\\x7F-\\x84]|[\\x86-\\x9F]|[\\uFDD0-\\uFDEF]|\\uD83F[\\uDFFE\\uDFFF]|(?:\\uD87F[\\uDFFE\\uDFFF])|\\uD8BF[\\uDFFE\\uDFFF]|\\uD8FF[\\uDFFE\\uDFFF]|(?:\\uD93F[\\uDFFE\\uDFFF])|\\uD97F[\\uDFFE\\uDFFF]|\\uD9BF[\\uDFFE\\uDFFF]|\\uD9FF[\\uDFFE\\uDFFF]|\\uDA3F[\\uDFFE\\uDFFF]|\\uDA7F[\\uDFFE\\uDFFF]|\\uDABF[\\uDFFE\\uDFFF]|(?:\\uDAFF[\\uDFFE\\uDFFF])|\\uDB3F[\\uDFFE\\uDFFF]|\\uDB7F[\\uDFFE\\uDFFF]|(?:\\uDBBF[\\uDFFE\\uDFFF])|\\uDBFF[\\uDFFE\\uDFFF](?:[\\0-\\t\\v\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))",
    "g"
    /* eslint-enable */
  ), value = value.replace(regex, "");
  return value;
}
function escapeXML(value) {
  return removeInvalidXMLCharacters(String(value).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), true);
}
function executionTime(durationMS) {
  return (durationMS / 1e3).toLocaleString("en-US", {
    useGrouping: false,
    maximumFractionDigits: 10
  });
}
function getDuration(task) {
  var _a10;
  const duration = ((_a10 = task.result) == null ? void 0 : _a10.duration) ?? 0;
  return executionTime(duration);
}
var JUnitReporter = class {
  constructor(options) {
    __publicField(this, "ctx");
    __publicField(this, "reportFile");
    __publicField(this, "baseLog");
    __publicField(this, "logger");
    __publicField(this, "_timeStart", /* @__PURE__ */ new Date());
    __publicField(this, "fileFd");
    __publicField(this, "options");
    var _a10;
    this.options = { ...options }, (_a10 = this.options).includeConsoleOutput ?? (_a10.includeConsoleOutput = true);
  }
  async onInit(ctx) {
    this.ctx = ctx;
    const outputFile = this.options.outputFile ?? getOutputFile(this.ctx.config, "junit");
    if (outputFile) {
      this.reportFile = resolve(this.ctx.config.root, outputFile);
      const outputDirectory = dirname(this.reportFile);
      if (!(0, import_node_fs.existsSync)(outputDirectory)) await import_node_fs.promises.mkdir(outputDirectory, { recursive: true });
      this.fileFd = await import_node_fs.promises.open(this.reportFile, "w+"), this.baseLog = async (text) => {
        if (!this.fileFd) this.fileFd = await import_node_fs.promises.open(this.reportFile, "w+");
        await import_node_fs.promises.writeFile(this.fileFd, `${text}
`);
      };
    } else this.baseLog = async (text) => this.ctx.logger.log(text);
    this._timeStart = /* @__PURE__ */ new Date(), this.logger = new IndentedLogger(this.baseLog);
  }
  async writeElement(name, attrs, children) {
    const pairs = [];
    for (const key in attrs) {
      const attr = attrs[key];
      if (attr === void 0) continue;
      pairs.push(`${key}="${escapeXML(attr)}"`);
    }
    await this.logger.log(`<${name}${pairs.length ? ` ${pairs.join(" ")}` : ""}>`), this.logger.indent(), await children.call(this), this.logger.unindent(), await this.logger.log(`</${name}>`);
  }
  async writeLogs(task, type) {
    if (task.logs == null || task.logs.length === 0) return;
    const logType = type === "err" ? "stderr" : "stdout", logs = task.logs.filter((log) => log.type === logType);
    logs.length !== 0 && await this.writeElement(`system-${type}`, {}, async () => {
      for (const log of logs) await this.baseLog(escapeXML(log.content));
    });
  }
  async writeTasks(tasks, filename) {
    for (const task of tasks) {
      let classname = filename;
      const templateVars = {
        filename: task.file.name,
        filepath: task.file.filepath
      };
      if (typeof this.options.classnameTemplate === "function") classname = this.options.classnameTemplate(templateVars);
      else if (typeof this.options.classnameTemplate === "string") classname = this.options.classnameTemplate.replace(/\{filename\}/g, templateVars.filename).replace(/\{filepath\}/g, templateVars.filepath);
      await this.writeElement("testcase", {
        classname,
        file: this.options.addFileAttribute ? filename : void 0,
        name: task.name,
        time: getDuration(task)
      }, async () => {
        var _a10;
        if (this.options.includeConsoleOutput) await this.writeLogs(task, "out"), await this.writeLogs(task, "err");
        if (task.mode === "skip" || task.mode === "todo") await this.logger.log("<skipped/>");
        if (task.type === "test" && task.annotations.length) {
          await this.logger.log("<properties>"), this.logger.indent();
          for (const annotation of task.annotations) await this.logger.log(`<property name="${escapeXML(annotation.type)}" value="${escapeXML(annotation.message)}">`), await this.logger.log("</property>");
          this.logger.unindent(), await this.logger.log("</properties>");
        }
        if (((_a10 = task.result) == null ? void 0 : _a10.state) === "fail") {
          const errors = task.result.errors || [];
          for (const error of errors) await this.writeElement("failure", {
            message: error == null ? void 0 : error.message,
            type: error == null ? void 0 : error.name
          }, async () => {
            if (!error) return;
            const result = capturePrintError(error, this.ctx, {
              project: this.ctx.getProjectByName(task.file.projectName || ""),
              task
            });
            await this.baseLog(escapeXML((0, import_node_util.stripVTControlCharacters)(result.output.trim())));
          });
        }
      });
    }
  }
  async onTestRunEnd(testModules) {
    var _a10;
    const files = testModules.map((testModule) => testModule.task);
    await this.logger.log('<?xml version="1.0" encoding="UTF-8" ?>');
    const transformed = files.map((file) => {
      var _a11, _b5;
      const tasks = file.tasks.flatMap((task) => flattenTasks$1(task)), stats2 = tasks.reduce((stats3, task) => {
        var _a12, _b6;
        return {
          passed: stats3.passed + Number(((_a12 = task.result) == null ? void 0 : _a12.state) === "pass"),
          failures: stats3.failures + Number(((_b6 = task.result) == null ? void 0 : _b6.state) === "fail"),
          skipped: stats3.skipped + Number(task.mode === "skip" || task.mode === "todo")
        };
      }, {
        passed: 0,
        failures: 0,
        skipped: 0
      }), suites = getSuites(file);
      for (const suite of suites) if ((_a11 = suite.result) == null ? void 0 : _a11.errors) tasks.push(suite), stats2.failures += 1;
      if (tasks.length === 0 && ((_b5 = file.result) == null ? void 0 : _b5.state) === "fail") stats2.failures = 1, tasks.push({
        id: file.id,
        type: "test",
        name: file.name,
        mode: "run",
        result: file.result,
        meta: {},
        timeout: 0,
        context: null,
        suite: null,
        file: null,
        annotations: []
      });
      return {
        ...file,
        tasks,
        stats: stats2
      };
    }), stats = transformed.reduce((stats2, file) => {
      var _a11;
      return stats2.tests += file.tasks.length, stats2.failures += file.stats.failures, stats2.time += ((_a11 = file.result) == null ? void 0 : _a11.duration) || 0, stats2;
    }, {
      name: this.options.suiteName || "vitest tests",
      tests: 0,
      failures: 0,
      errors: 0,
      time: 0
    });
    if (await this.writeElement("testsuites", {
      ...stats,
      time: executionTime(stats.time)
    }, async () => {
      for (const file of transformed) {
        const filename = relative(this.ctx.config.root, file.filepath);
        await this.writeElement("testsuite", {
          name: filename,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          hostname: (0, import_node_os.hostname)(),
          tests: file.tasks.length,
          failures: file.stats.failures,
          errors: 0,
          skipped: file.stats.skipped,
          time: getDuration(file)
        }, async () => {
          await this.writeTasks(file.tasks, filename);
        });
      }
    }), this.reportFile) this.ctx.logger.log(`JUNIT report written to ${this.reportFile}`);
    await ((_a10 = this.fileFd) == null ? void 0 : _a10.close()), this.fileFd = void 0;
  }
};
function yamlString(str) {
  return str ? `"${str.replace(/"/g, '\\"')}"` : "";
}
function tapString(str) {
  return str.replace(/\\/g, "\\\\").replace(/#/g, "\\#").replace(/\n/g, " ");
}
var TapReporter = class _TapReporter {
  constructor() {
    __publicField(this, "ctx");
    __publicField(this, "logger");
  }
  onInit(ctx) {
    this.ctx = ctx, this.logger = new IndentedLogger(ctx.logger.log.bind(ctx.logger));
  }
  static getComment(task) {
    var _a10;
    return task.mode === "skip" ? " # SKIP" : task.mode === "todo" ? " # TODO" : ((_a10 = task.result) == null ? void 0 : _a10.duration) == null ? "" : ` # time=${task.result.duration.toFixed(2)}ms`;
  }
  logErrorDetails(error, stack) {
    const errorName = error.name || "Unknown Error";
    if (this.logger.log(`name: ${yamlString(String(errorName))}`), this.logger.log(`message: ${yamlString(String(error.message))}`), stack)
      this.logger.log(`stack: ${yamlString(`${stack.file}:${stack.line}:${stack.column}`)}`);
  }
  logTasks(tasks) {
    var _a10, _b5;
    this.logger.log(`1..${tasks.length}`);
    for (const [i2, task] of tasks.entries()) {
      const id = i2 + 1, ok = ((_a10 = task.result) == null ? void 0 : _a10.state) === "pass" || task.mode === "skip" || task.mode === "todo" ? "ok" : "not ok", comment = _TapReporter.getComment(task);
      if (task.type === "suite" && task.tasks.length > 0) this.logger.log(`${ok} ${id} - ${tapString(task.name)}${comment} {`), this.logger.indent(), this.logTasks(task.tasks), this.logger.unindent(), this.logger.log("}");
      else {
        this.logger.log(`${ok} ${id} - ${tapString(task.name)}${comment}`);
        const project = this.ctx.getProjectByName(task.file.projectName || "");
        if (task.type === "test" && task.annotations) this.logger.indent(), task.annotations.forEach(({ type, message }) => {
          this.logger.log(`# ${type}: ${message}`);
        }), this.logger.unindent();
        if (((_b5 = task.result) == null ? void 0 : _b5.state) === "fail" && task.result.errors) this.logger.indent(), task.result.errors.forEach((error) => {
          var _a11;
          const stack = (task.file.pool === "browser" ? ((_a11 = project.browser) == null ? void 0 : _a11.parseErrorStacktrace(error)) || [] : parseErrorStacktrace(error, { frameFilter: this.ctx.config.onStackTrace }))[0];
          if (this.logger.log("---"), this.logger.log("error:"), this.logger.indent(), this.logErrorDetails(error), this.logger.unindent(), stack) this.logger.log(`at: ${yamlString(`${stack.file}:${stack.line}:${stack.column}`)}`);
          if (error.showDiff) this.logger.log(`actual: ${yamlString(error.actual)}`), this.logger.log(`expected: ${yamlString(error.expected)}`);
        }), this.logger.log("..."), this.logger.unindent();
      }
    }
  }
  onTestRunEnd(testModules) {
    const files = testModules.map((testModule) => testModule.task);
    this.logger.log("TAP version 13"), this.logTasks(files);
  }
};
function flattenTasks(task, baseName = "") {
  const base2 = baseName ? `${baseName} > ` : "";
  return task.type === "suite" && task.tasks.length > 0 ? task.tasks.flatMap((child) => flattenTasks(child, `${base2}${task.name}`)) : [{
    ...task,
    name: `${base2}${task.name}`
  }];
}
var TapFlatReporter = class extends TapReporter {
  onInit(ctx) {
    super.onInit(ctx);
  }
  onTestRunEnd(testModules) {
    this.ctx.logger.log("TAP version 13");
    const flatTasks = testModules.flatMap((testModule) => flattenTasks(testModule.task));
    this.logTasks(flatTasks);
  }
};
var TreeReporter = class extends DefaultReporter {
  constructor() {
    super(...arguments);
    __publicField(this, "verbose", true);
    __publicField(this, "renderSucceed", true);
  }
};
var VerboseReporter = class extends DefaultReporter {
  constructor() {
    super(...arguments);
    __publicField(this, "verbose", true);
    __publicField(this, "renderSucceed", true);
  }
  printTestModule(_module) {
  }
  onTestCaseResult(test2) {
    super.onTestCaseResult(test2);
    const testResult = test2.result();
    if (this.ctx.config.hideSkippedTests && testResult.state === "skipped") return;
    let title = ` ${this.getEntityPrefix(test2)} `;
    if (title += test2.module.task.name, test2.location) title += C.dim(`:${test2.location.line}:${test2.location.column}`);
    if (title += separator, title += getTestName(test2.task, separator), title += this.getTestCaseSuffix(test2), this.log(title), testResult.state === "failed") testResult.errors.forEach((error) => this.log(C.red(`   ${F_RIGHT} ${error.message}`)));
    if (test2.annotations().length) this.log(), this.printAnnotations(test2, "log", 3), this.log();
  }
};
var ReportersMap = {
  "default": DefaultReporter,
  "blob": BlobReporter,
  "verbose": VerboseReporter,
  "dot": DotReporter,
  "json": JsonReporter,
  "tap": TapReporter,
  "tap-flat": TapFlatReporter,
  "junit": JUnitReporter,
  "tree": TreeReporter,
  "hanging-process": HangingProcessReporter,
  "github-actions": GithubActionsReporter
};

export {
  import_esbuild,
  node_exports,
  KNOWN_ASSET_RE,
  nanoid,
  shuffle,
  notNullish,
  isPrimitive,
  slash,
  cleanUrl,
  isExternalUrl,
  wrapId,
  unwrapId,
  withTrailingSlash,
  toArray,
  deepClone,
  noop,
  createDefer,
  deepMerge,
  p,
  T,
  isWindows,
  isTTY,
  getDefaultExportFromCjs2 as getDefaultExportFromCjs,
  serializeValue,
  join2 as join,
  dirname2 as dirname,
  parseErrorStacktrace,
  interpretTaskModes,
  someTasksAreOnly,
  generateHash,
  calculateSuiteHash,
  createFileTask,
  generateFileHash,
  limitConcurrency,
  isTestCase,
  getTests,
  getTasks,
  hasFailed,
  getFullName,
  require_node_console,
  require_node_stream,
  rootDir,
  distDir,
  parse$1,
  stringify2 as stringify,
  createDefinesScript,
  BlobReporter,
  readBlobs,
  convertTasksToEvents,
  F_RIGHT,
  separator,
  errorBanner,
  divider,
  getStateSymbol,
  formatProjectName,
  withLabel,
  truncateString,
  utils,
  DefaultReporter,
  DotReporter,
  TraceMap,
  originalPositionFor2 as originalPositionFor,
  ancestor,
  Typechecker,
  printError2 as printError,
  generateCodeFrame,
  GithubActionsReporter,
  HangingProcessReporter,
  JsonReporter,
  JUnitReporter,
  TapReporter,
  TapFlatReporter,
  VerboseReporter,
  ReportersMap
};
/*! Bundled license information:

@vitest/pretty-format/dist/index.js:
  (**
   * @license React
   * react-is.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-27ZNANQB.js.map
