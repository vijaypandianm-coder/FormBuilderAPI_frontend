import {
  BlobReporter,
  DefaultReporter,
  F_RIGHT,
  HangingProcessReporter,
  KNOWN_ASSET_RE,
  ReportersMap,
  T,
  TraceMap,
  Typechecker,
  ancestor,
  calculateSuiteHash,
  cleanUrl,
  convertTasksToEvents,
  createDefer,
  createDefinesScript,
  createFileTask,
  deepClone,
  deepMerge,
  dirname as dirname2,
  distDir,
  divider,
  errorBanner,
  formatProjectName,
  generateCodeFrame,
  generateFileHash,
  generateHash,
  getDefaultExportFromCjs as getDefaultExportFromCjs2,
  getFullName,
  getStateSymbol,
  getTasks,
  getTests,
  hasFailed,
  interpretTaskModes,
  isExternalUrl,
  isPrimitive,
  isTTY,
  isTestCase,
  isWindows,
  join as join2,
  limitConcurrency,
  nanoid,
  node_exports,
  noop,
  notNullish,
  originalPositionFor,
  p,
  parse$1,
  parseErrorStacktrace,
  printError,
  readBlobs,
  require_node_console,
  rootDir,
  separator,
  serializeValue,
  shuffle,
  slash,
  someTasksAreOnly,
  stringify,
  toArray,
  truncateString,
  unwrapId,
  withLabel,
  withTrailingSlash,
  wrapId
} from "./chunk-27ZNANQB.js";
import {
  API_PATH,
  configFiles,
  defaultBrowserPort,
  defaultInspectPort,
  defaultPort
} from "./chunk-PHFRUQN7.js";
import {
  C
} from "./chunk-HUUV2CJB.js";
import {
  basename,
  dirname,
  extname,
  isAbsolute,
  join,
  normalize,
  relative,
  resolve
} from "./chunk-5ZZAFORQ.js";
import {
  DEFAULT_SERVER_CONDITIONS,
  ModuleRunner,
  VERSION,
  createFilter,
  createServer$2,
  fetchModule,
  glob,
  isDynamicPattern,
  mergeConfig,
  require_crypto,
  require_node_assert,
  require_node_child_process,
  require_node_crypto,
  require_node_events,
  require_node_readline,
  require_node_util,
  require_node_v8,
  require_node_worker_threads,
  require_picomatch,
  require_zlib,
  searchForWorkspaceRoot,
  ssrDynamicImportKey,
  ssrExportAllKey,
  ssrImportKey,
  ssrImportMetaKey,
  ssrModuleExportsKey
} from "./chunk-P4ZB3LCK.js";
import {
  require_url
} from "./chunk-PGHFWCZA.js";
import {
  any,
  getDefaultExportFromCjs,
  prompt
} from "./chunk-A7V4J3LA.js";
import {
  require_node_url
} from "./chunk-MYHZVKW7.js";
import {
  require_stream
} from "./chunk-J2SMN4EQ.js";
import {
  require_node_os
} from "./chunk-EXACAG4Z.js";
import {
  parseAst
} from "./chunk-R2F3KQRP.js";
import {
  require_node_process
} from "./chunk-VOWBBAOG.js";
import {
  require_events
} from "./chunk-4QXANL6B.js";
import {
  require_node_fs
} from "./chunk-Y27CEZEH.js";
import {
  require_node_module
} from "./chunk-5GUNUIXR.js";
import {
  require_node_path
} from "./chunk-PTHJ7W2W.js";
import {
  require_promises
} from "./chunk-2F4QH2CI.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __require,
  __toESM
} from "./chunk-UN725CXD.js";

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y;
        case "weeks":
        case "week":
        case "w":
          return n2 * w;
        case "days":
        case "day":
        case "d":
          return n2 * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup2(env) {
      createDebug2.debug = createDebug2;
      createDebug2.default = createDebug2;
      createDebug2.coerce = coerce;
      createDebug2.disable = disable;
      createDebug2.enable = enable;
      createDebug2.enabled = enabled;
      createDebug2.humanize = require_ms();
      createDebug2.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug2[key] = env[key];
      });
      createDebug2.names = [];
      createDebug2.skips = [];
      createDebug2.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug2.colors[Math.abs(hash2) % createDebug2.colors.length];
      }
      createDebug2.selectColor = selectColor;
      function createDebug2(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug2.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug2.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug2.formatArgs.call(self, args);
          const logFn = self.log || createDebug2.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug2.useColors();
        debug2.color = createDebug2.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug2.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug2.namespaces) {
              namespacesCache = createDebug2.namespaces;
              enabledCache = createDebug2.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug2.init === "function") {
          createDebug2.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug2(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug2.save(namespaces);
        createDebug2.namespaces = namespaces;
        createDebug2.names = [];
        createDebug2.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug2.skips.push(ns.slice(1));
          } else {
            createDebug2.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug2.names,
          ...createDebug2.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug2.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug2.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug2.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug2.enable(createDebug2.load());
      return createDebug2;
    }
    module.exports = setup2;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// browser-external:node:vm
var require_node_vm = __commonJS({
  "browser-external:node:vm"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:vm" has been externalized for browser compatibility. Cannot access "node:vm.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:tty
var require_node_tty = __commonJS({
  "browser-external:node:tty"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:tty" has been externalized for browser compatibility. Cannot access "node:tty.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:path/posix
var require_posix = __commonJS({
  "browser-external:node:path/posix"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:path/posix" has been externalized for browser compatibility. Cannot access "node:path/posix.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/vitest/dist/chunks/cli-api.6GYRwzrM.js
var import_node_fs6 = __toESM(require_node_fs(), 1);

// node_modules/vitest/dist/chunks/coverage.D_JHT54q.js
var CoverageProviderMap = {
  v8: "@vitest/coverage-v8",
  istanbul: "@vitest/coverage-istanbul"
};
async function resolveCoverageProviderModule(options, loader) {
  if (!(options == null ? void 0 : options.enabled) || !options.provider) return null;
  const provider = options.provider;
  if (provider === "v8" || provider === "istanbul") {
    let builtInModule = CoverageProviderMap[provider];
    if (provider === "v8" && loader.isBrowser) builtInModule += "/browser";
    const { default: coverageModule } = await loader.import(builtInModule);
    if (!coverageModule) throw new Error(`Failed to load ${CoverageProviderMap[provider]}. Default export is missing.`);
    return coverageModule;
  }
  let customProviderModule;
  try {
    customProviderModule = await loader.import(options.customProviderModule);
  } catch (error) {
    throw new Error(`Failed to load custom CoverageProviderModule from ${options.customProviderModule}`, { cause: error });
  }
  if (customProviderModule.default == null) throw new Error(`Custom CoverageProviderModule loaded from ${options.customProviderModule} was not the default export`);
  return customProviderModule.default;
}

// node_modules/vitest/dist/chunks/cli-api.6GYRwzrM.js
var import_node_path2 = __toESM(require_node_path(), 1);

// node_modules/vitest/dist/chunks/coverage.DT47gDHj.js
var import_node_fs = __toESM(require_node_fs(), 1);
var import_node_path = __toESM(require_node_path(), 1);
var import_picomatch = __toESM(require_picomatch(), 1);

// node_modules/vitest/dist/chunks/defaults.BOqNVLsY.js
var import_node_os = __toESM(require_node_os(), 1);
var defaultInclude = ["**/*.{test,spec}.?(c|m)[jt]s?(x)"];
var defaultExclude = ["**/node_modules/**", "**/.git/**"];
var benchmarkConfigDefaults = {
  include: ["**/*.{bench,benchmark}.?(c|m)[jt]s?(x)"],
  exclude: defaultExclude,
  includeSource: [],
  reporters: ["default"],
  includeSamples: false
};
var _a, _b;
var coverageConfigDefaults = {
  provider: "v8",
  enabled: false,
  clean: true,
  cleanOnRerun: true,
  reportsDirectory: "./coverage",
  exclude: [],
  reportOnFailure: false,
  reporter: [
    ["text", {}],
    ["html", {}],
    ["clover", {}],
    ["json", {}]
  ],
  allowExternal: false,
  excludeAfterRemap: false,
  processingConcurrency: Math.min(20, ((_b = (_a = import_node_os.default).availableParallelism) == null ? void 0 : _b.call(_a)) ?? import_node_os.default.cpus().length)
};
var fakeTimersDefaults = {
  loopLimit: 1e4,
  shouldClearNativeTimers: true
};
var configDefaults = Object.freeze({
  allowOnly: !T,
  isolate: true,
  watch: !T && process.stdin.isTTY,
  globals: false,
  environment: "node",
  clearMocks: false,
  restoreMocks: false,
  mockReset: false,
  unstubGlobals: false,
  unstubEnvs: false,
  include: defaultInclude,
  exclude: defaultExclude,
  teardownTimeout: 1e4,
  forceRerunTriggers: ["**/package.json/**", "**/{vitest,vite}.config.*/**"],
  update: false,
  reporters: [],
  silent: false,
  hideSkippedTests: false,
  api: false,
  ui: false,
  uiBase: "/__vitest__/",
  open: !T,
  css: { include: [] },
  coverage: coverageConfigDefaults,
  fakeTimers: fakeTimersDefaults,
  maxConcurrency: 5,
  dangerouslyIgnoreUnhandledErrors: false,
  typecheck: {
    checker: "tsc",
    include: ["**/*.{test,spec}-d.?(c|m)[jt]s?(x)"],
    exclude: defaultExclude
  },
  slowTestThreshold: 300,
  disableConsoleIntercept: false
});

// node_modules/vitest/dist/chunks/coverage.DT47gDHj.js
var import_node_crypto = __toESM(require_node_crypto(), 1);
var import_node_module = __toESM(require_node_module(), 1);
var import_node_process = __toESM(require_node_process(), 1);
var import_promises = __toESM(require_promises(), 1);
var import_node_url = __toESM(require_node_url(), 1);
var import_node_assert = __toESM(require_node_assert(), 1);
var import_node_v8 = __toESM(require_node_v8(), 1);
var import_node_util = __toESM(require_node_util(), 1);
var import_node_os2 = __toESM(require_node_os(), 1);
var hash = import_node_crypto.default.hash ?? ((algorithm, data, outputEncoding) => import_node_crypto.default.createHash(algorithm).update(data).digest(outputEncoding));
var JOIN_LEADING_SLASH_RE = /^\.?\//;
function withTrailingSlash2(input = "", respectQueryAndFragment) {
  {
    return input.endsWith("/") ? input : input + "/";
  }
}
function isNonEmptyURL(url2) {
  return url2 && url2 !== "/";
}
function joinURL(base2, ...input) {
  let url2 = base2 || "";
  for (const segment of input.filter((url22) => isNonEmptyURL(url22))) {
    if (url2) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url2 = withTrailingSlash2(url2) + _segment;
    } else {
      url2 = segment;
    }
  }
  return url2;
}
var BUILTIN_MODULES = new Set(import_node_module.builtinModules);
function normalizeSlash(path3) {
  return path3.replace(/\\/g, "/");
}
var own$1 = {}.hasOwnProperty;
var classRegExp = /^([A-Z][a-z\d]*)+$/;
var kTypes = /* @__PURE__ */ new Set([
  "string",
  "function",
  "number",
  "object",
  // Accept 'Function' and 'Object' as alternative to the lower cased version.
  "Function",
  "Object",
  "boolean",
  "bigint",
  "symbol"
]);
var codes = {};
function formatList(array, type = "and") {
  return array.length < 3 ? array.join(` ${type} `) : `${array.slice(0, -1).join(", ")}, ${type} ${array[array.length - 1]}`;
}
var messages = /* @__PURE__ */ new Map();
var nodeInternalPrefix = "__node_internal_";
var userStackTraceLimit;
codes.ERR_INVALID_ARG_TYPE = createError(
  "ERR_INVALID_ARG_TYPE",
  /**
   * @param {string} name
   * @param {Array<string> | string} expected
   * @param {unknown} actual
   */
  (name, expected, actual) => {
    (0, import_node_assert.default)(typeof name === "string", "'name' must be a string");
    if (!Array.isArray(expected)) {
      expected = [expected];
    }
    let message = "The ";
    if (name.endsWith(" argument")) {
      message += `${name} `;
    } else {
      const type = name.includes(".") ? "property" : "argument";
      message += `"${name}" ${type} `;
    }
    message += "must be ";
    const types2 = [];
    const instances = [];
    const other = [];
    for (const value of expected) {
      (0, import_node_assert.default)(
        typeof value === "string",
        "All expected entries have to be of type string"
      );
      if (kTypes.has(value)) {
        types2.push(value.toLowerCase());
      } else if (classRegExp.exec(value) === null) {
        (0, import_node_assert.default)(
          value !== "object",
          'The value "object" should be written as "Object"'
        );
        other.push(value);
      } else {
        instances.push(value);
      }
    }
    if (instances.length > 0) {
      const pos = types2.indexOf("object");
      if (pos !== -1) {
        types2.slice(pos, 1);
        instances.push("Object");
      }
    }
    if (types2.length > 0) {
      message += `${types2.length > 1 ? "one of type" : "of type"} ${formatList(
        types2,
        "or"
      )}`;
      if (instances.length > 0 || other.length > 0) message += " or ";
    }
    if (instances.length > 0) {
      message += `an instance of ${formatList(instances, "or")}`;
      if (other.length > 0) message += " or ";
    }
    if (other.length > 0) {
      if (other.length > 1) {
        message += `one of ${formatList(other, "or")}`;
      } else {
        if (other[0].toLowerCase() !== other[0]) message += "an ";
        message += `${other[0]}`;
      }
    }
    message += `. Received ${determineSpecificType(actual)}`;
    return message;
  },
  TypeError
);
codes.ERR_INVALID_MODULE_SPECIFIER = createError(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base2 = void 0) => {
    return `Invalid module "${request}" ${reason}${base2 ? ` imported from ${base2}` : ""}`;
  },
  TypeError
);
codes.ERR_INVALID_PACKAGE_CONFIG = createError(
  "ERR_INVALID_PACKAGE_CONFIG",
  /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */
  (path3, base2, message) => {
    return `Invalid package config ${path3}${base2 ? ` while importing ${base2}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
codes.ERR_INVALID_PACKAGE_TARGET = createError(
  "ERR_INVALID_PACKAGE_TARGET",
  /**
   * @param {string} packagePath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */
  (packagePath, key, target, isImport = false, base2 = void 0) => {
    const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      (0, import_node_assert.default)(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base2 ? ` imported from ${base2}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${packagePath}package.json${base2 ? ` imported from ${base2}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
codes.ERR_MODULE_NOT_FOUND = createError(
  "ERR_MODULE_NOT_FOUND",
  /**
   * @param {string} path
   * @param {string} base
   * @param {boolean} [exactUrl]
   */
  (path3, base2, exactUrl = false) => {
    return `Cannot find ${exactUrl ? "module" : "package"} '${path3}' imported from ${base2}`;
  },
  Error
);
codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */
  (specifier, packagePath, base2) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base2}`;
  },
  TypeError
);
codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} packagePath
   * @param {string} subpath
   * @param {string} [base]
   */
  (packagePath, subpath, base2 = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${packagePath}package.json${base2 ? ` imported from ${base2}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base2 ? ` imported from ${base2}` : ""}`;
  },
  Error
);
codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(
  "ERR_UNSUPPORTED_RESOLVE_REQUEST",
  'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
  TypeError
);
codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
  "ERR_UNKNOWN_FILE_EXTENSION",
  /**
   * @param {string} extension
   * @param {string} path
   */
  (extension2, path3) => {
    return `Unknown file extension "${extension2}" for ${path3}`;
  },
  TypeError
);
codes.ERR_INVALID_ARG_VALUE = createError(
  "ERR_INVALID_ARG_VALUE",
  /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */
  (name, value, reason = "is invalid") => {
    let inspected = (0, import_node_util.inspect)(value);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name.includes(".") ? "property" : "argument";
    return `The ${type} '${name}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (import_node_v8.default.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
var captureLargerStackTrace = hideStackFrames(
  /**
   * @param {Error} error
   * @returns {Error}
   */
  // @ts-expect-error: fine
  function(error) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error);
    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
    return error;
  }
);
function getMessage(key, parameters, self) {
  const message = messages.get(key);
  (0, import_node_assert.default)(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    (0, import_node_assert.default)(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self, parameters);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null) expectedLength++;
  (0, import_node_assert.default)(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(import_node_util.format, null, parameters);
}
function determineSpecificType(value) {
  if (value === null || value === void 0) {
    return String(value);
  }
  if (typeof value === "function" && value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === "object") {
    if (value.constructor && value.constructor.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${(0, import_node_util.inspect)(value, { depth: -1 })}`;
  }
  let inspected = (0, import_node_util.inspect)(value, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}
var hasOwnProperty$1 = {}.hasOwnProperty;
var { ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1 } = codes;
var cache = /* @__PURE__ */ new Map();
function read(jsonPath, { base: base2, specifier }) {
  const existing = cache.get(jsonPath);
  if (existing) {
    return existing;
  }
  let string;
  try {
    string = import_node_fs.default.readFileSync(import_node_path.default.toNamespacedPath(jsonPath), "utf8");
  } catch (error) {
    const exception = (
      /** @type {ErrnoException} */
      error
    );
    if (exception.code !== "ENOENT") {
      throw exception;
    }
  }
  const result = {
    exists: false,
    pjsonPath: jsonPath,
    main: void 0,
    name: void 0,
    type: "none",
    // Ignore unknown types for forwards compatibility
    exports: void 0,
    imports: void 0
  };
  if (string !== void 0) {
    let parsed;
    try {
      parsed = JSON.parse(string);
    } catch (error_) {
      const cause = (
        /** @type {ErrnoException} */
        error_
      );
      const error = new ERR_INVALID_PACKAGE_CONFIG$1(
        jsonPath,
        (base2 ? `"${specifier}" from ` : "") + (0, import_node_url.fileURLToPath)(base2 || specifier),
        cause.message
      );
      error.cause = cause;
      throw error;
    }
    result.exists = true;
    if (hasOwnProperty$1.call(parsed, "name") && typeof parsed.name === "string") {
      result.name = parsed.name;
    }
    if (hasOwnProperty$1.call(parsed, "main") && typeof parsed.main === "string") {
      result.main = parsed.main;
    }
    if (hasOwnProperty$1.call(parsed, "exports")) {
      result.exports = parsed.exports;
    }
    if (hasOwnProperty$1.call(parsed, "imports")) {
      result.imports = parsed.imports;
    }
    if (hasOwnProperty$1.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
      result.type = parsed.type;
    }
  }
  cache.set(jsonPath, result);
  return result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new URL("package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (packageJSONPath2.endsWith("node_modules/package.json")) {
      break;
    }
    const packageConfig = read((0, import_node_url.fileURLToPath)(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists) {
      return packageConfig;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = (0, import_node_url.fileURLToPath)(packageJSONUrl);
  return {
    pjsonPath: packageJSONPath,
    exists: false,
    type: "none"
  };
}
function getPackageType(url2) {
  return getPackageScopeConfig(url2).type;
}
var { ERR_UNKNOWN_FILE_EXTENSION } = codes;
var hasOwnProperty = {}.hasOwnProperty;
var extensionFormatMap = {
  // @ts-expect-error: hush.
  __proto__: null,
  ".cjs": "commonjs",
  ".js": "module",
  ".json": "json",
  ".mjs": "module"
};
function mimeToFormat(mime2) {
  if (mime2 && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime2))
    return "module";
  if (mime2 === "application/json") return "json";
  return null;
}
var protocolHandlers = {
  // @ts-expect-error: hush.
  __proto__: null,
  "data:": getDataProtocolModuleFormat,
  "file:": getFileProtocolModuleFormat,
  "http:": getHttpProtocolModuleFormat,
  "https:": getHttpProtocolModuleFormat,
  "node:"() {
    return "builtin";
  }
};
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime2 } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime2);
}
function extname2(url2) {
  const pathname = url2.pathname;
  let index = pathname.length;
  while (index--) {
    const code = pathname.codePointAt(index);
    if (code === 47) {
      return "";
    }
    if (code === 46) {
      return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
    }
  }
  return "";
}
function getFileProtocolModuleFormat(url2, _context, ignoreErrors) {
  const value = extname2(url2);
  if (value === ".js") {
    const packageType = getPackageType(url2);
    if (packageType !== "none") {
      return packageType;
    }
    return "commonjs";
  }
  if (value === "") {
    const packageType = getPackageType(url2);
    if (packageType === "none" || packageType === "commonjs") {
      return "commonjs";
    }
    return "module";
  }
  const format2 = extensionFormatMap[value];
  if (format2) return format2;
  if (ignoreErrors) {
    return void 0;
  }
  const filepath = (0, import_node_url.fileURLToPath)(url2);
  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url2, context) {
  const protocol = url2.protocol;
  if (!hasOwnProperty.call(protocolHandlers, protocol)) {
    return null;
  }
  return protocolHandlers[protocol](url2, context, true) || null;
}
var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
var {
  ERR_INVALID_MODULE_SPECIFIER,
  ERR_INVALID_PACKAGE_CONFIG,
  ERR_INVALID_PACKAGE_TARGET,
  ERR_MODULE_NOT_FOUND,
  ERR_PACKAGE_IMPORT_NOT_DEFINED,
  ERR_PACKAGE_PATH_NOT_EXPORTED,
  ERR_UNSUPPORTED_DIR_IMPORT,
  ERR_UNSUPPORTED_RESOLVE_REQUEST
} = codes;
var own = {}.hasOwnProperty;
var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
var invalidPackageNameRegEx = /^\.|%|\\/;
var patternRegEx = /\*/g;
var encodedSeparatorRegEx = /%2f|%5c/i;
var emittedPackageWarnings = /* @__PURE__ */ new Set();
var doubleSlashRegEx = /[/\\]{2}/;
function emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base2, isTarget) {
  if (import_node_process.default.noDeprecation) {
    return;
  }
  const pjsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  import_node_process.default.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match ? "" : `matched to "${match}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base2 ? ` imported from ${(0, import_node_url.fileURLToPath)(base2)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url2, packageJsonUrl, base2, main) {
  if (import_node_process.default.noDeprecation) {
    return;
  }
  const format2 = defaultGetFormatWithoutErrors(url2, { parentURL: base2.href });
  if (format2 !== "module") return;
  const urlPath = (0, import_node_url.fileURLToPath)(url2.href);
  const packagePath = (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl));
  const basePath = (0, import_node_url.fileURLToPath)(base2);
  if (!main) {
    import_node_process.default.emitWarning(
      `No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  } else if (import_node_path.default.resolve(packagePath, main) !== urlPath) {
    import_node_process.default.emitWarning(
      `Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  }
}
function tryStatSync(path3) {
  try {
    return (0, import_node_fs.statSync)(path3);
  } catch {
  }
}
function fileExists(url2) {
  const stats = (0, import_node_fs.statSync)(url2, { throwIfNoEntry: false });
  const isFile = stats ? stats.isFile() : void 0;
  return isFile === null || isFile === void 0 ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base2) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new import_node_url.URL(packageConfig.main, packageJsonUrl);
    if (fileExists(guess)) return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i2 = -1;
    while (++i2 < tries2.length) {
      guess = new import_node_url.URL(tries2[i2], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base2,
        packageConfig.main
      );
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i = -1;
  while (++i < tries.length) {
    guess = new import_node_url.URL(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base2, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(
    (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    (0, import_node_url.fileURLToPath)(base2)
  );
}
function finalizeResolution(resolved, base2, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      (0, import_node_url.fileURLToPath)(base2)
    );
  }
  let filePath;
  try {
    filePath = (0, import_node_url.fileURLToPath)(resolved);
  } catch (error) {
    const cause = (
      /** @type {ErrnoException} */
      error
    );
    Object.defineProperty(cause, "input", { value: String(resolved) });
    Object.defineProperty(cause, "module", { value: String(base2) });
    throw cause;
  }
  const stats = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats && stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, import_node_url.fileURLToPath)(base2));
    error.url = String(resolved);
    throw error;
  }
  if (!stats || !stats.isFile()) {
    const error = new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base2 && (0, import_node_url.fileURLToPath)(base2),
      true
    );
    error.url = String(resolved);
    throw error;
  }
  {
    const real = (0, import_node_fs.realpathSync)(filePath);
    const { search, hash: hash2 } = resolved;
    resolved = (0, import_node_url.pathToFileURL)(real + (filePath.endsWith(import_node_path.default.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash2;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base2) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    (0, import_node_url.fileURLToPath)(base2)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base2) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    subpath,
    base2 && (0, import_node_url.fileURLToPath)(base2)
  );
}
function throwInvalidSubpath(request, match, packageJsonUrl, internal, base2) {
  const reason = `request is not a valid match in pattern "${match}" for the "${internal ? "imports" : "exports"}" resolution of ${(0, import_node_url.fileURLToPath)(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base2 && (0, import_node_url.fileURLToPath)(base2)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base2) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(
    (0, import_node_url.fileURLToPath)(new import_node_url.URL(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base2 && (0, import_node_url.fileURLToPath)(base2)
  );
}
function resolvePackageTargetString(target, subpath, match, packageJsonUrl, base2, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base2);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL = false;
      try {
        new import_node_url.URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base2);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match.replace("*", () => subpath) : match + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base2,
          true
        );
      }
    } else {
      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base2);
    }
  }
  const resolved = new import_node_url.URL(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new import_node_url.URL(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base2);
  if (subpath === "") return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match.replace("*", () => subpath) : match + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match,
          packageJsonUrl,
          internal,
          base2,
          false
        );
      }
    } else {
      throwInvalidSubpath(request, match, packageJsonUrl, internal, base2);
    }
  }
  if (pattern) {
    return new import_node_url.URL(
      RegExpPrototypeSymbolReplace.call(
        patternRegEx,
        resolved.href,
        () => subpath
      )
    );
  }
  return new import_node_url.URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNumber = Number(key);
  if (`${keyNumber}` !== key) return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base2, pattern, internal, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base2,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0) return null;
    let lastException;
    let i = -1;
    while (++i < targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base2,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error) {
        const exception = (
          /** @type {ErrnoException} */
          error
        );
        lastException = exception;
        if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
        throw error;
      }
      if (resolveResult === void 0) continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys2 = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys2.length) {
      const key = keys2[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          (0, import_node_url.fileURLToPath)(packageJsonUrl),
          base2,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    i = -1;
    while (++i < keys2.length) {
      const key = keys2[i];
      if (key === "default" || conditions && conditions.has(key)) {
        const conditionalTarget = (
          /** @type {unknown} */
          target[key]
        );
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base2,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0) continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base2
  );
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base2) {
  if (typeof exports === "string" || Array.isArray(exports)) return true;
  if (typeof exports !== "object" || exports === null) return false;
  const keys2 = Object.getOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  let keyIndex = -1;
  while (++keyIndex < keys2.length) {
    const key = keys2[keyIndex];
    const currentIsConditionalSugar = key === "" || key[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = currentIsConditionalSugar;
    } else if (isConditionalSugar !== currentIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG(
        (0, import_node_url.fileURLToPath)(packageJsonUrl),
        base2,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match, pjsonUrl, base2) {
  if (import_node_process.default.noDeprecation) {
    return;
  }
  const pjsonPath = (0, import_node_url.fileURLToPath)(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match)) return;
  emittedPackageWarnings.add(pjsonPath + "|" + match);
  import_node_process.default.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match}" in the "exports" field module resolution of the package at ${pjsonPath}${base2 ? ` imported from ${(0, import_node_url.fileURLToPath)(base2)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base2, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base2)) {
    exports = { ".": exports };
  }
  if (own.call(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base2,
      false,
      false,
      false,
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base2);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys2 = Object.getOwnPropertyNames(exports);
  let i = -1;
  while (++i < keys2.length) {
    const key = keys2[i];
    const patternIndex = key.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJsonUrl,
          base2
        );
      }
      const patternTrailer = key.slice(patternIndex + 1);
      if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
        bestMatch = key;
        bestMatchSubpath = packageSubpath.slice(
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = (
      /** @type {unknown} */
      exports[bestMatch]
    );
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base2,
      true,
      false,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base2);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base2);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*");
  const bPatternIndex = b.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB) return -1;
  if (baseLengthB > baseLengthA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a.length > b.length) return -1;
  if (b.length > a.length) return 1;
  return 0;
}
function packageImportsResolve(name, base2, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, (0, import_node_url.fileURLToPath)(base2));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base2);
  if (packageConfig.exists) {
    packageJsonUrl = (0, import_node_url.pathToFileURL)(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base2,
          false,
          true,
          false,
          conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys2 = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i < keys2.length) {
          const key = keys2[i];
          const patternIndex = key.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key.slice(0, -1))) {
            const patternTrailer = key.slice(patternIndex + 1);
            if (name.length >= key.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = name.slice(
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base2,
            true,
            true,
            false,
            conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base2);
}
function parsePackageName(specifier, base2) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      (0, import_node_url.fileURLToPath)(base2)
    );
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base2, conditions) {
  if (import_node_module.builtinModules.includes(specifier)) {
    return new import_node_url.URL("node:" + specifier);
  }
  const { packageName, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base2
  );
  const packageConfig = getPackageScopeConfig(base2);
  if (packageConfig.exists) {
    const packageJsonUrl2 = (0, import_node_url.pathToFileURL)(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base2,
        conditions
      );
    }
  }
  let packageJsonUrl = new import_node_url.URL(
    "./node_modules/" + packageName + "/package.json",
    base2
  );
  let packageJsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
  let lastPath;
  do {
    const stat2 = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat2 || !stat2.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new import_node_url.URL(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
        packageJsonUrl
      );
      packageJsonPath = (0, import_node_url.fileURLToPath)(packageJsonUrl);
      continue;
    }
    const packageConfig2 = read(packageJsonPath, { base: base2, specifier });
    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl,
        packageSubpath,
        packageConfig2,
        base2,
        conditions
      );
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base2);
    }
    return new import_node_url.URL(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, (0, import_node_url.fileURLToPath)(base2), false);
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/") return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "") return false;
  if (specifier[0] === "/") return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base2, conditions, preserveSymlinks) {
  const protocol = base2.protocol;
  const isData = protocol === "data:";
  const isRemote = isData || protocol === "http:" || protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    try {
      resolved = new import_node_url.URL(specifier, base2);
    } catch (error_) {
      const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base2);
      error.cause = error_;
      throw error;
    }
  } else if (protocol === "file:" && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base2, conditions);
  } else {
    try {
      resolved = new import_node_url.URL(specifier);
    } catch (error_) {
      if (isRemote && !import_node_module.builtinModules.includes(specifier)) {
        const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base2);
        error.cause = error_;
        throw error;
      }
      resolved = packageResolve(specifier, base2, conditions);
    }
  }
  (0, import_node_assert.default)(resolved !== void 0, "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base2);
}
function fileURLToPath(id) {
  if (typeof id === "string" && !id.startsWith("file://")) {
    return normalizeSlash(id);
  }
  return normalizeSlash((0, import_node_url.fileURLToPath)(id));
}
function pathToFileURL(id) {
  return (0, import_node_url.pathToFileURL)(fileURLToPath(id)).toString();
}
function normalizeid(id) {
  if (typeof id !== "string") {
    id = id.toString();
  }
  if (/(?:node|data|http|https|file):/.test(id)) {
    return id;
  }
  if (BUILTIN_MODULES.has(id)) {
    return "node:" + id;
  }
  return "file://" + encodeURI(normalizeSlash(id));
}
var DEFAULT_CONDITIONS_SET = /* @__PURE__ */ new Set(["node", "import"]);
var DEFAULT_EXTENSIONS = [".mjs", ".cjs", ".js", ".json"];
var NOT_FOUND_ERRORS = /* @__PURE__ */ new Set([
  "ERR_MODULE_NOT_FOUND",
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "MODULE_NOT_FOUND",
  "ERR_PACKAGE_PATH_NOT_EXPORTED"
]);
function _tryModuleResolve(id, url2, conditions) {
  try {
    return moduleResolve(id, url2, conditions);
  } catch (error) {
    if (!NOT_FOUND_ERRORS.has(error == null ? void 0 : error.code)) {
      throw error;
    }
  }
}
function _resolve$1(id, options = {}) {
  if (typeof id !== "string") {
    if (id instanceof URL) {
      id = fileURLToPath(id);
    } else {
      throw new TypeError("input must be a `string` or `URL`");
    }
  }
  if (/(?:node|data|http|https):/.test(id)) {
    return id;
  }
  if (BUILTIN_MODULES.has(id)) {
    return "node:" + id;
  }
  if (id.startsWith("file://")) {
    id = fileURLToPath(id);
  }
  if (isAbsolute(id)) {
    try {
      const stat2 = (0, import_node_fs.statSync)(id);
      if (stat2.isFile()) {
        return pathToFileURL(id);
      }
    } catch (error) {
      if ((error == null ? void 0 : error.code) !== "ENOENT") {
        throw error;
      }
    }
  }
  const conditionsSet = options.conditions ? new Set(options.conditions) : DEFAULT_CONDITIONS_SET;
  const _urls = (Array.isArray(options.url) ? options.url : [options.url]).filter(Boolean).map((url2) => new URL(normalizeid(url2.toString())));
  if (_urls.length === 0) {
    _urls.push(new URL(pathToFileURL(process.cwd())));
  }
  const urls = [..._urls];
  for (const url2 of _urls) {
    if (url2.protocol === "file:") {
      urls.push(
        new URL("./", url2),
        // If url is directory
        new URL(joinURL(url2.pathname, "_index.js"), url2),
        // TODO: Remove in next major version?
        new URL("node_modules", url2)
      );
    }
  }
  let resolved;
  for (const url2 of urls) {
    resolved = _tryModuleResolve(id, url2, conditionsSet);
    if (resolved) {
      break;
    }
    for (const prefix of ["", "/index"]) {
      for (const extension2 of options.extensions || DEFAULT_EXTENSIONS) {
        resolved = _tryModuleResolve(
          joinURL(id, prefix) + extension2,
          url2,
          conditionsSet
        );
        if (resolved) {
          break;
        }
      }
      if (resolved) {
        break;
      }
    }
    if (resolved) {
      break;
    }
  }
  if (!resolved) {
    const error = new Error(
      `Cannot find module ${id} imported from ${urls.join(", ")}`
    );
    error.code = "ERR_MODULE_NOT_FOUND";
    throw error;
  }
  return pathToFileURL(resolved);
}
function resolveSync(id, options) {
  return _resolve$1(id, options);
}
function resolvePathSync(id, options) {
  return fileURLToPath(resolveSync(id, options));
}
var GET_IS_ASYNC = Symbol.for("quansync.getIsAsync");
var QuansyncError = class extends Error {
  constructor(message = "Unexpected promise in sync context") {
    super(message);
    this.name = "QuansyncError";
  }
};
function isThenable(value) {
  return value && typeof value === "object" && typeof value.then === "function";
}
function isQuansyncGenerator(value) {
  return value && typeof value === "object" && typeof value[Symbol.iterator] === "function" && "__quansync" in value;
}
function fromObject(options) {
  const generator = function* (...args) {
    const isAsync = yield GET_IS_ASYNC;
    if (isAsync)
      return yield options.async.apply(this, args);
    return options.sync.apply(this, args);
  };
  function fn(...args) {
    const iter = generator.apply(this, args);
    iter.then = (...thenArgs) => options.async.apply(this, args).then(...thenArgs);
    iter.__quansync = true;
    return iter;
  }
  fn.sync = options.sync;
  fn.async = options.async;
  return fn;
}
function fromPromise(promise) {
  return fromObject({
    async: () => Promise.resolve(promise),
    sync: () => {
      if (isThenable(promise))
        throw new QuansyncError();
      return promise;
    }
  });
}
function unwrapYield(value, isAsync) {
  if (value === GET_IS_ASYNC)
    return isAsync;
  if (isQuansyncGenerator(value))
    return isAsync ? iterateAsync(value) : iterateSync(value);
  if (!isAsync && isThenable(value))
    throw new QuansyncError();
  return value;
}
var DEFAULT_ON_YIELD = (value) => value;
function iterateSync(generator, onYield = DEFAULT_ON_YIELD) {
  let current = generator.next();
  while (!current.done) {
    try {
      current = generator.next(unwrapYield(onYield(current.value, false)));
    } catch (err) {
      current = generator.throw(err);
    }
  }
  return unwrapYield(current.value);
}
async function iterateAsync(generator, onYield = DEFAULT_ON_YIELD) {
  let current = generator.next();
  while (!current.done) {
    try {
      current = generator.next(await unwrapYield(onYield(current.value, true), true));
    } catch (err) {
      current = generator.throw(err);
    }
  }
  return current.value;
}
function fromGeneratorFn(generatorFn, options) {
  return fromObject({
    name: generatorFn.name,
    async(...args) {
      return iterateAsync(generatorFn.apply(this, args), options == null ? void 0 : options.onYield);
    },
    sync(...args) {
      return iterateSync(generatorFn.apply(this, args), options == null ? void 0 : options.onYield);
    }
  });
}
function quansync$1(input, options) {
  if (isThenable(input))
    return fromPromise(input);
  if (typeof input === "function")
    return fromGeneratorFn(input, options);
  else
    return fromObject(input);
}
quansync$1({
  async: () => Promise.resolve(true),
  sync: () => false
});
var quansync = quansync$1;
var toPath = (urlOrPath) => urlOrPath instanceof URL ? (0, import_node_url.fileURLToPath)(urlOrPath) : urlOrPath;
async function findUp$1(name, {
  cwd = import_node_process.default.cwd(),
  type = "file",
  stopAt
} = {}) {
  let directory = import_node_path.default.resolve(toPath(cwd) ?? "");
  const { root } = import_node_path.default.parse(directory);
  stopAt = import_node_path.default.resolve(directory, toPath(stopAt ?? root));
  const isAbsoluteName = import_node_path.default.isAbsolute(name);
  while (directory) {
    const filePath = isAbsoluteName ? name : import_node_path.default.join(directory, name);
    try {
      const stats = await import_promises.default.stat(filePath);
      if (type === "file" && stats.isFile() || type === "directory" && stats.isDirectory()) {
        return filePath;
      }
    } catch {
    }
    if (directory === stopAt || directory === root) {
      break;
    }
    directory = import_node_path.default.dirname(directory);
  }
}
function findUpSync(name, {
  cwd = import_node_process.default.cwd(),
  type = "file",
  stopAt
} = {}) {
  let directory = import_node_path.default.resolve(toPath(cwd) ?? "");
  const { root } = import_node_path.default.parse(directory);
  stopAt = import_node_path.default.resolve(directory, toPath(stopAt) ?? root);
  const isAbsoluteName = import_node_path.default.isAbsolute(name);
  while (directory) {
    const filePath = isAbsoluteName ? name : import_node_path.default.join(directory, name);
    try {
      const stats = import_node_fs.default.statSync(filePath, { throwIfNoEntry: false });
      if (type === "file" && (stats == null ? void 0 : stats.isFile()) || type === "directory" && (stats == null ? void 0 : stats.isDirectory())) {
        return filePath;
      }
    } catch {
    }
    if (directory === stopAt || directory === root) {
      break;
    }
    directory = import_node_path.default.dirname(directory);
  }
}
function _resolve(path3, options = {}) {
  if (options.platform === "auto" || !options.platform)
    options.platform = import_node_process.default.platform === "win32" ? "win32" : "posix";
  if (import_node_process.default.versions.pnp) {
    const paths = options.paths || [];
    if (paths.length === 0)
      paths.push(import_node_process.default.cwd());
    const targetRequire = (0, import_node_module.createRequire)(import.meta.url);
    try {
      return targetRequire.resolve(path3, { paths });
    } catch {
    }
  }
  const modulePath = resolvePathSync(path3, {
    url: options.paths
  });
  if (options.platform === "win32")
    return import_node_path.win32.normalize(modulePath);
  return modulePath;
}
function resolveModule(name, options = {}) {
  try {
    return _resolve(name, options);
  } catch {
    return void 0;
  }
}
function isPackageExists(name, options = {}) {
  return !!resolvePackage(name, options);
}
function getPackageJsonPath(name, options = {}) {
  const entry = resolvePackage(name, options);
  if (!entry)
    return;
  return searchPackageJSON(entry);
}
var readFile = quansync({
  async: (id) => import_node_fs.default.promises.readFile(id, "utf8"),
  sync: (id) => import_node_fs.default.readFileSync(id, "utf8")
});
var getPackageInfo = quansync(function* (name, options = {}) {
  const packageJsonPath = getPackageJsonPath(name, options);
  if (!packageJsonPath)
    return;
  const packageJson = JSON.parse(yield readFile(packageJsonPath));
  return {
    name,
    version: packageJson.version,
    rootPath: (0, import_node_path.dirname)(packageJsonPath),
    packageJsonPath,
    packageJson
  };
});
getPackageInfo.sync;
function resolvePackage(name, options = {}) {
  try {
    return _resolve(`${name}/package.json`, options);
  } catch {
  }
  try {
    return _resolve(name, options);
  } catch (e) {
    if (e.code !== "MODULE_NOT_FOUND" && e.code !== "ERR_MODULE_NOT_FOUND")
      console.error(e);
    return false;
  }
}
function searchPackageJSON(dir) {
  let packageJsonPath;
  while (true) {
    if (!dir)
      return;
    const newDir = (0, import_node_path.dirname)(dir);
    if (newDir === dir)
      return;
    dir = newDir;
    packageJsonPath = (0, import_node_path.join)(dir, "package.json");
    if (import_node_fs.default.existsSync(packageJsonPath))
      break;
  }
  return packageJsonPath;
}
var findUp = quansync({
  sync: findUpSync,
  async: findUp$1
});
var loadPackageJSON = quansync(function* (cwd = import_node_process.default.cwd()) {
  const path3 = yield findUp("package.json", { cwd });
  if (!path3 || !import_node_fs.default.existsSync(path3))
    return null;
  return JSON.parse(yield readFile(path3));
});
loadPackageJSON.sync;
var isPackageListed = quansync(function* (name, cwd) {
  const pkg = (yield loadPackageJSON(cwd)) || {};
  return name in (pkg.dependencies || {}) || name in (pkg.devDependencies || {});
});
isPackageListed.sync;
function getWorkersCountByPercentage(percent) {
  var _a2, _b2;
  const maxWorkersCount = ((_b2 = (_a2 = import_node_os2.default).availableParallelism) == null ? void 0 : _b2.call(_a2)) ?? import_node_os2.default.cpus().length, workersCountByPercentage = Math.round(Number.parseInt(percent) / 100 * maxWorkersCount);
  return Math.max(1, Math.min(maxWorkersCount, workersCountByPercentage));
}
var BaseSequencer = class {
  constructor(ctx) {
    __publicField(this, "ctx");
    this.ctx = ctx;
  }
  // async so it can be extended by other sequelizers
  async shard(files) {
    const { config } = this.ctx, { index, count } = config.shard, [shardStart, shardEnd] = this.calculateShardRange(files.length, index, count);
    return [...files].map((spec) => {
      var _a2;
      const specPath = (_a2 = resolve(slash(config.root), slash(spec.moduleId))) == null ? void 0 : _a2.slice(config.root.length);
      return {
        spec,
        hash: hash("sha1", specPath, "hex")
      };
    }).sort((a, b) => a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0).slice(shardStart, shardEnd).map(({ spec }) => spec);
  }
  // async so it can be extended by other sequelizers
  async sort(files) {
    const cache2 = this.ctx.cache;
    return [...files].sort((a, b) => {
      const keyA = `${a.project.name}:${relative(this.ctx.config.root, a.moduleId)}`, keyB = `${b.project.name}:${relative(this.ctx.config.root, b.moduleId)}`, aState = cache2.getFileTestResults(keyA), bState = cache2.getFileTestResults(keyB);
      if (!aState || !bState) {
        const statsA = cache2.getFileStats(keyA), statsB = cache2.getFileStats(keyB);
        return !statsA || !statsB ? !statsA && statsB ? -1 : !statsB && statsA ? 1 : 0 : statsB.size - statsA.size;
      }
      return aState.failed && !bState.failed ? -1 : !aState.failed && bState.failed ? 1 : bState.duration - aState.duration;
    });
  }
  // Calculate distributed shard range [start, end] distributed equally
  calculateShardRange(filesCount, index, count) {
    const baseShardSize = Math.floor(filesCount / count), remainderTestFilesCount = filesCount % count;
    if (remainderTestFilesCount >= index) {
      const shardSize = baseShardSize + 1, shardStart2 = shardSize * (index - 1), shardEnd2 = shardSize * index;
      return [shardStart2, shardEnd2];
    }
    const shardStart = remainderTestFilesCount * (baseShardSize + 1) + (index - remainderTestFilesCount - 1) * baseShardSize, shardEnd = shardStart + baseShardSize;
    return [shardStart, shardEnd];
  }
};
var RandomSequencer = class extends BaseSequencer {
  async sort(files) {
    const { sequence } = this.ctx.config;
    return shuffle(files, sequence.seed);
  }
};
function resolvePath(path3, root) {
  return normalize(resolveModule(path3, { paths: [root] }) ?? resolve(root, path3));
}
function parseInspector(inspect2) {
  if (typeof inspect2 === "boolean" || inspect2 === void 0) return {};
  if (typeof inspect2 === "number") return { port: inspect2 };
  if (inspect2.match(/https?:\//)) throw new Error(`Inspector host cannot be a URL. Use "host:port" instead of "${inspect2}"`);
  const [host, port] = inspect2.split(":");
  return port ? {
    host,
    port: Number(port) || defaultInspectPort
  } : { host };
}
function resolveApiServerConfig(options, defaultPort2) {
  let api;
  if (options.ui && !options.api) api = { port: defaultPort2 };
  else if (options.api === true) api = { port: defaultPort2 };
  else if (typeof options.api === "number") api = { port: options.api };
  if (typeof options.api === "object") if (api) {
    if (options.api.port) api.port = options.api.port;
    if (options.api.strictPort) api.strictPort = options.api.strictPort;
    if (options.api.host) api.host = options.api.host;
  } else api = { ...options.api };
  if (api) {
    if (!api.port && !api.middlewareMode) api.port = defaultPort2;
  } else api = { middlewareMode: true };
  return api;
}
function resolveInlineWorkerOption(value) {
  return typeof value === "string" && value.trim().endsWith("%") ? getWorkersCountByPercentage(value) : Number(value);
}
function resolveConfig$1(vitest, options, viteConfig) {
  var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q;
  const mode = vitest.mode, logger = vitest.logger;
  if (options.dom) {
    if (((_a2 = viteConfig.test) == null ? void 0 : _a2.environment) != null && viteConfig.test.environment !== "happy-dom") logger.console.warn(C.yellow(`${C.inverse(C.yellow(" Vitest "))} Your config.test.environment ("${viteConfig.test.environment}") conflicts with --dom flag ("happy-dom"), ignoring "${viteConfig.test.environment}"`));
    options.environment = "happy-dom";
  }
  const resolved = {
    ...configDefaults,
    ...options,
    root: viteConfig.root,
    mode
  };
  if (options.pool && typeof options.pool !== "string") resolved.pool = options.pool.name, resolved.poolRunner = options.pool;
  if (resolved.pool ?? (resolved.pool = "forks"), resolved.project = toArray(resolved.project), resolved.provide ?? (resolved.provide = {}), resolved.name = typeof options.name === "string" ? options.name : ((_b2 = options.name) == null ? void 0 : _b2.label) || "", resolved.color = typeof options.name !== "string" ? (_c = options.name) == null ? void 0 : _c.color : void 0, resolved.environment === "browser") throw new Error(`Looks like you set "test.environment" to "browser". To enable Browser Mode, use "test.browser.enabled" instead.`);
  const inspector = resolved.inspect || resolved.inspectBrk;
  if (resolved.inspector = {
    ...resolved.inspector,
    ...parseInspector(inspector),
    enabled: !!inspector,
    waitForDebugger: ((_d = options.inspector) == null ? void 0 : _d.waitForDebugger) ?? !!resolved.inspectBrk
  }, viteConfig.base !== "/") resolved.base = viteConfig.base;
  if (resolved.clearScreen = resolved.clearScreen ?? viteConfig.clearScreen ?? true, options.shard) {
    if (resolved.watch) throw new Error("You cannot use --shard option with enabled watch");
    const [indexString, countString] = options.shard.split("/"), index = Math.abs(Number.parseInt(indexString, 10)), count = Math.abs(Number.parseInt(countString, 10));
    if (Number.isNaN(count) || count <= 0) throw new Error("--shard <count> must be a positive number");
    if (Number.isNaN(index) || index <= 0 || index > count) throw new Error("--shard <index> must be a positive number less then <count>");
    resolved.shard = {
      index,
      count
    };
  }
  if (resolved.standalone && !resolved.watch) throw new Error(`Vitest standalone mode requires --watch`);
  if (resolved.mergeReports && resolved.watch) throw new Error(`Cannot merge reports with --watch enabled`);
  if (resolved.maxWorkers) resolved.maxWorkers = resolveInlineWorkerOption(resolved.maxWorkers);
  if (resolved.fileParallelism ?? (resolved.fileParallelism = mode !== "benchmark"), !resolved.fileParallelism)
    resolved.maxWorkers = 1;
  if (resolved.maxConcurrency === 0) logger.console.warn(C.yellow(`The option "maxConcurrency" cannot be set to 0. Using default value ${configDefaults.maxConcurrency} instead.`)), resolved.maxConcurrency = configDefaults.maxConcurrency;
  if (resolved.inspect || resolved.inspectBrk) {
    if (resolved.fileParallelism) {
      const inspectOption = `--inspect${resolved.inspectBrk ? "-brk" : ""}`;
      throw new Error(`You cannot use ${inspectOption} without "--no-file-parallelism"`);
    }
  }
  if (vitest._cliOptions.browser && resolved.browser && (resolved.browser.enabled !== false || vitest._cliOptions.browser.enabled)) resolved.browser = mergeConfig(resolved.browser, vitest._cliOptions.browser);
  resolved.browser ?? (resolved.browser = {});
  const browser = resolved.browser;
  if (browser.enabled) {
    const instances = browser.instances;
    if (!browser.instances) browser.instances = [];
    if (!browser.instances.length && ((_e = browser.provider) == null ? void 0 : _e.name) === "preview") browser.instances = [{ browser: "chromium" }];
    if (browser.name && (instances == null ? void 0 : instances.length)) {
      if (browser.instances = browser.instances.filter((instance) => instance.browser === browser.name), !browser.instances.length) throw new Error([`"browser.instances" was set in the config, but the array is empty. Define at least one browser config.`, ` The "browser.name" was set to "${browser.name}" which filtered all configs (${instances.map((c) => c.browser).join(", ")}). Did you mean to use another name?`].join(""));
    }
  }
  const containsChromium = hasBrowserChromium(vitest, resolved), hasOnlyChromium = hasOnlyBrowserChromium(vitest, resolved);
  if (browser.enabled && (!containsChromium || !hasOnlyChromium)) {
    const browserConfig = `
{
  browser: {
    provider: ${((_f = browser.provider) == null ? void 0 : _f.name) || "preview"}(),
    instances: [
      ${(browser.instances || []).map((i) => `{ browser: '${i.browser}' }`).join(",\n      ")}
    ],
  },
}
    `.trim(), preferredProvider = !((_g = browser.provider) == null ? void 0 : _g.name) || browser.provider.name === "preview" ? "playwright" : browser.provider.name, correctExample = `
{
  browser: {
    provider: ${preferredProvider}(),
    instances: [
      { browser: '${preferredProvider === "playwright" ? "chromium" : "chrome"}' }
    ],
  },
}
    `.trim();
    if (!hasOnlyChromium && resolved.coverage.enabled && resolved.coverage.provider === "v8") {
      const coverageExample = `
{
  coverage: {
    provider: 'istanbul',
  },
}
      `.trim();
      throw new Error(`@vitest/coverage-v8 does not work with
${browserConfig}

Use either:
${correctExample}

...or change your coverage provider to:
${coverageExample}
`);
    }
    if (!containsChromium && (resolved.inspect || resolved.inspectBrk)) {
      const inspectOption = `--inspect${resolved.inspectBrk ? "-brk" : ""}`;
      throw new Error(`${inspectOption} does not work with
${browserConfig}

Use either:
${correctExample}

...or disable ${inspectOption}
`);
    }
  }
  if (resolved.coverage.reporter = resolveCoverageReporters(resolved.coverage.reporter), resolved.coverage.enabled && resolved.coverage.reportsDirectory) {
    const reportsDirectory = resolve(resolved.root, resolved.coverage.reportsDirectory);
    if (reportsDirectory === resolved.root || reportsDirectory === process.cwd()) throw new Error(`You cannot set "coverage.reportsDirectory" as ${reportsDirectory}. Vitest needs to be able to remove this directory before test run`);
  }
  if (resolved.coverage.enabled && resolved.coverage.provider === "custom" && resolved.coverage.customProviderModule) resolved.coverage.customProviderModule = resolvePath(resolved.coverage.customProviderModule, resolved.root);
  if (resolved.expect ?? (resolved.expect = {}), resolved.deps ?? (resolved.deps = {}), (_h = resolved.deps).moduleDirectories ?? (_h.moduleDirectories = []), (_i = resolved.deps).optimizer ?? (_i.optimizer = {}), (_j = resolved.deps.optimizer).ssr ?? (_j.ssr = {}), (_k = resolved.deps.optimizer.ssr).enabled ?? (_k.enabled = false), (_l = resolved.deps.optimizer).client ?? (_l.client = {}), (_m = resolved.deps.optimizer.client).enabled ?? (_m.enabled = false), (_n = resolved.deps).web ?? (_n.web = {}), (_o = resolved.deps.web).transformAssets ?? (_o.transformAssets = true), (_p = resolved.deps.web).transformCss ?? (_p.transformCss = true), (_q = resolved.deps.web).transformGlobPattern ?? (_q.transformGlobPattern = []), resolved.setupFiles = toArray(resolved.setupFiles || []).map((file) => resolvePath(file, resolved.root)), resolved.globalSetup = toArray(resolved.globalSetup || []).map((file) => resolvePath(file, resolved.root)), resolved.coverage.exclude = [
    ...resolved.coverage.exclude,
    ...resolved.setupFiles.map((file) => `${resolved.coverage.allowExternal ? "**/" : ""}${relative(resolved.root, file)}`),
    ...resolved.include,
    resolved.config && slash(resolved.config),
    ...configFiles,
    "**/virtual:*",
    "**/__x00__*",
    "**/node_modules/**"
  ].filter((pattern) => typeof pattern === "string"), resolved.forceRerunTriggers = [...resolved.forceRerunTriggers, ...resolved.setupFiles], resolved.cliExclude) resolved.exclude.push(...resolved.cliExclude);
  if (resolved.runner) resolved.runner = resolvePath(resolved.runner, resolved.root);
  if (resolved.attachmentsDir = resolve(resolved.root, resolved.attachmentsDir ?? ".vitest-attachments"), resolved.snapshotEnvironment) resolved.snapshotEnvironment = resolvePath(resolved.snapshotEnvironment, resolved.root);
  if (resolved.testNamePattern = resolved.testNamePattern ? resolved.testNamePattern instanceof RegExp ? resolved.testNamePattern : new RegExp(resolved.testNamePattern) : void 0, resolved.snapshotFormat && "plugins" in resolved.snapshotFormat) {
    if (resolved.snapshotFormat.plugins = [], typeof resolved.snapshotFormat.compareKeys === "function") throw new TypeError(`"snapshotFormat.compareKeys" function is not supported.`);
  }
  const UPDATE_SNAPSHOT = resolved.update || process.env.UPDATE_SNAPSHOT;
  if (resolved.snapshotOptions = {
    expand: resolved.expandSnapshotDiff ?? false,
    snapshotFormat: resolved.snapshotFormat || {},
    updateSnapshot: T && !UPDATE_SNAPSHOT ? "none" : UPDATE_SNAPSHOT ? "all" : "new",
    resolveSnapshotPath: options.resolveSnapshotPath,
    snapshotEnvironment: null
  }, resolved.snapshotSerializers ?? (resolved.snapshotSerializers = []), resolved.snapshotSerializers = resolved.snapshotSerializers.map((file) => resolvePath(file, resolved.root)), resolved.forceRerunTriggers.push(...resolved.snapshotSerializers), options.resolveSnapshotPath) delete resolved.resolveSnapshotPath;
  if (resolved.execArgv ?? (resolved.execArgv = []), resolved.pool ?? (resolved.pool = "threads"), resolved.pool === "vmForks" || resolved.pool === "vmThreads" || resolved.pool === "typescript") resolved.isolate = false;
  if (process.env.VITEST_MAX_WORKERS) resolved.maxWorkers = Number.parseInt(process.env.VITEST_MAX_WORKERS);
  if (mode === "benchmark") {
    resolved.benchmark = {
      ...benchmarkConfigDefaults,
      ...resolved.benchmark
    }, resolved.coverage.enabled = false, resolved.typecheck.enabled = false, resolved.include = resolved.benchmark.include, resolved.exclude = resolved.benchmark.exclude, resolved.includeSource = resolved.benchmark.includeSource;
    const reporters = Array.from(/* @__PURE__ */ new Set([...toArray(resolved.benchmark.reporters), ...toArray(options.reporter)])).filter(Boolean);
    if (reporters.length) resolved.benchmark.reporters = reporters;
    else resolved.benchmark.reporters = ["default"];
    if (options.outputFile) resolved.benchmark.outputFile = options.outputFile;
    if (options.compare) resolved.benchmark.compare = options.compare;
    if (options.outputJson) resolved.benchmark.outputJson = options.outputJson;
  }
  if (typeof resolved.diff === "string") resolved.diff = resolvePath(resolved.diff, resolved.root), resolved.forceRerunTriggers.push(resolved.diff);
  if (resolved.api = {
    ...resolveApiServerConfig(options, defaultPort),
    token: import_node_crypto.default.randomUUID()
  }, options.related) resolved.related = toArray(options.related).map((file) => resolve(resolved.root, file));
  if (options.reporters) if (!Array.isArray(options.reporters))
    if (typeof options.reporters === "string") resolved.reporters = [[options.reporters, {}]];
    else resolved.reporters = [options.reporters];
  else {
    resolved.reporters = [];
    for (const reporter of options.reporters) if (Array.isArray(reporter))
      resolved.reporters.push([reporter[0], reporter[1] || {}]);
    else if (typeof reporter === "string")
      resolved.reporters.push([reporter, {}]);
    else
      resolved.reporters.push(reporter);
  }
  if (mode !== "benchmark") {
    const reportersFromCLI = resolved.reporter, cliReporters = toArray(reportersFromCLI || []).map((reporter) => {
      return /^\.\.?\//.test(reporter) ? resolve(process.cwd(), reporter) : reporter;
    });
    if (cliReporters.length) {
      const configReportersMap = /* @__PURE__ */ new Map();
      for (const reporter of resolved.reporters) if (Array.isArray(reporter)) {
        const [reporterName, reporterOptions] = reporter;
        if (typeof reporterName === "string") configReportersMap.set(reporterName, reporterOptions);
      }
      resolved.reporters = Array.from(new Set(toArray(cliReporters))).filter(Boolean).map((reporter) => [reporter, configReportersMap.get(reporter) || {}]);
    }
  }
  if (!resolved.reporters.length) {
    if (resolved.reporters.push(["default", {}]), process.env.GITHUB_ACTIONS === "true") resolved.reporters.push(["github-actions", {}]);
  }
  if (resolved.changed) resolved.passWithNoTests ?? (resolved.passWithNoTests = true);
  if (resolved.css ?? (resolved.css = {}), typeof resolved.css === "object") (_r = resolved.css).modules ?? (_r.modules = {}), (_s = resolved.css.modules).classNameStrategy ?? (_s.classNameStrategy = "stable");
  if (resolved.cache !== false) {
    if (resolved.cache && typeof resolved.cache.dir === "string") vitest.logger.deprecate(`"cache.dir" is deprecated, use Vite's "cacheDir" instead if you want to change the cache director. Note caches will be written to "cacheDir/vitest"`);
    resolved.cache = { dir: viteConfig.cacheDir };
  }
  if (resolved.sequence ?? (resolved.sequence = {}), resolved.sequence.shuffle && typeof resolved.sequence.shuffle === "object") {
    const { files, tests } = resolved.sequence.shuffle;
    (_t = resolved.sequence).sequencer ?? (_t.sequencer = files ? RandomSequencer : BaseSequencer), resolved.sequence.shuffle = tests;
  }
  if (!((_u = resolved.sequence) == null ? void 0 : _u.sequencer))
    resolved.sequence.sequencer = resolved.sequence.shuffle ? RandomSequencer : BaseSequencer;
  if ((_v = resolved.sequence).groupOrder ?? (_v.groupOrder = 0), (_w = resolved.sequence).hooks ?? (_w.hooks = "stack"), resolved.sequence.sequencer === RandomSequencer) (_x = resolved.sequence).seed ?? (_x.seed = Date.now());
  if (resolved.typecheck = {
    ...configDefaults.typecheck,
    ...resolved.typecheck
  }, resolved.typecheck ?? (resolved.typecheck = {}), (_y = resolved.typecheck).enabled ?? (_y.enabled = false), resolved.typecheck.enabled) logger.console.warn(C.yellow("Testing types with tsc and vue-tsc is an experimental feature.\nBreaking changes might not follow SemVer, please pin Vitest's version when using it."));
  if ((_z = resolved.browser).enabled ?? (_z.enabled = false), (_A = resolved.browser).headless ?? (_A.headless = T), (_B = resolved.browser).isolate ?? (_B.isolate = true), (_C = resolved.browser).fileParallelism ?? (_C.fileParallelism = options.fileParallelism ?? mode !== "benchmark"), (_D = resolved.browser).ui ?? (_D.ui = resolved.browser.headless === true ? false : !T), (_E = resolved.browser).commands ?? (_E.commands = {}), resolved.browser.screenshotDirectory) resolved.browser.screenshotDirectory = resolve(resolved.root, resolved.browser.screenshotDirectory);
  if (resolved.inspector.enabled) (_F = resolved.browser).trackUnhandledErrors ?? (_F.trackUnhandledErrors = false);
  if ((_G = resolved.browser).viewport ?? (_G.viewport = {}), (_H = resolved.browser.viewport).width ?? (_H.width = 414), (_I = resolved.browser.viewport).height ?? (_I.height = 896), (_J = resolved.browser).locators ?? (_J.locators = {}), (_K = resolved.browser.locators).testIdAttribute ?? (_K.testIdAttribute = "data-testid"), typeof resolved.browser.provider === "string") {
    const source = `@vitest/browser-${resolved.browser.provider}`;
    throw new TypeError(`The \`browser.provider\` configuration was changed to accept a factory instead of a string. Add an import of "${resolved.browser.provider}" from "${source}" instead. See: https://vitest.dev/guide/browser/config#provider`);
  }
  const isPreview = ((_L = resolved.browser.provider) == null ? void 0 : _L.name) === "preview";
  if (!isPreview && resolved.browser.enabled && p === "stackblitz") throw new Error(`stackblitz environment does not support the ${(_M = resolved.browser.provider) == null ? void 0 : _M.name} provider. Please, use "@vitest/browser-preview" instead.`);
  if (isPreview && resolved.browser.screenshotFailures === true) console.warn(C.yellow([
    `Browser provider "preview" doesn't support screenshots, `,
    `so "browser.screenshotFailures" option is forcefully disabled. `,
    `Set "browser.screenshotFailures" to false or remove it from the config to suppress this warning.`
  ].join(""))), resolved.browser.screenshotFailures = false;
  else (_N = resolved.browser).screenshotFailures ?? (_N.screenshotFailures = !isPreview && !resolved.browser.ui);
  if (resolved.browser.provider && resolved.browser.provider.options == null) resolved.browser.provider.options = {};
  if (resolved.browser.api = resolveApiServerConfig(resolved.browser, defaultBrowserPort) || { port: defaultBrowserPort }, resolved.browser.enabled) {
    if (resolved.browser.ui) resolved.includeTaskLocation ?? (resolved.includeTaskLocation = true);
  } else if (resolved.ui) resolved.includeTaskLocation ?? (resolved.includeTaskLocation = true);
  if (typeof resolved.browser.trace === "string" || !resolved.browser.trace) resolved.browser.trace = { mode: resolved.browser.trace || "off" };
  if (resolved.browser.trace.tracesDir != null) resolved.browser.trace.tracesDir = resolvePath(resolved.browser.trace.tracesDir, resolved.root);
  if (toArray(resolved.reporters).some((reporter) => {
    return Array.isArray(reporter) ? reporter[0] === "html" : false;
  })) resolved.includeTaskLocation ?? (resolved.includeTaskLocation = true);
  if (resolved.server ?? (resolved.server = {}), (_O = resolved.server).deps ?? (_O.deps = {}), ((_P = resolved.server.debug) == null ? void 0 : _P.dump) || process.env.VITEST_DEBUG_DUMP) {
    const userFolder = ((_Q = resolved.server.debug) == null ? void 0 : _Q.dump) || process.env.VITEST_DEBUG_DUMP;
    resolved.dumpDir = resolve(resolved.root, typeof userFolder === "string" && userFolder !== "true" ? userFolder : ".vitest-dump", resolved.name || "root");
  }
  return resolved.testTimeout ?? (resolved.testTimeout = resolved.browser.enabled ? 3e4 : 5e3), resolved.hookTimeout ?? (resolved.hookTimeout = resolved.browser.enabled ? 3e4 : 1e4), resolved;
}
function isBrowserEnabled(config) {
  var _a2;
  return Boolean((_a2 = config.browser) == null ? void 0 : _a2.enabled);
}
function resolveCoverageReporters(configReporters) {
  if (!Array.isArray(configReporters)) return [[configReporters, {}]];
  const resolvedReporters = [];
  for (const reporter of configReporters) if (Array.isArray(reporter))
    resolvedReporters.push([reporter[0], reporter[1] || {}]);
  else
    resolvedReporters.push([reporter, {}]);
  return resolvedReporters;
}
function isChromiumName(provider, name) {
  return provider === "playwright" ? name === "chromium" : name === "chrome" || name === "edge";
}
function hasBrowserChromium(vitest, config) {
  const browser = config.browser;
  return !browser || !browser.provider || browser.provider.name === "preview" || !browser.enabled ? false : browser.name ? isChromiumName(browser.provider.name, browser.name) : browser.instances ? browser.instances.some((instance) => {
    const name = instance.name || (config.name ? `${config.name} (${instance.browser})` : instance.browser);
    return vitest.matchesProjectFilter(name) ? isChromiumName(browser.provider.name, instance.browser) : false;
  }) : false;
}
function hasOnlyBrowserChromium(vitest, config) {
  const browser = config.browser;
  return !browser || !browser.provider || browser.provider.name === "preview" || !browser.enabled ? false : browser.name ? isChromiumName(browser.provider.name, browser.name) : browser.instances ? browser.instances.every((instance) => {
    const name = instance.name || (config.name ? `${config.name} (${instance.browser})` : instance.browser);
    return vitest.matchesProjectFilter(name) ? isChromiumName(browser.provider.name, instance.browser) : true;
  }) : false;
}
var DEFAULT_PROJECT = Symbol.for("default-project");
async function getCoverageProvider(options, loader) {
  const coverageModule = await resolveCoverageProviderModule(options, loader);
  return coverageModule ? coverageModule.getProvider() : null;
}

// node_modules/vitest/dist/chunks/cli-api.6GYRwzrM.js
var nodeos = __toESM(require_node_os(), 1);
var import_node_os3 = __toESM(require_node_os(), 1);

// node_modules/@vitest/snapshot/dist/manager.js
var SnapshotManager = class {
  constructor(options) {
    __publicField(this, "summary");
    __publicField(this, "extension", ".snap");
    this.options = options;
    this.clear();
  }
  clear() {
    this.summary = emptySummary(this.options);
  }
  add(result) {
    addSnapshotResult(this.summary, result);
  }
  resolvePath(testPath, context) {
    const resolver = this.options.resolveSnapshotPath || (() => {
      return join(join(dirname(testPath), "__snapshots__"), `${basename(testPath)}${this.extension}`);
    });
    const path3 = resolver(testPath, this.extension, context);
    return path3;
  }
  resolveRawPath(testPath, rawPath) {
    return isAbsolute(rawPath) ? rawPath : resolve(dirname(testPath), rawPath);
  }
};
function emptySummary(options) {
  const summary = {
    added: 0,
    failure: false,
    filesAdded: 0,
    filesRemoved: 0,
    filesRemovedList: [],
    filesUnmatched: 0,
    filesUpdated: 0,
    matched: 0,
    total: 0,
    unchecked: 0,
    uncheckedKeysByFile: [],
    unmatched: 0,
    updated: 0,
    didUpdate: options.updateSnapshot === "all"
  };
  return summary;
}
function addSnapshotResult(summary, result) {
  if (result.added) {
    summary.filesAdded++;
  }
  if (result.fileDeleted) {
    summary.filesRemoved++;
  }
  if (result.unmatched) {
    summary.filesUnmatched++;
  }
  if (result.updated) {
    summary.filesUpdated++;
  }
  summary.added += result.added;
  summary.matched += result.matched;
  summary.unchecked += result.unchecked;
  if (result.uncheckedKeys && result.uncheckedKeys.length > 0) {
    summary.uncheckedKeysByFile.push({
      filePath: result.filepath,
      keys: result.uncheckedKeys
    });
  }
  summary.unmatched += result.unmatched;
  summary.updated += result.updated;
  summary.total += result.added + result.matched + result.unmatched + result.updated;
}

// node_modules/vitest/dist/chunks/cac.Be29vze6.js
var import_events = __toESM(require_events(), 1);
function toArr(any2) {
  return any2 == null ? [] : Array.isArray(any2) ? any2 : [any2];
}
function toVal(out, key, val, opts) {
  var x, old = out[key], nxt = !!~opts.string.indexOf(key) ? val == null || val === true ? "" : String(val) : typeof val === "boolean" ? val : !!~opts.boolean.indexOf(key) ? val === "false" ? false : val === "true" || (out._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;
  out[key] = old == null ? nxt : Array.isArray(old) ? old.concat(nxt) : [old, nxt];
}
function mri2(args, opts) {
  args = args || [];
  opts = opts || {};
  var k, arr, arg, name, val, out = { _: [] };
  var i = 0, j = 0, idx = 0, len = args.length;
  const alibi = opts.alias !== void 0;
  const strict = opts.unknown !== void 0;
  const defaults = opts.default !== void 0;
  opts.alias = opts.alias || {};
  opts.string = toArr(opts.string);
  opts.boolean = toArr(opts.boolean);
  if (alibi) {
    for (k in opts.alias) {
      arr = opts.alias[k] = toArr(opts.alias[k]);
      for (i = 0; i < arr.length; i++) {
        (opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
      }
    }
  }
  for (i = opts.boolean.length; i-- > 0; ) {
    arr = opts.alias[opts.boolean[i]] || [];
    for (j = arr.length; j-- > 0; ) opts.boolean.push(arr[j]);
  }
  for (i = opts.string.length; i-- > 0; ) {
    arr = opts.alias[opts.string[i]] || [];
    for (j = arr.length; j-- > 0; ) opts.string.push(arr[j]);
  }
  if (defaults) {
    for (k in opts.default) {
      name = typeof opts.default[k];
      arr = opts.alias[k] = opts.alias[k] || [];
      if (opts[name] !== void 0) {
        opts[name].push(k);
        for (i = 0; i < arr.length; i++) {
          opts[name].push(arr[i]);
        }
      }
    }
  }
  const keys2 = strict ? Object.keys(opts.alias) : [];
  for (i = 0; i < len; i++) {
    arg = args[i];
    if (arg === "--") {
      out._ = out._.concat(args.slice(++i));
      break;
    }
    for (j = 0; j < arg.length; j++) {
      if (arg.charCodeAt(j) !== 45) break;
    }
    if (j === 0) {
      out._.push(arg);
    } else if (arg.substring(j, j + 3) === "no-") {
      name = arg.substring(j + 3);
      if (strict && !~keys2.indexOf(name)) {
        return opts.unknown(arg);
      }
      out[name] = false;
    } else {
      for (idx = j + 1; idx < arg.length; idx++) {
        if (arg.charCodeAt(idx) === 61) break;
      }
      name = arg.substring(j, idx);
      val = arg.substring(++idx) || (i + 1 === len || ("" + args[i + 1]).charCodeAt(0) === 45 || args[++i]);
      arr = j === 2 ? [name] : name;
      for (idx = 0; idx < arr.length; idx++) {
        name = arr[idx];
        if (strict && !~keys2.indexOf(name)) return opts.unknown("-".repeat(j) + name);
        toVal(out, name, idx + 1 < arr.length || val, opts);
      }
    }
  }
  if (defaults) {
    for (k in opts.default) {
      if (out[k] === void 0) {
        out[k] = opts.default[k];
      }
    }
  }
  if (alibi) {
    for (k in out) {
      arr = opts.alias[k] || [];
      while (arr.length > 0) {
        out[arr.shift()] = out[k];
      }
    }
  }
  return out;
}
var removeBrackets = (v) => v.replace(/[<[].+/, "").trim();
var findAllBrackets = (v) => {
  const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
  const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
  const res = [];
  const parse2 = (match) => {
    let variadic = false;
    let value = match[1];
    if (value.startsWith("...")) {
      value = value.slice(3);
      variadic = true;
    }
    return {
      required: match[0].startsWith("<"),
      value,
      variadic
    };
  };
  let angledMatch;
  while (angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse2(angledMatch));
  }
  let squareMatch;
  while (squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse2(squareMatch));
  }
  return res;
};
var getMriOptions = (options) => {
  const result = { alias: {}, boolean: [] };
  for (const [index, option] of options.entries()) {
    if (option.names.length > 1) {
      result.alias[option.names[0]] = option.names.slice(1);
    }
    if (option.isBoolean) {
      if (option.negated) {
        const hasStringTypeOption = options.some((o, i) => {
          return i !== index && o.names.some((name) => option.names.includes(name)) && typeof o.required === "boolean";
        });
        if (!hasStringTypeOption) {
          result.boolean.push(option.names[0]);
        }
      } else {
        result.boolean.push(option.names[0]);
      }
    }
  }
  return result;
};
var findLongest = (arr) => {
  return arr.sort((a, b) => {
    return a.length > b.length ? -1 : 1;
  })[0];
};
var padRight = (str, length) => {
  return str.length >= length ? str : `${str}${" ".repeat(length - str.length)}`;
};
var camelcase = (input) => {
  return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {
    return p1 + p2.toUpperCase();
  });
};
var setDotProp = (obj, keys2, val, transforms) => {
  let i = 0;
  let length = keys2.length;
  let t = obj;
  let x;
  let convertKey = (i2) => {
    let key = keys2[i2];
    i2--;
    while (i2 >= 0) {
      key = keys2[i2] + "." + key;
      i2--;
    }
    return key;
  };
  for (; i < length; ++i) {
    x = t[keys2[i]];
    const transform = transforms[convertKey(i)] || ((v) => v);
    t = t[keys2[i]] = transform(i === length - 1 ? val : x != null ? x : !!~keys2[i + 1].indexOf(".") || !(+keys2[i + 1] > -1) ? {} : []);
  }
};
var getFileName = (input) => {
  const m = /([^\\\/]+)$/.exec(input);
  return m ? m[1] : "";
};
var camelcaseOptionName = (name) => {
  return name.split(".").map((v, i) => {
    return i === 0 ? camelcase(v) : v;
  }).join(".");
};
var CACError = class extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
};
var Option = class {
  constructor(rawName, description, config) {
    this.rawName = rawName;
    this.description = description;
    this.config = Object.assign({}, config);
    rawName = rawName.replace(/\.\*/g, "");
    this.negated = false;
    this.names = removeBrackets(rawName).split(",").map((v) => {
      let name = v.trim().replace(/^-{1,2}/, "");
      if (name.startsWith("no-")) {
        this.negated = true;
        name = name.replace(/^no-/, "");
      }
      return camelcaseOptionName(name);
    }).sort((a, b) => a.length > b.length ? 1 : -1);
    this.name = this.names[this.names.length - 1];
    if (this.negated && this.config.default == null) {
      this.config.default = true;
    }
    if (rawName.includes("<")) {
      this.required = true;
    } else if (rawName.includes("[")) {
      this.required = false;
    } else {
      this.isBoolean = true;
    }
  }
};
var processArgs = process.argv;
var platformInfo = `${process.platform}-${process.arch} node-${process.version}`;
var Command = class {
  constructor(rawName, description, config = {}, cli) {
    this.rawName = rawName;
    this.description = description;
    this.config = config;
    this.cli = cli;
    this.options = [];
    this.aliasNames = [];
    this.name = removeBrackets(rawName);
    this.args = findAllBrackets(rawName);
    this.examples = [];
  }
  usage(text) {
    this.usageText = text;
    return this;
  }
  allowUnknownOptions() {
    this.config.allowUnknownOptions = true;
    return this;
  }
  ignoreOptionDefaultValue() {
    this.config.ignoreOptionDefaultValue = true;
    return this;
  }
  version(version2, customFlags = "-v, --version") {
    this.versionNumber = version2;
    this.option(customFlags, "Display version number");
    return this;
  }
  example(example) {
    this.examples.push(example);
    return this;
  }
  option(rawName, description, config) {
    const option = new Option(rawName, description, config);
    this.options.push(option);
    return this;
  }
  alias(name) {
    this.aliasNames.push(name);
    return this;
  }
  action(callback) {
    this.commandAction = callback;
    return this;
  }
  isMatched(name) {
    return this.name === name || this.aliasNames.includes(name);
  }
  get isDefaultCommand() {
    return this.name === "" || this.aliasNames.includes("!");
  }
  get isGlobalCommand() {
    return this instanceof GlobalCommand;
  }
  hasOption(name) {
    name = name.split(".")[0];
    return this.options.find((option) => {
      return option.names.includes(name);
    });
  }
  outputHelp() {
    const { name, commands } = this.cli;
    const {
      versionNumber,
      options: globalOptions,
      helpCallback
    } = this.cli.globalCommand;
    let sections = [
      {
        body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
      }
    ];
    sections.push({
      title: "Usage",
      body: `  $ ${name} ${this.usageText || this.rawName}`
    });
    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
    if (showCommands) {
      const longestCommandName = findLongest(commands.map((command) => command.rawName));
      sections.push({
        title: "Commands",
        body: commands.map((command) => {
          return `  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`;
        }).join("\n")
      });
      sections.push({
        title: `For more info, run any command with the \`--help\` flag`,
        body: commands.map((command) => `  $ ${name}${command.name === "" ? "" : ` ${command.name}`} --help`).join("\n")
      });
    }
    let options = this.isGlobalCommand ? globalOptions : [...this.options, ...globalOptions || []];
    if (!this.isGlobalCommand && !this.isDefaultCommand) {
      options = options.filter((option) => option.name !== "version");
    }
    if (options.length > 0) {
      const longestOptionName = findLongest(options.map((option) => option.rawName));
      sections.push({
        title: "Options",
        body: options.map((option) => {
          return `  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === void 0 ? "" : `(default: ${option.config.default})`}`;
        }).join("\n")
      });
    }
    if (this.examples.length > 0) {
      sections.push({
        title: "Examples",
        body: this.examples.map((example) => {
          if (typeof example === "function") {
            return example(name);
          }
          return example;
        }).join("\n")
      });
    }
    if (helpCallback) {
      sections = helpCallback(sections) || sections;
    }
    console.log(sections.map((section) => {
      return section.title ? `${section.title}:
${section.body}` : section.body;
    }).join("\n\n"));
  }
  outputVersion() {
    const { name } = this.cli;
    const { versionNumber } = this.cli.globalCommand;
    if (versionNumber) {
      console.log(`${name}/${versionNumber} ${platformInfo}`);
    }
  }
  checkRequiredArgs() {
    const minimalArgsCount = this.args.filter((arg) => arg.required).length;
    if (this.cli.args.length < minimalArgsCount) {
      throw new CACError(`missing required args for command \`${this.rawName}\``);
    }
  }
  checkUnknownOptions() {
    const { options, globalCommand } = this.cli;
    if (!this.config.allowUnknownOptions) {
      for (const name of Object.keys(options)) {
        if (name !== "--" && !this.hasOption(name) && !globalCommand.hasOption(name)) {
          throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
        }
      }
    }
  }
  checkOptionValue() {
    const { options: parsedOptions, globalCommand } = this.cli;
    const options = [...globalCommand.options, ...this.options];
    for (const option of options) {
      if (option.name.includes(".")) {
        continue;
      }
      const value = parsedOptions[option.name];
      if (option.required) {
        const hasNegated = options.some((o) => o.negated && o.names.includes(option.name));
        if (value === true || value === false && !hasNegated) {
          throw new CACError(`option \`${option.rawName}\` value is missing`);
        }
      }
    }
  }
};
var GlobalCommand = class extends Command {
  constructor(cli) {
    super("@@global@@", "", {}, cli);
  }
};
var __assign = Object.assign;
var CAC = class extends import_events.EventEmitter {
  constructor(name = "") {
    super();
    this.name = name;
    this.commands = [];
    this.rawArgs = [];
    this.args = [];
    this.options = {};
    this.globalCommand = new GlobalCommand(this);
    this.globalCommand.usage("<command> [options]");
  }
  usage(text) {
    this.globalCommand.usage(text);
    return this;
  }
  command(rawName, description, config) {
    const command = new Command(rawName, description || "", config, this);
    command.globalCommand = this.globalCommand;
    this.commands.push(command);
    return command;
  }
  option(rawName, description, config) {
    this.globalCommand.option(rawName, description, config);
    return this;
  }
  help(callback) {
    this.globalCommand.option("-h, --help", "Display this message");
    this.globalCommand.helpCallback = callback;
    this.showHelpOnExit = true;
    return this;
  }
  version(version2, customFlags = "-v, --version") {
    this.globalCommand.version(version2, customFlags);
    this.showVersionOnExit = true;
    return this;
  }
  example(example) {
    this.globalCommand.example(example);
    return this;
  }
  outputHelp() {
    if (this.matchedCommand) {
      this.matchedCommand.outputHelp();
    } else {
      this.globalCommand.outputHelp();
    }
  }
  outputVersion() {
    this.globalCommand.outputVersion();
  }
  setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
    this.args = args;
    this.options = options;
    if (matchedCommand) {
      this.matchedCommand = matchedCommand;
    }
    if (matchedCommandName) {
      this.matchedCommandName = matchedCommandName;
    }
    return this;
  }
  unsetMatchedCommand() {
    this.matchedCommand = void 0;
    this.matchedCommandName = void 0;
  }
  parse(argv = processArgs, {
    run: run2 = true
  } = {}) {
    this.rawArgs = argv;
    if (!this.name) {
      this.name = argv[1] ? getFileName(argv[1]) : "cli";
    }
    let shouldParse = true;
    for (const command of this.commands) {
      const parsed = this.mri(argv.slice(2), command);
      const commandName = parsed.args[0];
      if (command.isMatched(commandName)) {
        shouldParse = false;
        const parsedInfo = __assign(__assign({}, parsed), {
          args: parsed.args.slice(1)
        });
        this.setParsedInfo(parsedInfo, command, commandName);
        this.emit(`command:${commandName}`, command);
      }
    }
    if (shouldParse) {
      for (const command of this.commands) {
        if (command.name === "") {
          shouldParse = false;
          const parsed = this.mri(argv.slice(2), command);
          this.setParsedInfo(parsed, command);
          this.emit(`command:!`, command);
        }
      }
    }
    if (shouldParse) {
      const parsed = this.mri(argv.slice(2));
      this.setParsedInfo(parsed);
    }
    if (this.options.help && this.showHelpOnExit) {
      this.outputHelp();
      run2 = false;
      this.unsetMatchedCommand();
    }
    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {
      this.outputVersion();
      run2 = false;
      this.unsetMatchedCommand();
    }
    const parsedArgv = { args: this.args, options: this.options };
    if (run2) {
      this.runMatchedCommand();
    }
    if (!this.matchedCommand && this.args[0]) {
      this.emit("command:*");
    }
    return parsedArgv;
  }
  mri(argv, command) {
    const cliOptions = [
      ...this.globalCommand.options,
      ...command ? command.options : []
    ];
    const mriOptions = getMriOptions(cliOptions);
    let argsAfterDoubleDashes = [];
    const doubleDashesIndex = argv.indexOf("--");
    if (doubleDashesIndex > -1) {
      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
      argv = argv.slice(0, doubleDashesIndex);
    }
    let parsed = mri2(argv, mriOptions);
    parsed = Object.keys(parsed).reduce((res, name) => {
      return __assign(__assign({}, res), {
        [camelcaseOptionName(name)]: parsed[name]
      });
    }, { _: [] });
    const args = parsed._;
    const options = {
      "--": argsAfterDoubleDashes
    };
    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
    let transforms = /* @__PURE__ */ Object.create(null);
    for (const cliOption of cliOptions) {
      if (!ignoreDefault && cliOption.config.default !== void 0) {
        for (const name of cliOption.names) {
          options[name] = cliOption.config.default;
        }
      }
      if (cliOption.config.type != null) {
        if (transforms[cliOption.name] === void 0) {
          transforms[cliOption.name] = cliOption.config.type;
        }
      }
    }
    for (const key of Object.keys(parsed)) {
      if (key !== "_") {
        const keys2 = key.split(".");
        setDotProp(options, keys2, parsed[key], transforms);
      }
    }
    return {
      args,
      options
    };
  }
  runMatchedCommand() {
    const { args, options, matchedCommand: command } = this;
    if (!command || !command.commandAction)
      return;
    command.checkUnknownOptions();
    command.checkOptionValue();
    command.checkRequiredArgs();
    const actionArgs = [];
    command.args.forEach((arg, index) => {
      if (arg.variadic) {
        actionArgs.push(args.slice(index));
      } else {
        actionArgs.push(args[index]);
      }
    });
    actionArgs.push(options);
    return command.commandAction.apply(this, actionArgs);
  }
};
var cac = (name = "") => new CAC(name);
var version = "4.0.5";
var apiConfig = (port) => ({
  port: {
    description: `Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on. If true will be set to \`${port}\``,
    argument: "[port]"
  },
  host: {
    description: "Specify which IP addresses the server should listen on. Set this to `0.0.0.0` or `true` to listen on all addresses, including LAN and public addresses",
    argument: "[host]"
  },
  strictPort: { description: "Set to true to exit if port is already in use, instead of automatically trying the next available port" },
  middlewareMode: null
});
function watermarkTransform(value) {
  return typeof value === "string" ? value.split(",").map(Number) : value;
}
function transformNestedBoolean(value) {
  return typeof value === "boolean" ? { enabled: value } : value;
}
var cliOptionsConfig = {
  root: {
    description: "Root path",
    shorthand: "r",
    argument: "<path>",
    normalize: true
  },
  config: {
    shorthand: "c",
    description: "Path to config file",
    argument: "<path>",
    normalize: true
  },
  update: {
    shorthand: "u",
    description: "Update snapshot"
  },
  watch: {
    shorthand: "w",
    description: "Enable watch mode"
  },
  testNamePattern: {
    description: "Run tests with full names matching the specified regexp pattern",
    argument: "<pattern>",
    shorthand: "t"
  },
  dir: {
    description: "Base directory to scan for the test files",
    argument: "<path>",
    normalize: true
  },
  ui: { description: "Enable UI" },
  open: { description: "Open UI automatically (default: `!process.env.CI`)" },
  api: {
    argument: "[port]",
    description: `Specify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on. If true will be set to ${defaultPort}`,
    subcommands: apiConfig(defaultPort)
  },
  silent: {
    description: "Silent console output from tests. Use `'passed-only'` to see logs from failing tests only.",
    argument: "[value]",
    transform(value) {
      if (value === "true" || value === "yes" || value === true) return true;
      if (value === "false" || value === "no" || value === false) return false;
      if (value === "passed-only") return value;
      throw new TypeError(`Unexpected value "--silent=${value}". Use "--silent=true ${value}" instead.`);
    }
  },
  hideSkippedTests: { description: "Hide logs for skipped tests" },
  reporters: {
    alias: "reporter",
    description: `Specify reporters (${Object.keys(ReportersMap).join(", ")})`,
    argument: "<name>",
    subcommands: null,
    array: true
  },
  outputFile: {
    argument: "<filename/-s>",
    description: "Write test results to a file when supporter reporter is also specified, use cac's dot notation for individual outputs of multiple reporters (example: `--outputFile.tap=./tap.txt`)",
    subcommands: null
  },
  coverage: {
    description: "Enable coverage report",
    argument: "",
    transform: transformNestedBoolean,
    subcommands: {
      provider: {
        description: 'Select the tool for coverage collection, available values are: "v8", "istanbul" and "custom"',
        argument: "<name>"
      },
      enabled: { description: "Enables coverage collection. Can be overridden using the `--coverage` CLI option (default: `false`)" },
      include: {
        description: "Files included in coverage as glob patterns. May be specified more than once when using multiple patterns. By default only files covered by tests are included.",
        argument: "<pattern>",
        array: true
      },
      exclude: {
        description: "Files to be excluded in coverage. May be specified more than once when using multiple extensions.",
        argument: "<pattern>",
        array: true
      },
      clean: { description: "Clean coverage results before running tests (default: true)" },
      cleanOnRerun: { description: "Clean coverage report on watch rerun (default: true)" },
      reportsDirectory: {
        description: "Directory to write coverage report to (default: ./coverage)",
        argument: "<path>",
        normalize: true
      },
      reporter: {
        description: 'Coverage reporters to use. Visit [`coverage.reporter`](https://vitest.dev/config/#coverage-reporter) for more information (default: `["text", "html", "clover", "json"]`)',
        argument: "<name>",
        subcommands: null,
        array: true
      },
      reportOnFailure: { description: "Generate coverage report even when tests fail (default: `false`)" },
      allowExternal: { description: "Collect coverage of files outside the project root (default: `false`)" },
      skipFull: { description: "Do not show files with 100% statement, branch, and function coverage (default: `false`)" },
      thresholds: {
        description: null,
        argument: "",
        subcommands: {
          perFile: { description: "Check thresholds per file. See `--coverage.thresholds.lines`, `--coverage.thresholds.functions`, `--coverage.thresholds.branches` and `--coverage.thresholds.statements` for the actual thresholds (default: `false`)" },
          autoUpdate: {
            description: 'Update threshold values: "lines", "functions", "branches" and "statements" to configuration file when current coverage is above the configured thresholds (default: `false`)',
            argument: "<boolean|function>",
            subcommands: null,
            transform(value) {
              return value === "true" || value === "yes" || value === true ? true : value === "false" || value === "no" || value === false ? false : value;
            }
          },
          lines: {
            description: "Threshold for lines. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers",
            argument: "<number>"
          },
          functions: {
            description: "Threshold for functions. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers",
            argument: "<number>"
          },
          branches: {
            description: "Threshold for branches. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers",
            argument: "<number>"
          },
          statements: {
            description: "Threshold for statements. Visit [istanbuljs](https://github.com/istanbuljs/nyc#coverage-thresholds) for more information. This option is not available for custom providers",
            argument: "<number>"
          },
          100: { description: "Shortcut to set all coverage thresholds to 100 (default: `false`)" }
        }
      },
      ignoreClassMethods: {
        description: "Array of class method names to ignore for coverage. Visit [istanbuljs](https://github.com/istanbuljs/nyc#ignoring-methods) for more information. This option is only available for the istanbul providers (default: `[]`)",
        argument: "<name>",
        array: true
      },
      processingConcurrency: {
        description: "Concurrency limit used when processing the coverage results. (default min between 20 and the number of CPUs)",
        argument: "<number>"
      },
      customProviderModule: {
        description: "Specifies the module name or path for the custom coverage provider module. Visit [Custom Coverage Provider](https://vitest.dev/guide/coverage#custom-coverage-provider) for more information. This option is only available for custom providers",
        argument: "<path>",
        normalize: true
      },
      watermarks: {
        description: null,
        argument: "",
        subcommands: {
          statements: {
            description: "High and low watermarks for statements in the format of `<high>,<low>`",
            argument: "<watermarks>",
            transform: watermarkTransform
          },
          lines: {
            description: "High and low watermarks for lines in the format of `<high>,<low>`",
            argument: "<watermarks>",
            transform: watermarkTransform
          },
          branches: {
            description: "High and low watermarks for branches in the format of `<high>,<low>`",
            argument: "<watermarks>",
            transform: watermarkTransform
          },
          functions: {
            description: "High and low watermarks for functions in the format of `<high>,<low>`",
            argument: "<watermarks>",
            transform: watermarkTransform
          }
        }
      }
    }
  },
  mode: {
    description: "Override Vite mode (default: `test` or `benchmark`)",
    argument: "<name>"
  },
  isolate: { description: "Run every test file in isolation. To disable isolation, use `--no-isolate` (default: `true`)" },
  globals: { description: "Inject apis globally" },
  dom: { description: "Mock browser API with happy-dom" },
  browser: {
    description: "Run tests in the browser. Equivalent to `--browser.enabled` (default: `false`)",
    argument: "<name>",
    transform(browser) {
      return typeof browser === "boolean" ? { enabled: browser } : browser === "true" || browser === "false" ? { enabled: browser === "true" } : browser === "yes" || browser === "no" ? { enabled: browser === "yes" } : typeof browser === "string" ? { name: browser } : browser;
    },
    subcommands: {
      enabled: { description: "Run tests in the browser. Equivalent to `--browser.enabled` (default: `false`)" },
      name: {
        description: "Run all tests in a specific browser. Some browsers are only available for specific providers (see `--browser.provider`). Visit [`browser.name`](https://vitest.dev/guide/browser/config/#browser-name) for more information",
        argument: "<name>"
      },
      headless: { description: "Run the browser in headless mode (i.e. without opening the GUI (Graphical User Interface)). If you are running Vitest in CI, it will be enabled by default (default: `process.env.CI`)" },
      api: {
        description: "Specify options for the browser API server. Does not affect the --api option",
        argument: "[port]",
        subcommands: apiConfig(defaultBrowserPort)
      },
      provider: {
        description: 'Provider used to run browser tests. Some browsers are only available for specific providers. Can be "webdriverio", "playwright", "preview", or the path to a custom provider. Visit [`browser.provider`](https://vitest.dev/guide/browser/config.html#browser-provider) for more information (default: `"preview"`)',
        argument: "<name>",
        subcommands: null,
        transform(value) {
          const supported = [
            "playwright",
            "webdriverio",
            "preview"
          ];
          if (typeof value !== "string" || !supported.includes(value)) throw new Error(`Unsupported browser provider: ${value}. Supported providers are: ${supported.join(", ")}`);
          return {
            name: value,
            _cli: true
          };
        }
      },
      isolate: { description: "Run every browser test file in isolation. To disable isolation, use `--browser.isolate=false` (default: `true`)" },
      ui: { description: "Show Vitest UI when running tests (default: `!process.env.CI`)" },
      fileParallelism: { description: "Should browser test files run in parallel. Use `--browser.fileParallelism=false` to disable (default: `true`)" },
      connectTimeout: {
        description: "If connection to the browser takes longer, the test suite will fail (default: `60_000`)",
        argument: "<timeout>"
      },
      trackUnhandledErrors: { description: "Control if Vitest catches uncaught exceptions so they can be reported (default: `true`)" },
      trace: {
        description: 'Enable trace view mode. Supported: "on", "off", "on-first-retry", "on-all-retries", "retain-on-failure".',
        argument: "<mode>",
        subcommands: null,
        transform(value) {
          return { mode: value };
        }
      },
      orchestratorScripts: null,
      commands: null,
      viewport: null,
      screenshotDirectory: null,
      screenshotFailures: null,
      locators: null,
      testerHtmlPath: null,
      instances: null,
      expect: null
    }
  },
  pool: {
    description: "Specify pool, if not running in the browser (default: `forks`)",
    argument: "<pool>",
    subcommands: null
  },
  execArgv: {
    description: "Pass additional arguments to `node` process when spawning `worker_threads` or `child_process`.",
    argument: "<option>"
  },
  vmMemoryLimit: {
    description: "Memory limit for VM pools. If you see memory leaks, try to tinker this value.",
    argument: "<limit>"
  },
  fileParallelism: { description: "Should all test files run in parallel. Use `--no-file-parallelism` to disable (default: `true`)" },
  maxWorkers: {
    description: "Maximum number or percentage of workers to run tests in",
    argument: "<workers>"
  },
  environment: {
    description: "Specify runner environment, if not running in the browser (default: `node`)",
    argument: "<name>",
    subcommands: null
  },
  passWithNoTests: { description: "Pass when no tests are found" },
  logHeapUsage: { description: "Show the size of heap for each test when running in node" },
  allowOnly: { description: "Allow tests and suites that are marked as only (default: `!process.env.CI`)" },
  dangerouslyIgnoreUnhandledErrors: { description: "Ignore any unhandled errors that occur" },
  shard: {
    description: "Test suite shard to execute in a format of `<index>/<count>`",
    argument: "<shards>"
  },
  changed: {
    description: "Run tests that are affected by the changed files (default: `false`)",
    argument: "[since]"
  },
  sequence: {
    description: "Options for how tests should be sorted",
    argument: "<options>",
    subcommands: {
      shuffle: {
        description: "Run files and tests in a random order. Enabling this option will impact Vitest's cache and have a performance impact. May be useful to find tests that accidentally depend on another run previously (default: `false`)",
        argument: "",
        subcommands: {
          files: { description: "Run files in a random order. Long running tests will not start earlier if you enable this option. (default: `false`)" },
          tests: { description: "Run tests in a random order (default: `false`)" }
        }
      },
      concurrent: { description: "Make tests run in parallel (default: `false`)" },
      seed: {
        description: 'Set the randomization seed. This option will have no effect if `--sequence.shuffle` is falsy. Visit ["Random Seed" page](https://en.wikipedia.org/wiki/Random_seed) for more information',
        argument: "<seed>"
      },
      hooks: {
        description: 'Changes the order in which hooks are executed. Accepted values are: "stack", "list" and "parallel". Visit [`sequence.hooks`](https://vitest.dev/config/#sequence-hooks) for more information (default: `"parallel"`)',
        argument: "<order>"
      },
      setupFiles: {
        description: 'Changes the order in which setup files are executed. Accepted values are: "list" and "parallel". If set to "list", will run setup files in the order they are defined. If set to "parallel", will run setup files in parallel (default: `"parallel"`)',
        argument: "<order>"
      },
      groupOrder: null
    }
  },
  inspect: {
    description: "Enable Node.js inspector (default: `127.0.0.1:9229`)",
    argument: "[[host:]port]",
    transform(portOrEnabled) {
      return portOrEnabled === 0 || portOrEnabled === "true" || portOrEnabled === "yes" ? true : portOrEnabled === "false" || portOrEnabled === "no" ? false : portOrEnabled;
    }
  },
  inspectBrk: {
    description: "Enable Node.js inspector and break before the test starts",
    argument: "[[host:]port]",
    transform(portOrEnabled) {
      return portOrEnabled === 0 || portOrEnabled === "true" || portOrEnabled === "yes" ? true : portOrEnabled === "false" || portOrEnabled === "no" ? false : portOrEnabled;
    }
  },
  inspector: null,
  testTimeout: {
    description: "Default timeout of a test in milliseconds (default: `5000`). Use `0` to disable timeout completely.",
    argument: "<timeout>"
  },
  hookTimeout: {
    description: "Default hook timeout in milliseconds (default: `10000`). Use `0` to disable timeout completely.",
    argument: "<timeout>"
  },
  bail: {
    description: "Stop test execution when given number of tests have failed (default: `0`)",
    argument: "<number>"
  },
  retry: {
    description: "Retry the test specific number of times if it fails (default: `0`)",
    argument: "<times>"
  },
  diff: {
    description: "DiffOptions object or a path to a module which exports DiffOptions object",
    argument: "<path>",
    subcommands: {
      aAnnotation: {
        description: "Annotation for expected lines (default: `Expected`)",
        argument: "<annotation>"
      },
      aIndicator: {
        description: "Indicator for expected lines (default: `-`)",
        argument: "<indicator>"
      },
      bAnnotation: {
        description: "Annotation for received lines (default: `Received`)",
        argument: "<annotation>"
      },
      bIndicator: {
        description: "Indicator for received lines (default: `+`)",
        argument: "<indicator>"
      },
      commonIndicator: {
        description: "Indicator for common lines (default: ` `)",
        argument: "<indicator>"
      },
      contextLines: {
        description: "Number of lines of context to show around each change (default: `5`)",
        argument: "<lines>"
      },
      emptyFirstOrLastLinePlaceholder: {
        description: 'Placeholder for an empty first or last line (default: `""`)',
        argument: "<placeholder>"
      },
      expand: { description: "Expand all common lines (default: `true`)" },
      includeChangeCounts: { description: "Include comparison counts in diff output (default: `false`)" },
      omitAnnotationLines: { description: "Omit annotation lines from the output (default: `false`)" },
      printBasicPrototype: { description: "Print basic prototype Object and Array (default: `true`)" },
      maxDepth: {
        description: "Limit the depth to recurse when printing nested objects (default: `20`)",
        argument: "<maxDepth>"
      },
      truncateThreshold: {
        description: "Number of lines to show before and after each change (default: `0`)",
        argument: "<threshold>"
      },
      truncateAnnotation: {
        description: "Annotation for truncated lines (default: `... Diff result is truncated`)",
        argument: "<annotation>"
      }
    }
  },
  exclude: {
    description: "Additional file globs to be excluded from test",
    argument: "<glob>",
    array: true
  },
  expandSnapshotDiff: { description: "Show full diff when snapshot fails" },
  disableConsoleIntercept: { description: "Disable automatic interception of console logging (default: `false`)" },
  typecheck: {
    description: "Enable typechecking alongside tests (default: `false`)",
    argument: "",
    transform: transformNestedBoolean,
    subcommands: {
      enabled: { description: "Enable typechecking alongside tests (default: `false`)" },
      only: { description: "Run only typecheck tests. This automatically enables typecheck (default: `false`)" },
      checker: {
        description: 'Specify the typechecker to use. Available values are: "tsc" and "vue-tsc" and a path to an executable (default: `"tsc"`)',
        argument: "<name>",
        subcommands: null
      },
      allowJs: { description: "Allow JavaScript files to be typechecked. By default takes the value from tsconfig.json" },
      ignoreSourceErrors: { description: "Ignore type errors from source files" },
      tsconfig: {
        description: "Path to a custom tsconfig file",
        argument: "<path>",
        normalize: true
      },
      spawnTimeout: {
        description: "Minimum time in milliseconds it takes to spawn the typechecker",
        argument: "<time>"
      },
      include: null,
      exclude: null
    }
  },
  project: {
    description: "The name of the project to run if you are using Vitest workspace feature. This can be repeated for multiple projects: `--project=1 --project=2`. You can also filter projects using wildcards like `--project=packages*`, and exclude projects with `--project=!pattern`.",
    argument: "<name>",
    array: true
  },
  slowTestThreshold: {
    description: "Threshold in milliseconds for a test or suite to be considered slow (default: `300`)",
    argument: "<threshold>"
  },
  teardownTimeout: {
    description: "Default timeout of a teardown function in milliseconds (default: `10000`)",
    argument: "<timeout>"
  },
  cache: {
    description: "Enable cache",
    argument: "",
    subcommands: { dir: null },
    default: true,
    transform(cache2) {
      if (typeof cache2 !== "boolean" && cache2) throw new Error("--cache.dir is deprecated");
      return cache2 && {};
    }
  },
  maxConcurrency: {
    description: "Maximum number of concurrent tests in a suite (default: `5`)",
    argument: "<number>"
  },
  expect: {
    description: "Configuration options for `expect()` matches",
    argument: "",
    subcommands: {
      requireAssertions: { description: "Require that all tests have at least one assertion" },
      poll: {
        description: "Default options for `expect.poll()`",
        argument: "",
        subcommands: {
          interval: {
            description: "Poll interval in milliseconds for `expect.poll()` assertions (default: `50`)",
            argument: "<interval>"
          },
          timeout: {
            description: "Poll timeout in milliseconds for `expect.poll()` assertions (default: `1000`)",
            argument: "<timeout>"
          }
        },
        transform(value) {
          if (typeof value !== "object") throw new TypeError(`Unexpected value for --expect.poll: ${value}. If you need to configure timeout, use --expect.poll.timeout=<timeout>`);
          return value;
        }
      }
    },
    transform(value) {
      if (typeof value !== "object") throw new TypeError(`Unexpected value for --expect: ${value}. If you need to configure expect options, use --expect.{name}=<value> syntax`);
      return value;
    }
  },
  printConsoleTrace: { description: "Always print console stack traces" },
  includeTaskLocation: { description: "Collect test and suite locations in the `location` property" },
  attachmentsDir: {
    description: "The directory where attachments from `context.annotate` are stored in (default: `.vitest-attachments`)",
    argument: "<dir>"
  },
  run: { description: "Disable watch mode" },
  color: {
    description: "Removes colors from the console output",
    alias: "no-color"
  },
  clearScreen: { description: "Clear terminal screen when re-running tests during watch mode (default: `true`)" },
  configLoader: {
    description: "Use `bundle` to bundle the config with esbuild or `runner` (experimental) to process it on the fly. This is only available in vite version 6.1.0 and above. (default: `bundle`)",
    argument: "<loader>"
  },
  standalone: { description: "Start Vitest without running tests. Tests will be running only on change. This option is ignored when CLI file filters are passed. (default: `false`)" },
  mergeReports: {
    description: "Path to a blob reports directory. If this options is used, Vitest won't run any tests, it will only report previously recorded tests",
    argument: "[path]",
    transform(value) {
      return !value || typeof value === "boolean" ? ".vitest-reports" : value;
    }
  },
  cliExclude: null,
  server: null,
  setupFiles: null,
  globalSetup: null,
  snapshotFormat: null,
  snapshotSerializers: null,
  includeSource: null,
  alias: null,
  env: null,
  environmentOptions: null,
  unstubEnvs: null,
  related: null,
  restoreMocks: null,
  runner: null,
  mockReset: null,
  forceRerunTriggers: null,
  unstubGlobals: null,
  uiBase: null,
  benchmark: null,
  include: null,
  fakeTimers: null,
  chaiConfig: null,
  clearMocks: null,
  css: null,
  deps: null,
  name: null,
  snapshotEnvironment: null,
  compare: null,
  outputJson: null,
  json: null,
  provide: null,
  filesOnly: null,
  projects: null,
  watchTriggerPatterns: null
};
var benchCliOptionsConfig = {
  compare: {
    description: "Benchmark output file to compare against",
    argument: "<filename>"
  },
  outputJson: {
    description: "Benchmark output file",
    argument: "<filename>"
  }
};
var collectCliOptionsConfig = {
  ...cliOptionsConfig,
  json: {
    description: "Print collected tests as JSON or write to a file (Default: false)",
    argument: "[true/path]"
  },
  filesOnly: { description: "Print only test files with out the test cases" },
  changed: {
    description: "Print only tests that are affected by the changed files (default: `false`)",
    argument: "[since]"
  }
};
function addCommand(cli, name, option) {
  const commandName = option.alias || name;
  let command = option.shorthand ? `-${option.shorthand}, --${commandName}` : `--${commandName}`;
  if ("argument" in option) command += ` ${option.argument}`;
  function transform(value) {
    if (!option.array && Array.isArray(value)) {
      const received = value.map((s) => typeof s === "string" ? `"${s}"` : s).join(", ");
      throw new Error(`Expected a single value for option "${command}", received [${received}]`);
    }
    return value = removeQuotes(value), option.transform ? option.transform(value) : option.array ? toArray(value) : option.normalize ? normalize(String(value)) : value;
  }
  const hasSubcommands = "subcommands" in option && option.subcommands;
  if (option.description) {
    let description = option.description.replace(/\[.*\]\((.*)\)/, "$1").replace(/`/g, "");
    if (hasSubcommands) description += `. Use '--help --${commandName}' for more info.`;
    cli.option(command, description, { type: transform });
  }
  if (hasSubcommands) for (const commandName2 in option.subcommands) {
    const subcommand = option.subcommands[commandName2];
    if (subcommand) addCommand(cli, `${name}.${commandName2}`, subcommand);
  }
}
function addCliOptions(cli, options) {
  for (const [optionName, option] of Object.entries(options)) if (option) addCommand(cli, optionName, option);
}
function createCLI(options = {}) {
  const cli = cac("vitest");
  return cli.version(version), addCliOptions(cli, cliOptionsConfig), cli.help((info) => {
    const helpSection = info.find((current) => {
      var _a2;
      return (_a2 = current.title) == null ? void 0 : _a2.startsWith("For more info, run any command");
    });
    if (helpSection) helpSection.body += "\n  $ vitest --help --expand-help";
    const options2 = info.find((current) => current.title === "Options");
    if (typeof options2 !== "object") return info;
    const helpIndex = process.argv.findIndex((arg) => arg === "--help"), subcommands = process.argv.slice(helpIndex + 1), defaultOutput = options2.body.split("\n").filter((line) => /^\s+--\S+\./.test(line) === false).join("\n");
    if (subcommands.length === 0) return options2.body = defaultOutput, info;
    if (subcommands.length === 1 && (subcommands[0] === "--expand-help" || subcommands[0] === "--expandHelp")) return info;
    const subcommandMarker = "$SUB_COMMAND_MARKER$", banner = info.find((current) => /^vitest\/\d+\.\d+\.\d+$/.test(current.body));
    function addBannerWarning(warning) {
      if (typeof (banner == null ? void 0 : banner.body) === "string") {
        if (banner == null ? void 0 : banner.body.includes(warning)) return;
        banner.body = `${banner.body}
 WARN: ${warning}`;
      }
    }
    for (let i = 0; i < subcommands.length; i++) {
      const subcommand = subcommands[i];
      if (subcommand === "--expand-help" || subcommand === "--expandHelp") {
        addBannerWarning("--expand-help subcommand ignored because, when used with --help, it must be the only subcommand");
        continue;
      }
      if (subcommand.startsWith("--")) options2.body = options2.body.split("\n").map((line) => line.trim().startsWith(subcommand) ? `${subcommandMarker}${line}` : line).join("\n");
    }
    if (options2.body = options2.body.split("\n").map((line) => line.startsWith(subcommandMarker) ? line.split(subcommandMarker)[1] : "").filter((line) => line.length !== 0).join("\n"), !options2.body) addBannerWarning("no options were found for your subcommands so we printed the whole output"), options2.body = defaultOutput;
    return info;
  }), cli.command("run [...filters]", void 0, options).action(run), cli.command("related [...filters]", void 0, options).action(runRelated), cli.command("watch [...filters]", void 0, options).action(watch), cli.command("dev [...filters]", void 0, options).action(watch), addCliOptions(cli.command("bench [...filters]", void 0, options).action(benchmark), benchCliOptionsConfig), cli.command("init <project>", void 0, options).action(init), addCliOptions(cli.command("list [...filters]", void 0, options).action((filters, options2) => collect("test", filters, options2)), collectCliOptionsConfig), cli.command("[...filters]", void 0, options).action((filters, options2) => start("test", filters, options2)), cli;
}
function removeQuotes(str) {
  return typeof str === "string" ? str[0] === '"' && str.endsWith('"') || str.startsWith(`'`) && str.endsWith(`'`) ? str.slice(1, -1) : str : Array.isArray(str) ? str.map(removeQuotes) : str;
}
function splitArgv(argv) {
  return argv = argv.replace(/(['"])(?:(?!\1).)+\1/g, (match) => match.replace(/\s/g, "\0")), argv.split(" ").map((arg) => {
    return arg = arg.replace(/\0/g, " "), removeQuotes(arg);
  });
}
function parseCLI(argv, config = {}) {
  const arrayArgs = typeof argv === "string" ? splitArgv(argv) : argv;
  if (arrayArgs[0] !== "vitest") throw new Error(`Expected "vitest" as the first argument, received "${arrayArgs[0]}"`);
  arrayArgs[0] = "/index.js", arrayArgs.unshift("node");
  let { args, options } = createCLI(config).parse(arrayArgs, { run: false });
  if (arrayArgs[2] === "watch" || arrayArgs[2] === "dev") options.watch = true;
  if (arrayArgs[2] === "run" && !options.watch) options.run = true;
  if (arrayArgs[2] === "related") options.related = args, options.passWithNoTests ?? (options.passWithNoTests = true), args = [];
  return {
    filter: args,
    options
  };
}
async function runRelated(relatedFiles, argv) {
  argv.related = relatedFiles, argv.passWithNoTests ?? (argv.passWithNoTests = true), await start("test", [], argv);
}
async function watch(cliFilters, options) {
  options.watch = true, await start("test", cliFilters, options);
}
async function run(cliFilters, options) {
  options.run = !options.watch, await start("test", cliFilters, options);
}
async function benchmark(cliFilters, options) {
  console.warn(C.yellow("Benchmarking is an experimental feature.\nBreaking changes might not follow SemVer, please pin Vitest's version when using it.")), await start("benchmark", cliFilters, options);
}
function normalizeCliOptions(cliFilters, argv) {
  var _a2, _b2;
  if (argv.exclude) argv.cliExclude = toArray(argv.exclude), delete argv.exclude;
  if (cliFilters.some((filter) => filter.includes(":"))) argv.includeTaskLocation ?? (argv.includeTaskLocation = true);
  if (typeof ((_a2 = argv.typecheck) == null ? void 0 : _a2.only) === "boolean") (_b2 = argv.typecheck).enabled ?? (_b2.enabled = true);
  return argv;
}
async function start(mode, cliFilters, options) {
  try {
    const { startVitest: startVitest2 } = await import("./cli-api.6GYRwzrM-O4DE44A5.js").then(function(n2) {
      return n2.p;
    }), ctx = await startVitest2(mode, cliFilters.map(normalize), normalizeCliOptions(cliFilters, options));
    if (!ctx.shouldKeepServer()) await ctx.exit();
  } catch (e) {
    const { errorBanner: errorBanner2 } = await import("./index.CcRZ6fUh-RRS4WHFR.js").then(function(n2) {
      return n2.u;
    });
    if (console.error(`
${errorBanner2("Startup Error")}`), console.error(e), console.error("\n\n"), process.exitCode == null) process.exitCode = 1;
    process.exit();
  }
}
async function init(project) {
  if (project !== "browser") console.error(new Error('Only the "browser" project is supported. Use "vitest init browser" to create a new project.')), process.exit(1);
  const { create } = await import("./creator.cqqifzG7-G5IPIJLR.js");
  await create();
}
async function collect(mode, cliFilters, options) {
  try {
    const { prepareVitest: prepareVitest2, processCollected: processCollected2, outputFileList: outputFileList2 } = await import("./cli-api.6GYRwzrM-O4DE44A5.js").then(function(n2) {
      return n2.p;
    }), ctx = await prepareVitest2(mode, {
      ...normalizeCliOptions(cliFilters, options),
      watch: false,
      run: true
    }, void 0, void 0, cliFilters);
    if (!options.filesOnly) {
      const { testModules: tests, unhandledErrors: errors } = await ctx.collect(cliFilters.map(normalize));
      if (errors.length) {
        console.error("\nThere were unhandled errors during test collection"), errors.forEach((e) => console.error(e)), console.error("\n\n"), await ctx.close();
        return;
      }
      processCollected2(ctx, tests, options);
    } else {
      const files = await ctx.getRelevantTestSpecifications(cliFilters.map(normalize));
      outputFileList2(files, options);
    }
    await ctx.close();
  } catch (e) {
    const { errorBanner: errorBanner2 } = await import("./index.CcRZ6fUh-RRS4WHFR.js").then(function(n2) {
      return n2.u;
    });
    if (console.error(`
${errorBanner2("Collect Error")}`), console.error(e), console.error("\n\n"), process.exitCode == null) process.exitCode = 1;
    process.exit();
  }
}

// node_modules/vitest/dist/chunks/index.Bgo3tNWt.js
var TYPE_REQUEST = "q";
var TYPE_RESPONSE = "s";
var DEFAULT_TIMEOUT = 6e4;
function defaultSerialize(i) {
  return i;
}
var defaultDeserialize = defaultSerialize;
var { clearTimeout: clearTimeout2, setTimeout: setTimeout2 } = globalThis;
var random = Math.random.bind(Math);
function createBirpc(functions, options) {
  const {
    post,
    on,
    off = () => {
    },
    eventNames = [],
    serialize = defaultSerialize,
    deserialize = defaultDeserialize,
    resolver,
    bind = "rpc",
    timeout = DEFAULT_TIMEOUT
  } = options;
  const rpcPromiseMap = /* @__PURE__ */ new Map();
  let _promise;
  let closed = false;
  const rpc = new Proxy({}, {
    get(_, method) {
      if (method === "$functions")
        return functions;
      if (method === "$close")
        return close;
      if (method === "$rejectPendingCalls") {
        return rejectPendingCalls;
      }
      if (method === "$closed")
        return closed;
      if (method === "then" && !eventNames.includes("then") && !("then" in functions))
        return void 0;
      const sendEvent = (...args) => {
        post(serialize({ m: method, a: args, t: TYPE_REQUEST }));
      };
      if (eventNames.includes(method)) {
        sendEvent.asEvent = sendEvent;
        return sendEvent;
      }
      const sendCall = async (...args) => {
        if (closed)
          throw new Error(`[birpc] rpc is closed, cannot call "${method}"`);
        if (_promise) {
          try {
            await _promise;
          } finally {
            _promise = void 0;
          }
        }
        return new Promise((resolve3, reject) => {
          var _a2;
          const id = nanoid2();
          let timeoutId;
          if (timeout >= 0) {
            timeoutId = setTimeout2(() => {
              var _a3;
              try {
                const handleResult = (_a3 = options.onTimeoutError) == null ? void 0 : _a3.call(options, method, args);
                if (handleResult !== true)
                  throw new Error(`[birpc] timeout on calling "${method}"`);
              } catch (e) {
                reject(e);
              }
              rpcPromiseMap.delete(id);
            }, timeout);
            if (typeof timeoutId === "object")
              timeoutId = (_a2 = timeoutId.unref) == null ? void 0 : _a2.call(timeoutId);
          }
          rpcPromiseMap.set(id, { resolve: resolve3, reject, timeoutId, method });
          post(serialize({ m: method, a: args, i: id, t: "q" }));
        });
      };
      sendCall.asEvent = sendEvent;
      return sendCall;
    }
  });
  function close(customError) {
    closed = true;
    rpcPromiseMap.forEach(({ reject, method }) => {
      const error = new Error(`[birpc] rpc is closed, cannot call "${method}"`);
      if (customError) {
        customError.cause ?? (customError.cause = error);
        return reject(customError);
      }
      reject(error);
    });
    rpcPromiseMap.clear();
    off(onMessage2);
  }
  function rejectPendingCalls(handler) {
    const entries = Array.from(rpcPromiseMap.values());
    const handlerResults = entries.map(({ method, reject }) => {
      if (!handler) {
        return reject(new Error(`[birpc]: rejected pending call "${method}".`));
      }
      return handler({ method, reject });
    });
    rpcPromiseMap.clear();
    return handlerResults;
  }
  async function onMessage2(data, ...extra) {
    var _a2, _b2, _c;
    let msg;
    try {
      msg = deserialize(data);
    } catch (e) {
      if (((_a2 = options.onGeneralError) == null ? void 0 : _a2.call(options, e)) !== true)
        throw e;
      return;
    }
    if (msg.t === TYPE_REQUEST) {
      const { m: method, a: args } = msg;
      let result, error;
      const fn = resolver ? resolver(method, functions[method]) : functions[method];
      if (!fn) {
        error = new Error(`[birpc] function "${method}" not found`);
      } else {
        try {
          result = await fn.apply(bind === "rpc" ? rpc : functions, args);
        } catch (e) {
          error = e;
        }
      }
      if (msg.i) {
        if (error && options.onError)
          options.onError(error, method, args);
        if (error && options.onFunctionError) {
          if (options.onFunctionError(error, method, args) === true)
            return;
        }
        if (!error) {
          try {
            post(serialize({ t: TYPE_RESPONSE, i: msg.i, r: result }), ...extra);
            return;
          } catch (e) {
            error = e;
            if (((_b2 = options.onGeneralError) == null ? void 0 : _b2.call(options, e, method, args)) !== true)
              throw e;
          }
        }
        try {
          post(serialize({ t: TYPE_RESPONSE, i: msg.i, e: error }), ...extra);
        } catch (e) {
          if (((_c = options.onGeneralError) == null ? void 0 : _c.call(options, e, method, args)) !== true)
            throw e;
        }
      }
    } else {
      const { i: ack, r: result, e: error } = msg;
      const promise = rpcPromiseMap.get(ack);
      if (promise) {
        clearTimeout2(promise.timeoutId);
        if (error)
          promise.reject(error);
        else
          promise.resolve(result);
      }
      rpcPromiseMap.delete(ack);
    }
  }
  _promise = on(onMessage2);
  return rpc;
}
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
function nanoid2(size = 21) {
  let id = "";
  let i = size;
  while (i--)
    id += urlAlphabet[random() * 64 | 0];
  return id;
}

// node_modules/vitest/dist/chunks/cli-api.6GYRwzrM.js
var import_events2 = __toESM(require_events(), 1);
var import_https = __toESM(require_https(), 1);
var import_http = __toESM(require_http(), 1);
var import_net = __toESM(require_net(), 1);
var import_tls = __toESM(require_tls(), 1);
var import_crypto = __toESM(require_crypto(), 1);
var import_stream = __toESM(require_stream(), 1);
var import_url = __toESM(require_url(), 1);
var import_zlib = __toESM(require_zlib(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var import_node_crypto2 = __toESM(require_node_crypto(), 1);
var import_debug = __toESM(require_browser(), 1);
var import_promises3 = __toESM(require_promises(), 1);

// node_modules/vitest/dist/module-evaluator.js
var import_node_module2 = __toESM(require_node_module(), 1);
var import_node_url2 = __toESM(require_node_url(), 1);
var import_node_vm = __toESM(require_node_vm(), 1);
var performanceNow = performance.now.bind(performance);
var ModuleDebug = class {
  constructor() {
    __publicField(this, "executionStack", []);
  }
  startCalculateModuleExecutionInfo(filename, startOffset) {
    const startTime = performanceNow();
    return this.executionStack.push({
      filename,
      startTime,
      subImportTime: 0
    }), () => {
      const duration = performanceNow() - startTime, currentExecution = this.executionStack.pop();
      if (currentExecution == null) throw new Error("Execution stack is empty, this should never happen");
      const selfTime = duration - currentExecution.subImportTime;
      if (this.executionStack.length > 0) this.executionStack.at(-1).subImportTime += duration;
      return {
        startOffset,
        duration,
        selfTime
      };
    };
  }
};
var isWindows2 = process.platform === "win32";
var VitestModuleEvaluator = class {
  constructor(vmOptions, options = {}) {
    __publicField(this, "stubs", {});
    __publicField(this, "env", createImportMetaEnvProxy());
    __publicField(this, "vm");
    __publicField(this, "compiledFunctionArgumentsNames");
    __publicField(this, "compiledFunctionArgumentsValues", []);
    __publicField(this, "primitives");
    __publicField(this, "debug", new ModuleDebug());
    if (this.options = options, this.vm = vmOptions, this.stubs = getDefaultRequestStubs(vmOptions == null ? void 0 : vmOptions.context), options.compiledFunctionArgumentsNames) this.compiledFunctionArgumentsNames = options.compiledFunctionArgumentsNames;
    if (options.compiledFunctionArgumentsValues) this.compiledFunctionArgumentsValues = options.compiledFunctionArgumentsValues;
    if (vmOptions) this.primitives = import_node_vm.default.runInContext("({ Object, Proxy, Reflect })", vmOptions.context);
    else this.primitives = {
      Object,
      Proxy,
      Reflect
    };
  }
  convertIdToImportUrl(id) {
    if (!isWindows2 || (0, import_node_module2.isBuiltin)(id) || /^(?:node:|data:|http:|https:|file:)/.test(id)) return id;
    const [filepath, query] = id.split("?");
    return query ? `${(0, import_node_url2.pathToFileURL)(filepath).toString()}?${query}` : (0, import_node_url2.pathToFileURL)(filepath).toString();
  }
  async runExternalModule(id) {
    if (id in this.stubs) return this.stubs[id];
    const file = this.convertIdToImportUrl(id), namespace = this.vm ? await this.vm.externalModulesExecutor.import(file) : await import(file);
    if (!this.shouldInterop(file, namespace)) return namespace;
    const { mod, defaultExport } = interopModule(namespace), { Proxy: Proxy2, Reflect: Reflect2 } = this.primitives;
    return new Proxy2(mod, {
      get(mod2, prop) {
        return prop === "default" ? defaultExport : mod2[prop] ?? (defaultExport == null ? void 0 : defaultExport[prop]);
      },
      has(mod2, prop) {
        return prop === "default" ? defaultExport !== void 0 : prop in mod2 || defaultExport && prop in defaultExport;
      },
      getOwnPropertyDescriptor(mod2, prop) {
        const descriptor = Reflect2.getOwnPropertyDescriptor(mod2, prop);
        if (descriptor) return descriptor;
        if (prop === "default" && defaultExport !== void 0) return {
          value: defaultExport,
          enumerable: true,
          configurable: true
        };
      }
    });
  }
  async runInlinedModule(context, code, module) {
    var _a2, _b2, _c, _d;
    context.__vite_ssr_import_meta__.env = this.env;
    const { Reflect: Reflect2, Proxy: Proxy2, Object: Object2 } = this.primitives, exportsObject = context[ssrModuleExportsKey], SYMBOL_NOT_DEFINED = Symbol("not defined");
    let moduleExports = SYMBOL_NOT_DEFINED;
    const cjsExports = new Proxy2(exportsObject, {
      get: (target, p2, receiver2) => {
        return Reflect2.has(target, p2) ? Reflect2.get(target, p2, receiver2) : Reflect2.get(Object2.prototype, p2, receiver2);
      },
      getPrototypeOf: () => Object2.prototype,
      set: (_, p2, value) => {
        if (p2 === "default" && this.shouldInterop(module.file, { default: value }) && cjsExports !== value) return exportAll(cjsExports, value), exportsObject.default = value, true;
        if (!Reflect2.has(exportsObject, "default")) exportsObject.default = {};
        if (moduleExports !== SYMBOL_NOT_DEFINED && isPrimitive2(moduleExports)) return defineExport(exportsObject, p2, () => void 0), true;
        if (!isPrimitive2(exportsObject.default)) exportsObject.default[p2] = value;
        if (p2 !== "default") defineExport(exportsObject, p2, () => value);
        return true;
      }
    }), moduleProxy = {
      set exports(value) {
        exportAll(cjsExports, value), exportsObject.default = value, moduleExports = value;
      },
      get exports() {
        return cjsExports;
      }
    }, meta = context[ssrImportMetaKey];
    if (((_b2 = (_a2 = this.options).getCurrentTestFilepath) == null ? void 0 : _b2.call(_a2)) === module.file) {
      const globalNamespace = ((_c = this.vm) == null ? void 0 : _c.context) || globalThis;
      Object2.defineProperty(meta, "vitest", { get: () => globalNamespace.__vitest_index__ });
    }
    const filename = meta.filename, dirname5 = meta.dirname, require2 = this.createRequire(filename), argumentsList = [
      ssrModuleExportsKey,
      ssrImportMetaKey,
      ssrImportKey,
      ssrDynamicImportKey,
      ssrExportAllKey,
      "__vite_ssr_exportName__",
      "__filename",
      "__dirname",
      "module",
      "exports",
      "require"
    ];
    if (this.compiledFunctionArgumentsNames) argumentsList.push(...this.compiledFunctionArgumentsNames);
    const codeDefinition = `'use strict';async (${argumentsList.join(",")})=>{{`, wrappedCode = `${codeDefinition}${code}
}}`, options = {
      filename: module.id,
      lineOffset: 0,
      columnOffset: -codeDefinition.length
    }, finishModuleExecutionInfo = this.debug.startCalculateModuleExecutionInfo(options.filename, codeDefinition.length);
    try {
      await (this.vm ? import_node_vm.default.runInContext(wrappedCode, this.vm.context, options) : import_node_vm.default.runInThisContext(wrappedCode, options))(
        context[ssrModuleExportsKey],
        context[ssrImportMetaKey],
        context[ssrImportKey],
        async (dep, options2) => {
          return dep = String(dep), dep[0] === "#" ? context[ssrDynamicImportKey](wrapId2(dep), options2) : context[ssrDynamicImportKey](dep, options2);
        },
        context[ssrExportAllKey],
        // vite 7 support, remove when vite 7+ is supported
        context.__vite_ssr_exportName__ || ((name, getter) => Object2.defineProperty(exportsObject, name, {
          enumerable: true,
          configurable: true,
          get: getter
        })),
        filename,
        dirname5,
        moduleProxy,
        cjsExports,
        require2,
        ...this.compiledFunctionArgumentsValues
      );
    } finally {
      (_d = this.options.moduleExecutionInfo) == null ? void 0 : _d.set(options.filename, finishModuleExecutionInfo());
    }
  }
  createRequire(filename) {
    return filename[0] === "\0" || !isAbsolute(filename) ? () => ({}) : this.vm ? this.vm.externalModulesExecutor.createRequire(filename) : (0, import_node_module2.createRequire)(filename);
  }
  shouldInterop(path3, mod) {
    return this.options.interopDefault === false ? false : !path3.endsWith(".mjs") && "default" in mod;
  }
};
function createImportMetaEnvProxy() {
  const booleanKeys = [
    "DEV",
    "PROD",
    "SSR"
  ];
  return new Proxy(process.env, {
    get(_, key) {
      if (typeof key === "string") return booleanKeys.includes(key) ? !!process.env[key] : process.env[key];
    },
    set(_, key, value) {
      if (typeof key !== "string") return true;
      if (booleanKeys.includes(key)) process.env[key] = value ? "1" : "";
      else process.env[key] = value;
      return true;
    }
  });
}
function updateStyle(id, css) {
  if (typeof document === "undefined") return;
  const element = document.querySelector(`[data-vite-dev-id="${id}"]`);
  if (element) {
    element.textContent = css;
    return;
  }
  const head = document.querySelector("head"), style = document.createElement("style");
  style.setAttribute("type", "text/css"), style.setAttribute("data-vite-dev-id", id), style.textContent = css, head == null ? void 0 : head.appendChild(style);
}
function removeStyle(id) {
  if (typeof document === "undefined") return;
  const sheet = document.querySelector(`[data-vite-dev-id="${id}"]`);
  if (sheet) document.head.removeChild(sheet);
}
var defaultClientStub = {
  injectQuery: (id) => id,
  createHotContext: () => {
    return {
      accept: () => {
      },
      prune: () => {
      },
      dispose: () => {
      },
      decline: () => {
      },
      invalidate: () => {
      },
      on: () => {
      },
      send: () => {
      }
    };
  },
  updateStyle: () => {
  },
  removeStyle: () => {
  }
};
function getDefaultRequestStubs(context) {
  if (!context) {
    const clientStub2 = {
      ...defaultClientStub,
      updateStyle,
      removeStyle
    };
    return { "/@vite/client": clientStub2 };
  }
  const clientStub = import_node_vm.default.runInContext(`(defaultClient) => ({ ...defaultClient, updateStyle: ${updateStyle.toString()}, removeStyle: ${removeStyle.toString()} })`, context)(defaultClientStub);
  return { "/@vite/client": clientStub };
}
function exportAll(exports, sourceModule) {
  if (exports !== sourceModule && !(isPrimitive2(sourceModule) || Array.isArray(sourceModule) || sourceModule instanceof Promise)) {
    for (const key in sourceModule) if (key !== "default" && !(key in exports)) try {
      defineExport(exports, key, () => sourceModule[key]);
    } catch {
    }
  }
}
function defineExport(exports, key, value) {
  Object.defineProperty(exports, key, {
    enumerable: true,
    configurable: true,
    get: value
  });
}
function isPrimitive2(v) {
  return !(typeof v === "object" || typeof v === "function") || v == null;
}
function interopModule(mod) {
  if (isPrimitive2(mod)) return {
    mod: { default: mod },
    defaultExport: mod
  };
  let defaultExport = "default" in mod ? mod.default : mod;
  if (!isPrimitive2(defaultExport) && "__esModule" in defaultExport) {
    if (mod = defaultExport, "default" in defaultExport) defaultExport = defaultExport.default;
  }
  return {
    mod,
    defaultExport
  };
}
var VALID_ID_PREFIX = `/@id/`;
var NULL_BYTE_PLACEHOLDER = `__x00__`;
function wrapId2(id) {
  return id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace("\0", NULL_BYTE_PLACEHOLDER);
}

// node_modules/vitest/dist/chunks/cli-api.6GYRwzrM.js
var import_node_console = __toESM(require_node_console(), 1);

// node_modules/@vitest/utils/dist/highlight.js
var jsTokens_1;
var hasRequiredJsTokens;
function requireJsTokens() {
  if (hasRequiredJsTokens) return jsTokens_1;
  hasRequiredJsTokens = 1;
  var Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\\]).|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
  Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
  Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
  StringLiteral = /(['"])(?:(?!\1)[^\\\n\r]|\\(?:\r\n|[^]))*(\1)?/y;
  NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
  Template = /[`}](?:[^`\\$]|\\[^]|\$(?!\{))*(`|\$\{)?/y;
  WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
  LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
  MultiLineComment = /\/\*(?:[^*]|\*(?!\/))*(\*\/)?/y;
  SingleLineComment = /\/\/.*/y;
  JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
  JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
  JSXString = /(['"])(?:(?!\1)[^])*(\1)?/y;
  JSXText = /[^<>{}]+/y;
  TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
  TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
  KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
  KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
  Newline = RegExp(LineTerminatorSequence.source);
  jsTokens_1 = function* (input, { jsx = false } = {}) {
    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
    ({ length } = input);
    lastIndex = 0;
    lastSignificantToken = "";
    stack = [
      { tag: "JS" }
    ];
    braces = [];
    parenNesting = 0;
    postfixIncDec = false;
    while (lastIndex < length) {
      mode = stack[stack.length - 1];
      switch (mode.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
            RegularExpressionLiteral.lastIndex = lastIndex;
            if (match = RegularExpressionLiteral.exec(input)) {
              lastIndex = RegularExpressionLiteral.lastIndex;
              lastSignificantToken = match[0];
              postfixIncDec = true;
              yield {
                type: "RegularExpressionLiteral",
                value: match[0],
                closed: match[1] !== void 0 && match[1] !== "\\"
              };
              continue;
            }
          }
          Punctuator.lastIndex = lastIndex;
          if (match = Punctuator.exec(input)) {
            punctuator = match[0];
            nextLastIndex = Punctuator.lastIndex;
            nextLastSignificantToken = punctuator;
            switch (punctuator) {
              case "(":
                if (lastSignificantToken === "?NonExpressionParenKeyword") {
                  stack.push({
                    tag: "JSNonExpressionParen",
                    nesting: parenNesting
                  });
                }
                parenNesting++;
                postfixIncDec = false;
                break;
              case ")":
                parenNesting--;
                postfixIncDec = true;
                if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
                  stack.pop();
                  nextLastSignificantToken = "?NonExpressionParenEnd";
                  postfixIncDec = false;
                }
                break;
              case "{":
                Punctuator.lastIndex = 0;
                isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
                braces.push(isExpression);
                postfixIncDec = false;
                break;
              case "}":
                switch (mode.tag) {
                  case "InterpolationInTemplate":
                    if (braces.length === mode.nesting) {
                      Template.lastIndex = lastIndex;
                      match = Template.exec(input);
                      lastIndex = Template.lastIndex;
                      lastSignificantToken = match[0];
                      if (match[1] === "${") {
                        lastSignificantToken = "?InterpolationInTemplate";
                        postfixIncDec = false;
                        yield {
                          type: "TemplateMiddle",
                          value: match[0]
                        };
                      } else {
                        stack.pop();
                        postfixIncDec = true;
                        yield {
                          type: "TemplateTail",
                          value: match[0],
                          closed: match[1] === "`"
                        };
                      }
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (braces.length === mode.nesting) {
                      stack.pop();
                      lastIndex += 1;
                      lastSignificantToken = "}";
                      yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                postfixIncDec = braces.pop();
                nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                postfixIncDec = true;
                break;
              case "++":
              case "--":
                nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                  stack.push({ tag: "JSXTag" });
                  lastIndex += 1;
                  lastSignificantToken = "<";
                  yield {
                    type: "JSXPunctuator",
                    value: punctuator
                  };
                  continue;
                }
                postfixIncDec = false;
                break;
              default:
                postfixIncDec = false;
            }
            lastIndex = nextLastIndex;
            lastSignificantToken = nextLastSignificantToken;
            yield {
              type: "Punctuator",
              value: punctuator
            };
            continue;
          }
          Identifier.lastIndex = lastIndex;
          if (match = Identifier.exec(input)) {
            lastIndex = Identifier.lastIndex;
            nextLastSignificantToken = match[0];
            switch (match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
                  nextLastSignificantToken = "?NonExpressionParenKeyword";
                }
            }
            lastSignificantToken = nextLastSignificantToken;
            postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
            yield {
              type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: match[0]
            };
            continue;
          }
          StringLiteral.lastIndex = lastIndex;
          if (match = StringLiteral.exec(input)) {
            lastIndex = StringLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            yield {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          NumericLiteral.lastIndex = lastIndex;
          if (match = NumericLiteral.exec(input)) {
            lastIndex = NumericLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            yield {
              type: "NumericLiteral",
              value: match[0]
            };
            continue;
          }
          Template.lastIndex = lastIndex;
          if (match = Template.exec(input)) {
            lastIndex = Template.lastIndex;
            lastSignificantToken = match[0];
            if (match[1] === "${") {
              lastSignificantToken = "?InterpolationInTemplate";
              stack.push({
                tag: "InterpolationInTemplate",
                nesting: braces.length
              });
              postfixIncDec = false;
              yield {
                type: "TemplateHead",
                value: match[0]
              };
            } else {
              postfixIncDec = true;
              yield {
                type: "NoSubstitutionTemplate",
                value: match[0],
                closed: match[1] === "`"
              };
            }
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          JSXPunctuator.lastIndex = lastIndex;
          if (match = JSXPunctuator.exec(input)) {
            lastIndex = JSXPunctuator.lastIndex;
            nextLastSignificantToken = match[0];
            switch (match[0]) {
              case "<":
                stack.push({ tag: "JSXTag" });
                break;
              case ">":
                stack.pop();
                if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
                  nextLastSignificantToken = "?JSX";
                  postfixIncDec = true;
                } else {
                  stack.push({ tag: "JSXChildren" });
                }
                break;
              case "{":
                stack.push({
                  tag: "InterpolationInJSX",
                  nesting: braces.length
                });
                nextLastSignificantToken = "?InterpolationInJSX";
                postfixIncDec = false;
                break;
              case "/":
                if (lastSignificantToken === "<") {
                  stack.pop();
                  if (stack[stack.length - 1].tag === "JSXChildren") {
                    stack.pop();
                  }
                  stack.push({ tag: "JSXTagEnd" });
                }
            }
            lastSignificantToken = nextLastSignificantToken;
            yield {
              type: "JSXPunctuator",
              value: match[0]
            };
            continue;
          }
          JSXIdentifier.lastIndex = lastIndex;
          if (match = JSXIdentifier.exec(input)) {
            lastIndex = JSXIdentifier.lastIndex;
            lastSignificantToken = match[0];
            yield {
              type: "JSXIdentifier",
              value: match[0]
            };
            continue;
          }
          JSXString.lastIndex = lastIndex;
          if (match = JSXString.exec(input)) {
            lastIndex = JSXString.lastIndex;
            lastSignificantToken = match[0];
            yield {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          JSXText.lastIndex = lastIndex;
          if (match = JSXText.exec(input)) {
            lastIndex = JSXText.lastIndex;
            lastSignificantToken = match[0];
            yield {
              type: "JSXText",
              value: match[0]
            };
            continue;
          }
          switch (input[lastIndex]) {
            case "<":
              stack.push({ tag: "JSXTag" });
              lastIndex++;
              lastSignificantToken = "<";
              yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              stack.push({
                tag: "InterpolationInJSX",
                nesting: braces.length
              });
              lastIndex++;
              lastSignificantToken = "?InterpolationInJSX";
              postfixIncDec = false;
              yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      WhiteSpace.lastIndex = lastIndex;
      if (match = WhiteSpace.exec(input)) {
        lastIndex = WhiteSpace.lastIndex;
        yield {
          type: "WhiteSpace",
          value: match[0]
        };
        continue;
      }
      LineTerminatorSequence.lastIndex = lastIndex;
      if (match = LineTerminatorSequence.exec(input)) {
        lastIndex = LineTerminatorSequence.lastIndex;
        postfixIncDec = false;
        if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
          lastSignificantToken = "?NoLineTerminatorHere";
        }
        yield {
          type: "LineTerminatorSequence",
          value: match[0]
        };
        continue;
      }
      MultiLineComment.lastIndex = lastIndex;
      if (match = MultiLineComment.exec(input)) {
        lastIndex = MultiLineComment.lastIndex;
        if (Newline.test(match[0])) {
          postfixIncDec = false;
          if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
            lastSignificantToken = "?NoLineTerminatorHere";
          }
        }
        yield {
          type: "MultiLineComment",
          value: match[0],
          closed: match[1] !== void 0
        };
        continue;
      }
      SingleLineComment.lastIndex = lastIndex;
      if (match = SingleLineComment.exec(input)) {
        lastIndex = SingleLineComment.lastIndex;
        postfixIncDec = false;
        yield {
          type: "SingleLineComment",
          value: match[0]
        };
        continue;
      }
      firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
      lastIndex += firstCodePoint.length;
      lastSignificantToken = firstCodePoint;
      postfixIncDec = false;
      yield {
        type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: firstCodePoint
      };
    }
    return void 0;
  };
  return jsTokens_1;
}
var jsTokensExports = requireJsTokens();
var jsTokens = getDefaultExportFromCjs2(jsTokensExports);
var reservedWords = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
};
var keywords = new Set(reservedWords.keyword);
var reservedWordsStrictSet = new Set(reservedWords.strict);
var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
function isReservedWord(word) {
  return word === "await" || word === "enum";
}
function isStrictReservedWord(word) {
  return isReservedWord(word) || reservedWordsStrictSet.has(word);
}
function isKeyword(word) {
  return keywords.has(word);
}
var BRACKET = /^[()[\]{}]$/;
var getTokenType = function(token) {
  if (token.type === "IdentifierName") {
    if (isKeyword(token.value) || isStrictReservedWord(token.value) || sometimesKeywords.has(token.value))
      return "Keyword";
    if (token.value[0] && token.value[0] !== token.value[0].toLowerCase())
      return "IdentifierCapitalized";
  }
  return token.type === "Punctuator" && BRACKET.test(token.value) ? "Bracket" : token.type === "Invalid" && (token.value === "@" || token.value === "#") ? "Punctuator" : token.type;
};
function getCallableType(token) {
  if (token.type === "IdentifierName")
    return "IdentifierCallable";
  if (token.type === "PrivateIdentifier")
    return "PrivateIdentifierCallable";
  throw new Error("Not a callable token");
}
var colorize = (defs, type, value) => {
  let colorize2 = defs[type];
  return colorize2 ? colorize2(value) : value;
};
var highlightTokens = (defs, text, jsx) => {
  let highlighted = "", lastPotentialCallable = null, stackedHighlight = "";
  for (let token of jsTokens(text, { jsx })) {
    let type = getTokenType(token);
    if (type === "IdentifierName" || type === "PrivateIdentifier") {
      lastPotentialCallable && (highlighted += colorize(defs, getTokenType(lastPotentialCallable), lastPotentialCallable.value) + stackedHighlight, stackedHighlight = ""), lastPotentialCallable = token;
      continue;
    }
    if (lastPotentialCallable && (token.type === "WhiteSpace" || token.type === "LineTerminatorSequence" || token.type === "Punctuator" && (token.value === "?." || token.value === "!"))) {
      stackedHighlight += colorize(defs, type, token.value);
      continue;
    }
    if (stackedHighlight && !lastPotentialCallable && (highlighted += stackedHighlight, stackedHighlight = ""), lastPotentialCallable) {
      let type2 = token.type === "Punctuator" && token.value === "(" ? getCallableType(lastPotentialCallable) : getTokenType(lastPotentialCallable);
      highlighted += colorize(defs, type2, lastPotentialCallable.value) + stackedHighlight, stackedHighlight = "", lastPotentialCallable = null;
    }
    highlighted += colorize(defs, type, token.value);
  }
  return highlighted;
};
function highlight$1(code, options = { jsx: false, colors: {} }) {
  return code && highlightTokens(options.colors || {}, code, options.jsx);
}
function getDefs(c) {
  const Invalid = (text) => c.white(c.bgRed(c.bold(text)));
  return {
    Keyword: c.magenta,
    IdentifierCapitalized: c.yellow,
    Punctuator: c.yellow,
    StringLiteral: c.green,
    NoSubstitutionTemplate: c.green,
    MultiLineComment: c.gray,
    SingleLineComment: c.gray,
    RegularExpressionLiteral: c.cyan,
    NumericLiteral: c.blue,
    TemplateHead: (text) => c.green(text.slice(0, text.length - 2)) + c.cyan(text.slice(-2)),
    TemplateTail: (text) => c.cyan(text.slice(0, 1)) + c.green(text.slice(1)),
    TemplateMiddle: (text) => c.cyan(text.slice(0, 1)) + c.green(text.slice(1, text.length - 2)) + c.cyan(text.slice(-2)),
    IdentifierCallable: c.blue,
    PrivateIdentifierCallable: (text) => `#${c.blue(text.slice(1))}`,
    Invalid,
    JSXString: c.green,
    JSXIdentifier: c.yellow,
    JSXInvalid: Invalid,
    JSXPunctuator: c.yellow
  };
}
function highlight(code, options = { jsx: false }) {
  return highlight$1(code, {
    jsx: options.jsx,
    colors: getDefs(options.colors || C)
  });
}

// node_modules/vitest/dist/chunks/cli-api.6GYRwzrM.js
var import_node_module5 = __toESM(require_node_module(), 1);
var import_node_url4 = __toESM(require_node_url(), 1);
var import_node_tty = __toESM(require_node_tty(), 1);
var import_node_events = __toESM(require_node_events(), 1);
var import_node_child_process = __toESM(require_node_child_process(), 1);
var import_node_v82 = __toESM(require_node_v8(), 1);
var import_node_worker_threads = __toESM(require_node_worker_threads(), 1);
var import_picomatch2 = __toESM(require_picomatch(), 1);

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function encodeInteger(builder, num, relative2) {
  let delta = num - relative2;
  delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
  do {
    let clamped = delta & 31;
    delta >>>= 5;
    if (delta > 0) clamped |= 32;
    builder.write(intToChar[clamped]);
  } while (delta > 0);
  return num;
}
var bufLength = 1024 * 16;
var td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
var StringWriter = class {
  constructor() {
    this.pos = 0;
    this.out = "";
    this.buffer = new Uint8Array(bufLength);
  }
  write(v) {
    const { buffer } = this;
    buffer[this.pos++] = v;
    if (this.pos === bufLength) {
      this.out += td.decode(buffer);
      this.pos = 0;
    }
  }
  flush() {
    const { buffer, out, pos } = this;
    return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
  }
};
function encode(decoded) {
  const writer = new StringWriter();
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) writer.write(semicolon);
    if (line.length === 0) continue;
    let genColumn = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (j > 0) writer.write(comma);
      genColumn = encodeInteger(writer, segment[0], genColumn);
      if (segment.length === 1) continue;
      sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
      sourceLine = encodeInteger(writer, segment[2], sourceLine);
      sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
      if (segment.length === 4) continue;
      namesIndex = encodeInteger(writer, segment[4], namesIndex);
    }
  }
  return writer.flush();
}

// node_modules/magic-string/dist/magic-string.es.mjs
var BitSet = class _BitSet {
  constructor(arg) {
    this.bits = arg instanceof _BitSet ? arg.bits.slice() : [];
  }
  add(n2) {
    this.bits[n2 >> 5] |= 1 << (n2 & 31);
  }
  has(n2) {
    return !!(this.bits[n2 >> 5] & 1 << (n2 & 31));
  }
};
var Chunk = class _Chunk {
  constructor(start2, end, content) {
    this.start = start2;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new _Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index) {
    return this.start < index && index < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  reset() {
    this.intro = "";
    this.outro = "";
    if (this.edited) {
      this.content = this.original;
      this.storeName = false;
      this.edited = false;
    }
  }
  split(index) {
    const sliceIndex = index - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new _Chunk(index, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next) newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
        if (this.edited) {
          this.edit(trimmed, this.storeName, true);
        }
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length) return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        const newChunk = this.split(this.end - trimmed.length);
        if (this.edited) {
          newChunk.edit(trimmed, this.storeName, true);
        }
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length) return true;
    }
  }
};
function getBtoa() {
  if (typeof globalThis !== "undefined" && typeof globalThis.btoa === "function") {
    return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
  } else if (typeof Buffer === "function") {
    return (str) => Buffer.from(str, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa = getBtoa();
var SourceMap = class {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode(properties.mappings);
    if (typeof properties.x_google_ignoreList !== "undefined") {
      this.x_google_ignoreList = properties.x_google_ignoreList;
    }
    if (typeof properties.debugId !== "undefined") {
      this.debugId = properties.debugId;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min = spaced.reduce((previous, current) => {
    const numSpaces = /^ +/.exec(current)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i = fromParts.length;
    while (i--) fromParts[i] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString = Object.prototype.toString;
function isObject(thing) {
  return toString.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i = 0, pos = 0; i < originalLines.length; i++) {
    lineOffsets.push(pos);
    pos += originalLines[i].length + 1;
  }
  return function locate(index) {
    let i = 0;
    let j = lineOffsets.length;
    while (i < j) {
      const m = i + j >> 1;
      if (index < lineOffsets[m]) {
        j = m;
      } else {
        i = m + 1;
      }
    }
    const line = i - 1;
    const column = index - lineOffsets[line];
    return { line, column };
  };
}
var wordRegex = /\w/;
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const contentLengthMinusOne = content.length - 1;
      let contentLineEnd = content.indexOf("\n", 0);
      let previousContentLineEnd = -1;
      while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
        const segment2 = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
        if (nameIndex >= 0) {
          segment2.push(nameIndex);
        }
        this.rawSegments.push(segment2);
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        previousContentLineEnd = contentLineEnd;
        contentLineEnd = content.indexOf("\n", contentLineEnd + 1);
      }
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
      this.advance(content.slice(previousContentLineEnd + 1));
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
      this.advance(content);
    }
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first = true;
    let charInHiresBoundary = false;
    while (originalCharIndex < chunk.end) {
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first = true;
        charInHiresBoundary = false;
      } else {
        if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
          const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
          if (this.hires === "boundary") {
            if (wordRegex.test(original[originalCharIndex])) {
              if (!charInHiresBoundary) {
                this.rawSegments.push(segment);
                charInHiresBoundary = true;
              }
            } else {
              this.rawSegments.push(segment);
              charInHiresBoundary = false;
            }
          } else {
            this.rawSegments.push(segment);
          }
        }
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str) {
    if (!str) return;
    const lines = str.split("\n");
    if (lines.length > 1) {
      for (let i = 0; i < lines.length - 1; i++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class _MagicString {
  constructor(string, options = {}) {
    const chunk = new Chunk(0, string.length, string);
    Object.defineProperties(this, {
      original: { writable: true, value: string },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options.filename },
      indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 },
      ignoreList: { writable: true, value: options.ignoreList },
      offset: { writable: true, value: options.offset || 0 }
    });
    this.byStart[0] = chunk;
    this.byEnd[string.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new _MagicString(this.original, { filename: this.filename, offset: this.offset });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options) {
    options = options || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length) mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length) mappings.advance(chunk.outro);
    });
    if (this.outro) {
      mappings.advance(this.outro);
    }
    return {
      file: options.file ? options.file.split(/[/\\]/).pop() : void 0,
      sources: [
        options.source ? getRelativePath(options.file || "", options.source) : options.file || ""
      ],
      sourcesContent: options.includeContent ? [this.original] : void 0,
      names,
      mappings: mappings.raw,
      x_google_ignoreList: this.ignoreList ? [sourceIndex] : void 0
    };
  }
  generateMap(options) {
    return new SourceMap(this.generateDecodedMap(options));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options) {
    const pattern = /^[^\r\n]/gm;
    if (isObject(indentStr)) {
      options = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "") return this;
    options = options || {};
    const isExcluded = {};
    if (options.exclude) {
      const exclusions = typeof options.exclude[0] === "number" ? [options.exclude] : options.exclude;
      exclusions.forEach((exclusion) => {
        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
          isExcluded[i] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter) return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index, content);
  }
  insertRight(index, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index, content);
  }
  move(start2, end, index) {
    start2 = start2 + this.offset;
    end = end + this.offset;
    index = index + this.offset;
    if (index >= start2 && index <= end) throw new Error("Cannot move a selection inside itself");
    this._split(start2);
    this._split(end);
    this._split(index);
    const first = this.byStart[start2];
    const last = this.byEnd[end];
    const oldLeft = first.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index];
    if (!newRight && last === this.lastChunk) return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft) oldLeft.next = oldRight;
    if (oldRight) oldRight.previous = oldLeft;
    if (newLeft) newLeft.next = first;
    if (newRight) newRight.previous = last;
    if (!first.previous) this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first.previous;
      this.lastChunk.next = null;
    }
    first.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft) this.firstChunk = first;
    if (!newRight) this.lastChunk = last;
    return this;
  }
  overwrite(start2, end, content, options) {
    options = options || {};
    return this.update(start2, end, content, { ...options, overwrite: !options.contentOnly });
  }
  update(start2, end, content, options) {
    start2 = start2 + this.offset;
    end = end + this.offset;
    if (typeof content !== "string") throw new TypeError("replacement content must be a string");
    if (this.original.length !== 0) {
      while (start2 < 0) start2 += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (end > this.original.length) throw new Error("end is out of bounds");
    if (start2 === end)
      throw new Error(
        "Cannot overwrite a zero-length range  use appendLeft or prependRight instead"
      );
    this._split(start2);
    this._split(end);
    if (options === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options = { storeName: true };
    }
    const storeName = options !== void 0 ? options.storeName : false;
    const overwrite = options !== void 0 ? options.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start2, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first = this.byStart[start2];
    const last = this.byEnd[end];
    if (first) {
      let chunk = first;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start2, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string") throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byEnd[index];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index, content) {
    index = index + this.offset;
    if (typeof content !== "string") throw new TypeError("inserted content must be a string");
    this._split(index);
    const chunk = this.byStart[index];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start2, end) {
    start2 = start2 + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start2 < 0) start2 += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start2 === end) return this;
    if (start2 < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start2 > end) throw new Error("end must be greater than start");
    this._split(start2);
    this._split(end);
    let chunk = this.byStart[start2];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  reset(start2, end) {
    start2 = start2 + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start2 < 0) start2 += this.original.length;
      while (end < 0) end += this.original.length;
    }
    if (start2 === end) return this;
    if (start2 < 0 || end > this.original.length) throw new Error("Character is out of bounds");
    if (start2 > end) throw new Error("end must be greater than start");
    this._split(start2);
    this._split(end);
    let chunk = this.byStart[start2];
    while (chunk) {
      chunk.reset();
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length) return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length) return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length) return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n);
    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n);
        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n);
    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start2 = 0, end = this.original.length - this.offset) {
    start2 = start2 + this.offset;
    end = end + this.offset;
    if (this.original.length !== 0) {
      while (start2 < 0) start2 += this.original.length;
      while (end < 0) end += this.original.length;
    }
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start2 || chunk.end <= start2)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start2)
      throw new Error(`Cannot use replaced character ${start2} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start2)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start2 - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start2, end) {
    const clone = this.clone();
    clone.remove(0, start2);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index) {
    if (this.byStart[index] || this.byEnd[index]) return;
    let chunk = this.lastSearchedChunk;
    let previousChunk = chunk;
    const searchForward = index > chunk.end;
    while (chunk) {
      if (chunk.contains(index)) return this._splitChunk(chunk, index);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
      if (chunk === previousChunk) return;
      previousChunk = chunk;
    }
  }
  _splitChunk(chunk, index) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column}  "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index);
    this.byEnd[index] = chunk;
    this.byStart[index] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk) this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str += chunk.toString();
      chunk = chunk.next;
    }
    return str + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length) return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length) return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk) this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted) return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
          if (i === "$") return "$";
          if (i === "&") return match[0];
          const num = +i;
          if (num < match.length) return match[+i];
          return `$${i}`;
        });
      } else {
        return replacement(...match, match.index, str, match.groups);
      }
    }
    function matchAll(re, str) {
      let match;
      const matches = [];
      while (match = re.exec(str)) {
        matches.push(match);
      }
      return matches;
    }
    if (searchValue.global) {
      const matches = matchAll(searchValue, this.original);
      matches.forEach((match) => {
        if (match.index != null) {
          const replacement2 = getReplacement(match, this.original);
          if (replacement2 !== match[0]) {
            this.overwrite(match.index, match.index + match[0].length, replacement2);
          }
        }
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null) {
        const replacement2 = getReplacement(match, this.original);
        if (replacement2 !== match[0]) {
          this.overwrite(match.index, match.index + match[0].length, replacement2);
        }
      }
    }
    return this;
  }
  _replaceString(string, replacement) {
    const { original } = this;
    const index = original.indexOf(string);
    if (index !== -1) {
      if (typeof replacement === "function") {
        replacement = replacement(string, index, original);
      }
      if (string !== replacement) {
        this.overwrite(index, index + string.length, replacement);
      }
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string, replacement) {
    const { original } = this;
    const stringLength = string.length;
    for (let index = original.indexOf(string); index !== -1; index = original.indexOf(string, index + stringLength)) {
      const previous = original.slice(index, index + stringLength);
      let _replacement = replacement;
      if (typeof replacement === "function") {
        _replacement = replacement(previous, index, original);
      }
      if (previous !== _replacement) this.overwrite(index, index + stringLength, _replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};

// node_modules/vitest/node_modules/@vitest/mocker/dist/chunk-utils.js
var postfixRE = /[?#].*$/;
function cleanUrl2(url2) {
  return url2.replace(postfixRE, "");
}

// node_modules/estree-walker/src/walker.js
var WalkerBase = class {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(parent, prop, index, node) {
    if (parent && prop) {
      if (index != null) {
        parent[prop][index] = node;
      } else {
        parent[prop] = node;
      }
    }
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(parent, prop, index) {
    if (parent && prop) {
      if (index !== null && index !== void 0) {
        parent[prop].splice(index, 1);
      } else {
        delete parent[prop];
      }
    }
  }
};

// node_modules/estree-walker/src/sync.js
var SyncWalker = class extends WalkerBase {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(enter, leave) {
    super();
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
    this.enter = enter;
    this.leave = leave;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(node, parent, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped) return node;
        if (removed) return null;
      }
      let key;
      for (key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          if (Array.isArray(value)) {
            const nodes = (
              /** @type {Array<unknown>} */
              value
            );
            for (let i = 0; i < nodes.length; i += 1) {
              const item = nodes[i];
              if (isNode(item)) {
                if (!this.visit(item, node, key, i)) {
                  i--;
                }
              }
            }
          } else if (isNode(value)) {
            this.visit(value, node, key, null);
          }
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed) return null;
      }
    }
    return node;
  }
};
function isNode(value) {
  return value !== null && typeof value === "object" && "type" in value && typeof value.type === "string";
}

// node_modules/estree-walker/src/index.js
function walk(ast, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast, null);
}

// node_modules/vitest/node_modules/@vitest/mocker/dist/chunk-automock.js
var isNodeInPatternWeakSet = /* @__PURE__ */ new WeakSet();
function setIsNodeInPattern(node) {
  return isNodeInPatternWeakSet.add(node);
}
function isNodeInPattern(node) {
  return isNodeInPatternWeakSet.has(node);
}
function esmWalker(root, { onIdentifier, onImportMeta, onDynamicImport, onCallExpression }) {
  const parentStack = [];
  const varKindStack = [];
  const scopeMap = /* @__PURE__ */ new WeakMap();
  const identifiers = [];
  const setScope = (node, name) => {
    let scopeIds = scopeMap.get(node);
    if (scopeIds && scopeIds.has(name)) {
      return;
    }
    if (!scopeIds) {
      scopeIds = /* @__PURE__ */ new Set();
      scopeMap.set(node, scopeIds);
    }
    scopeIds.add(name);
  };
  function isInScope(name, parents) {
    return parents.some((node) => {
      var _scopeMap$get;
      return node && ((_scopeMap$get = scopeMap.get(node)) === null || _scopeMap$get === void 0 ? void 0 : _scopeMap$get.has(name));
    });
  }
  function handlePattern(p2, parentScope) {
    if (p2.type === "Identifier") {
      setScope(parentScope, p2.name);
    } else if (p2.type === "RestElement") {
      handlePattern(p2.argument, parentScope);
    } else if (p2.type === "ObjectPattern") {
      p2.properties.forEach((property) => {
        if (property.type === "RestElement") {
          setScope(parentScope, property.argument.name);
        } else {
          handlePattern(property.value, parentScope);
        }
      });
    } else if (p2.type === "ArrayPattern") {
      p2.elements.forEach((element) => {
        if (element) {
          handlePattern(element, parentScope);
        }
      });
    } else if (p2.type === "AssignmentPattern") {
      handlePattern(p2.left, parentScope);
    } else {
      setScope(parentScope, p2.name);
    }
  }
  walk(root, {
    enter(node, parent) {
      if (node.type === "ImportDeclaration") {
        return this.skip();
      }
      if (parent && !(parent.type === "IfStatement" && node === parent.alternate)) {
        parentStack.unshift(parent);
      }
      if (node.type === "VariableDeclaration") {
        varKindStack.unshift(node.kind);
      }
      if (node.type === "CallExpression") {
        onCallExpression === null || onCallExpression === void 0 ? void 0 : onCallExpression(node);
      }
      if (node.type === "MetaProperty" && node.meta.name === "import") {
        onImportMeta === null || onImportMeta === void 0 ? void 0 : onImportMeta(node);
      } else if (node.type === "ImportExpression") {
        onDynamicImport === null || onDynamicImport === void 0 ? void 0 : onDynamicImport(node);
      }
      if (node.type === "Identifier") {
        if (!isInScope(node.name, parentStack) && isRefIdentifier(node, parent, parentStack)) {
          identifiers.push([node, parentStack.slice(0)]);
        }
      } else if (isFunctionNode(node)) {
        if (node.type === "FunctionDeclaration") {
          const parentScope = findParentScope(parentStack);
          if (parentScope) {
            setScope(parentScope, node.id.name);
          }
        }
        node.params.forEach((p2) => {
          if (p2.type === "ObjectPattern" || p2.type === "ArrayPattern") {
            handlePattern(p2, node);
            return;
          }
          walk(p2.type === "AssignmentPattern" ? p2.left : p2, { enter(child, parent2) {
            if ((parent2 === null || parent2 === void 0 ? void 0 : parent2.type) === "AssignmentPattern" && (parent2 === null || parent2 === void 0 ? void 0 : parent2.right) === child) {
              return this.skip();
            }
            if (child.type !== "Identifier") {
              return;
            }
            if (isStaticPropertyKey(child, parent2)) {
              return;
            }
            if ((parent2 === null || parent2 === void 0 ? void 0 : parent2.type) === "TemplateLiteral" && (parent2 === null || parent2 === void 0 ? void 0 : parent2.expressions.includes(child)) || (parent2 === null || parent2 === void 0 ? void 0 : parent2.type) === "CallExpression" && (parent2 === null || parent2 === void 0 ? void 0 : parent2.callee) === child) {
              return;
            }
            setScope(node, child.name);
          } });
        });
      } else if (node.type === "Property" && parent.type === "ObjectPattern") {
        setIsNodeInPattern(node);
      } else if (node.type === "VariableDeclarator") {
        const parentFunction = findParentScope(parentStack, varKindStack[0] === "var");
        if (parentFunction) {
          handlePattern(node.id, parentFunction);
        }
      } else if (node.type === "CatchClause" && node.param) {
        handlePattern(node.param, node);
      }
    },
    leave(node, parent) {
      if (parent && !(parent.type === "IfStatement" && node === parent.alternate)) {
        parentStack.shift();
      }
      if (node.type === "VariableDeclaration") {
        varKindStack.shift();
      }
    }
  });
  identifiers.forEach(([node, stack]) => {
    if (!isInScope(node.name, stack)) {
      const parent = stack[0];
      const grandparent = stack[1];
      const hasBindingShortcut = isStaticProperty(parent) && parent.shorthand && (!isNodeInPattern(parent) || isInDestructuringAssignment(parent, parentStack));
      const classDeclaration = parent.type === "PropertyDefinition" && (grandparent === null || grandparent === void 0 ? void 0 : grandparent.type) === "ClassBody" || parent.type === "ClassDeclaration" && node === parent.superClass;
      const classExpression = parent.type === "ClassExpression" && node === parent.id;
      onIdentifier === null || onIdentifier === void 0 ? void 0 : onIdentifier(node, {
        hasBindingShortcut,
        classDeclaration,
        classExpression
      }, stack);
    }
  });
}
function isRefIdentifier(id, parent, parentStack) {
  if (parent.type === "CatchClause" || (parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) {
    return false;
  }
  if (isFunctionNode(parent)) {
    if (parent.id === id) {
      return false;
    }
    if (parent.params.includes(id)) {
      return false;
    }
  }
  if (parent.type === "MethodDefinition" && !parent.computed) {
    return false;
  }
  if (isStaticPropertyKey(id, parent)) {
    return false;
  }
  if (isNodeInPattern(parent) && parent.value === id) {
    return false;
  }
  if (parent.type === "ArrayPattern" && !isInDestructuringAssignment(parent, parentStack)) {
    return false;
  }
  if (parent.type === "MemberExpression" && parent.property === id && !parent.computed) {
    return false;
  }
  if (parent.type === "ExportSpecifier") {
    return false;
  }
  if (id.name === "arguments") {
    return false;
  }
  return true;
}
function isStaticProperty(node) {
  return node && node.type === "Property" && !node.computed;
}
function isStaticPropertyKey(node, parent) {
  return isStaticProperty(parent) && parent.key === node;
}
var functionNodeTypeRE = /Function(?:Expression|Declaration)$|Method$/;
function isFunctionNode(node) {
  return functionNodeTypeRE.test(node.type);
}
var blockNodeTypeRE = /^BlockStatement$|^For(?:In|Of)?Statement$/;
function isBlock(node) {
  return blockNodeTypeRE.test(node.type);
}
function findParentScope(parentStack, isVar = false) {
  return parentStack.find(isVar ? isFunctionNode : isBlock);
}
function isInDestructuringAssignment(parent, parentStack) {
  if (parent && (parent.type === "Property" || parent.type === "ArrayPattern")) {
    return parentStack.some((i) => i.type === "AssignmentExpression");
  }
  return false;
}
function getArbitraryModuleIdentifier(node) {
  return node.type === "Identifier" ? node.name : node.raw;
}
function automockModule(code, mockType, parse2, options = {}) {
  const globalThisAccessor = options.globalThisAccessor || '"__vitest_mocker__"';
  const ast = parse2(code);
  const m = new MagicString(code);
  const allSpecifiers = [];
  let importIndex = 0;
  for (const _node of ast.body) {
    if (_node.type === "ExportAllDeclaration") {
      throw new Error(`automocking files with \`export *\` is not supported in browser mode because it cannot be statically analysed`);
    }
    if (_node.type === "ExportNamedDeclaration") {
      let traversePattern = function(expression) {
        if (expression.type === "Identifier") {
          allSpecifiers.push({ name: expression.name });
        } else if (expression.type === "ArrayPattern") {
          expression.elements.forEach((element) => {
            if (!element) {
              return;
            }
            traversePattern(element);
          });
        } else if (expression.type === "ObjectPattern") {
          expression.properties.forEach((property) => {
            if (property.type === "RestElement") {
              traversePattern(property);
            } else if (property.type === "Property") {
              traversePattern(property.value);
            } else ;
          });
        } else if (expression.type === "RestElement") {
          traversePattern(expression.argument);
        } else if (expression.type === "AssignmentPattern") {
          throw new Error(`AssignmentPattern is not supported. Please open a new bug report.`);
        } else if (expression.type === "MemberExpression") {
          throw new Error(`MemberExpression is not supported. Please open a new bug report.`);
        } else ;
      };
      const node = _node;
      const declaration = node.declaration;
      if (declaration) {
        if (declaration.type === "FunctionDeclaration") {
          allSpecifiers.push({ name: declaration.id.name });
        } else if (declaration.type === "VariableDeclaration") {
          declaration.declarations.forEach((declaration2) => {
            traversePattern(declaration2.id);
          });
        } else if (declaration.type === "ClassDeclaration") {
          allSpecifiers.push({ name: declaration.id.name });
        } else ;
        m.remove(node.start, declaration.start);
      }
      const specifiers = node.specifiers || [];
      const source = node.source;
      if (!source && specifiers.length) {
        specifiers.forEach((specifier) => {
          allSpecifiers.push({
            alias: getArbitraryModuleIdentifier(specifier.exported),
            name: getArbitraryModuleIdentifier(specifier.local)
          });
        });
        m.remove(node.start, node.end);
      } else if (source && specifiers.length) {
        const importNames = [];
        specifiers.forEach((specifier) => {
          const importedName = `__vitest_imported_${importIndex++}__`;
          importNames.push([getArbitraryModuleIdentifier(specifier.local), importedName]);
          allSpecifiers.push({
            name: importedName,
            alias: getArbitraryModuleIdentifier(specifier.exported)
          });
        });
        const importString = `import { ${importNames.map(([name, alias]) => `${name} as ${alias}`).join(", ")} } from '${source.value}'`;
        m.overwrite(node.start, node.end, importString);
      }
    }
    if (_node.type === "ExportDefaultDeclaration") {
      const node = _node;
      const declaration = node.declaration;
      allSpecifiers.push({
        name: "__vitest_default",
        alias: "default"
      });
      m.overwrite(node.start, declaration.start, `const __vitest_default = `);
    }
  }
  const moduleObject = `
const __vitest_current_es_module__ = {
  __esModule: true,
  ${allSpecifiers.map(({ name }) => `["${name}"]: ${name},`).join("\n  ")}
}
const __vitest_mocked_module__ = globalThis[${globalThisAccessor}].mockObject(__vitest_current_es_module__, "${mockType}")
`;
  const assigning = allSpecifiers.map(({ name }, index) => {
    return `const __vitest_mocked_${index}__ = __vitest_mocked_module__["${name}"]`;
  }).join("\n");
  const redeclarations = allSpecifiers.map(({ name, alias }, index) => {
    return `  __vitest_mocked_${index}__ as ${alias || name},`;
  }).join("\n");
  const specifiersExports = `
export {
${redeclarations}
}
`;
  m.append(moduleObject + assigning + specifiersExports);
  return m;
}

// node_modules/vitest/node_modules/@vitest/mocker/dist/node.js
var import_promises2 = __toESM(require_promises());
var import_posix = __toESM(require_posix());
var import_node_url3 = __toESM(require_node_url());
var import_node_fs3 = __toESM(require_node_fs());

// node_modules/vitest/node_modules/@vitest/mocker/dist/redirect.js
var import_node_fs2 = __toESM(require_node_fs(), 1);
var import_node_module3 = __toESM(require_node_module(), 1);
var { existsSync: existsSync2, readdirSync: readdirSync2, statSync: statSync2 } = import_node_fs2.default;
var builtins = /* @__PURE__ */ new Set([
  ...import_node_module3.default.builtinModules,
  "assert/strict",
  "diagnostics_channel",
  "dns/promises",
  "fs/promises",
  "path/posix",
  "path/win32",
  "readline/promises",
  "stream/consumers",
  "stream/promises",
  "stream/web",
  "timers/promises",
  "util/types",
  "wasi"
]);

// node_modules/vitest/node_modules/@vitest/mocker/dist/node.js
var import_node_module4 = __toESM(require_node_module());
function automockPlugin(options = {}) {
  return {
    name: "vitest:automock",
    enforce: "post",
    transform(code, id) {
      if (id.includes("mock=automock") || id.includes("mock=autospy")) {
        const mockType = id.includes("mock=automock") ? "automock" : "autospy";
        const ms = automockModule(code, mockType, this.parse, options);
        return {
          code: ms.toString(),
          map: ms.generateMap({
            hires: "boundary",
            source: cleanUrl2(id)
          })
        };
      }
    }
  };
}
function makeTest(test) {
  if (typeof test === "string") {
    return function(type) {
      return type === test;
    };
  } else if (!test) {
    return function() {
      return true;
    };
  } else {
    return test;
  }
}
var Found = function Found2(node, state) {
  this.node = node;
  this.state = state;
};
function findNodeAround(node, pos, test, baseVisitor, state) {
  test = makeTest(test);
  if (!baseVisitor) {
    baseVisitor = base;
  }
  try {
    (function c(node2, st, override) {
      var type = override || node2.type;
      if (node2.start > pos || node2.end < pos) {
        return;
      }
      baseVisitor[type](node2, st, c);
      if (test(type, node2)) {
        throw new Found(node2, st);
      }
    })(node, state);
  } catch (e) {
    if (e instanceof Found) {
      return e;
    }
    throw e;
  }
}
function skipThrough(node, st, c) {
  c(node, st);
}
function ignore(_node, _st, _c) {
}
var base = {};
base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1) {
    var stmt = list[i];
    c(stmt, st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c) {
  return c(node.expression, st, "Expression");
};
base.IfStatement = function(node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) {
    c(node.alternate, st, "Statement");
  }
};
base.LabeledStatement = function(node, st, c) {
  return c(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function(node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base.SwitchStatement = function(node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i = 0, list = node.cases; i < list.length; i += 1) {
    var cs = list[i];
    c(cs, st);
  }
};
base.SwitchCase = function(node, st, c) {
  if (node.test) {
    c(node.test, st, "Expression");
  }
  for (var i = 0, list = node.consequent; i < list.length; i += 1) {
    var cons = list[i];
    c(cons, st, "Statement");
  }
};
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c) {
  if (node.argument) {
    c(node.argument, st, "Expression");
  }
};
base.ThrowStatement = base.SpreadElement = function(node, st, c) {
  return c(node.argument, st, "Expression");
};
base.TryStatement = function(node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) {
    c(node.handler, st);
  }
  if (node.finalizer) {
    c(node.finalizer, st, "Statement");
  }
};
base.CatchClause = function(node, st, c) {
  if (node.param) {
    c(node.param, st, "Pattern");
  }
  c(node.body, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function(node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForStatement = function(node, st, c) {
  if (node.init) {
    c(node.init, st, "ForInit");
  }
  if (node.test) {
    c(node.test, st, "Expression");
  }
  if (node.update) {
    c(node.update, st, "Expression");
  }
  c(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function(node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInit = function(node, st, c) {
  if (node.type === "VariableDeclaration") {
    c(node, st);
  } else {
    c(node, st, "Expression");
  }
};
base.DebuggerStatement = ignore;
base.FunctionDeclaration = function(node, st, c) {
  return c(node, st, "Function");
};
base.VariableDeclaration = function(node, st, c) {
  for (var i = 0, list = node.declarations; i < list.length; i += 1) {
    var decl = list[i];
    c(decl, st);
  }
};
base.VariableDeclarator = function(node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) {
    c(node.init, st, "Expression");
  }
};
base.Function = function(node, st, c) {
  if (node.id) {
    c(node.id, st, "Pattern");
  }
  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    c(param, st, "Pattern");
  }
  c(node.body, st, node.expression ? "Expression" : "Statement");
};
base.Pattern = function(node, st, c) {
  if (node.type === "Identifier") {
    c(node, st, "VariablePattern");
  } else if (node.type === "MemberExpression") {
    c(node, st, "MemberPattern");
  } else {
    c(node, st);
  }
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function(node, st, c) {
  return c(node.argument, st, "Pattern");
};
base.ArrayPattern = function(node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];
    if (elt) {
      c(elt, st, "Pattern");
    }
  }
};
base.ObjectPattern = function(node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1) {
    var prop = list[i];
    if (prop.type === "Property") {
      if (prop.computed) {
        c(prop.key, st, "Expression");
      }
      c(prop.value, st, "Pattern");
    } else if (prop.type === "RestElement") {
      c(prop.argument, st, "Pattern");
    }
  }
};
base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function(node, st, c) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];
    if (elt) {
      c(elt, st, "Expression");
    }
  }
};
base.ObjectExpression = function(node, st, c) {
  for (var i = 0, list = node.properties; i < list.length; i += 1) {
    var prop = list[i];
    c(prop, st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = function(node, st, c) {
  for (var i = 0, list = node.expressions; i < list.length; i += 1) {
    var expr = list[i];
    c(expr, st, "Expression");
  }
};
base.TemplateLiteral = function(node, st, c) {
  for (var i = 0, list = node.quasis; i < list.length; i += 1) {
    var quasi = list[i];
    c(quasi, st);
  }
  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
    var expr = list$1[i$1];
    c(expr, st, "Expression");
  }
};
base.TemplateElement = ignore;
base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
  c(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function(node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function(node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
base.ConditionalExpression = function(node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function(node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments) {
    for (var i = 0, list = node.arguments; i < list.length; i += 1) {
      var arg = list[i];
      c(arg, st, "Expression");
    }
  }
};
base.MemberExpression = function(node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) {
    c(node.property, st, "Expression");
  }
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c) {
  if (node.declaration) {
    c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
  }
  if (node.source) {
    c(node.source, st, "Expression");
  }
};
base.ExportAllDeclaration = function(node, st, c) {
  if (node.exported) {
    c(node.exported, st);
  }
  c(node.source, st, "Expression");
};
base.ImportDeclaration = function(node, st, c) {
  for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
    var spec = list[i];
    c(spec, st);
  }
  c(node.source, st, "Expression");
};
base.ImportExpression = function(node, st, c) {
  c(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
base.TaggedTemplateExpression = function(node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st, "Expression");
};
base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
  return c(node, st, "Class");
};
base.Class = function(node, st, c) {
  if (node.id) {
    c(node.id, st, "Pattern");
  }
  if (node.superClass) {
    c(node.superClass, st, "Expression");
  }
  c(node.body, st);
};
base.ClassBody = function(node, st, c) {
  for (var i = 0, list = node.body; i < list.length; i += 1) {
    var elt = list[i];
    c(elt, st);
  }
};
base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c) {
  if (node.computed) {
    c(node.key, st, "Expression");
  }
  if (node.value) {
    c(node.value, st, "Expression");
  }
};
function hoistMocksPlugin(options = {}) {
  const filter = options.filter || createFilter(options.include, options.exclude);
  const { hoistableMockMethodNames = ["mock", "unmock"], dynamicImportMockMethodNames = [
    "mock",
    "unmock",
    "doMock",
    "doUnmock"
  ], hoistedMethodNames = ["hoisted"], utilsObjectNames = ["vi", "vitest"] } = options;
  const methods = /* @__PURE__ */ new Set([
    ...hoistableMockMethodNames,
    ...hoistedMethodNames,
    ...dynamicImportMockMethodNames
  ]);
  const regexpHoistable2 = new RegExp(`\\b(?:${utilsObjectNames.join("|")})\\s*.\\s*(?:${Array.from(methods).join("|")})\\s*\\(`);
  return {
    name: "vitest:mocks",
    enforce: "post",
    transform(code, id) {
      if (!filter(id)) {
        return;
      }
      return hoistMocks(code, id, this.parse, {
        regexpHoistable: regexpHoistable2,
        hoistableMockMethodNames,
        hoistedMethodNames,
        utilsObjectNames,
        dynamicImportMockMethodNames,
        ...options
      });
    }
  };
}
var API_NOT_FOUND_ERROR = `There are some problems in resolving the mocks API.
You may encounter this issue when importing the mocks API from another module other than 'vitest'.
To fix this issue you can either:
- import the mocks API directly from 'vitest'
- enable the 'globals' options`;
function API_NOT_FOUND_CHECK(names) {
  return `
if (${names.map((name) => `typeof globalThis["${name}"] === "undefined"`).join(" && ")}) { throw new Error(${JSON.stringify(API_NOT_FOUND_ERROR)}) }
`;
}
function isIdentifier(node) {
  return node.type === "Identifier";
}
function getNodeTail(code, node) {
  let end = node.end;
  if (code[node.end] === ";") {
    end += 1;
  }
  if (code[node.end] === "\n") {
    return end + 1;
  }
  if (code[node.end + 1] === "\n") {
    end += 1;
  }
  return end;
}
var regexpHoistable = /\b(?:vi|vitest)\s*\.\s*(?:mock|unmock|hoisted|doMock|doUnmock)\s*\(/;
var hashbangRE = /^#!.*\n/;
function hoistMocks(code, id, parse2, options = {}) {
  var _hashbangRE$exec;
  const needHoisting = (options.regexpHoistable || regexpHoistable).test(code);
  if (!needHoisting) {
    return;
  }
  const s = new MagicString(code);
  let ast;
  try {
    ast = parse2(code);
  } catch (err) {
    console.error(`Cannot parse ${id}:
${err.message}.`);
    return;
  }
  const { hoistableMockMethodNames = ["mock", "unmock"], dynamicImportMockMethodNames = [
    "mock",
    "unmock",
    "doMock",
    "doUnmock"
  ], hoistedMethodNames = ["hoisted"], utilsObjectNames = ["vi", "vitest"], hoistedModule = "vitest" } = options;
  let hoistIndex = ((_hashbangRE$exec = hashbangRE.exec(code)) === null || _hashbangRE$exec === void 0 ? void 0 : _hashbangRE$exec[0].length) ?? 0;
  let hoistedModuleImported = false;
  let uid = 0;
  const idToImportMap = /* @__PURE__ */ new Map();
  const imports = [];
  function defineImport(importNode) {
    const source = importNode.source.value;
    if (hoistedModule === source) {
      hoistedModuleImported = true;
      return;
    }
    const importId = `__vi_import_${uid++}__`;
    imports.push({
      id: importId,
      node: importNode
    });
    return importId;
  }
  for (const node of ast.body) {
    if (node.type === "ImportDeclaration") {
      const importId = defineImport(node);
      if (!importId) {
        continue;
      }
      for (const spec of node.specifiers) {
        if (spec.type === "ImportSpecifier") {
          if (spec.imported.type === "Identifier") {
            idToImportMap.set(spec.local.name, `${importId}.${spec.imported.name}`);
          } else {
            idToImportMap.set(spec.local.name, `${importId}[${JSON.stringify(spec.imported.value)}]`);
          }
        } else if (spec.type === "ImportDefaultSpecifier") {
          idToImportMap.set(spec.local.name, `${importId}.default`);
        } else {
          idToImportMap.set(spec.local.name, importId);
        }
      }
    }
  }
  const declaredConst = /* @__PURE__ */ new Set();
  const hoistedNodes = [];
  function createSyntaxError(node, message) {
    const _error = new SyntaxError(message);
    Error.captureStackTrace(_error, createSyntaxError);
    const serializedError = {
      name: "SyntaxError",
      message: _error.message,
      stack: _error.stack
    };
    if (options.codeFrameGenerator) {
      serializedError.frame = options.codeFrameGenerator(node, id, code);
    }
    return serializedError;
  }
  function assertNotDefaultExport(node, error) {
    var _findNodeAround;
    const defaultExport = (_findNodeAround = findNodeAround(ast, node.start, "ExportDefaultDeclaration")) === null || _findNodeAround === void 0 ? void 0 : _findNodeAround.node;
    if ((defaultExport === null || defaultExport === void 0 ? void 0 : defaultExport.declaration) === node || (defaultExport === null || defaultExport === void 0 ? void 0 : defaultExport.declaration.type) === "AwaitExpression" && defaultExport.declaration.argument === node) {
      throw createSyntaxError(defaultExport, error);
    }
  }
  function assertNotNamedExport(node, error) {
    var _findNodeAround2;
    const nodeExported = (_findNodeAround2 = findNodeAround(ast, node.start, "ExportNamedDeclaration")) === null || _findNodeAround2 === void 0 ? void 0 : _findNodeAround2.node;
    if ((nodeExported === null || nodeExported === void 0 ? void 0 : nodeExported.declaration) === node) {
      throw createSyntaxError(nodeExported, error);
    }
  }
  function getVariableDeclaration(node) {
    var _findNodeAround3, _declarationNode$decl;
    const declarationNode = (_findNodeAround3 = findNodeAround(ast, node.start, "VariableDeclaration")) === null || _findNodeAround3 === void 0 ? void 0 : _findNodeAround3.node;
    const init3 = declarationNode === null || declarationNode === void 0 || (_declarationNode$decl = declarationNode.declarations[0]) === null || _declarationNode$decl === void 0 ? void 0 : _declarationNode$decl.init;
    if (init3 && (init3 === node || init3.type === "AwaitExpression" && init3.argument === node)) {
      return declarationNode;
    }
  }
  const usedUtilityExports = /* @__PURE__ */ new Set();
  esmWalker(ast, {
    onIdentifier(id2, info, parentStack) {
      const binding = idToImportMap.get(id2.name);
      if (!binding) {
        return;
      }
      if (info.hasBindingShortcut) {
        s.appendLeft(id2.end, `: ${binding}`);
      } else if (info.classDeclaration) {
        if (!declaredConst.has(id2.name)) {
          declaredConst.add(id2.name);
          const topNode = parentStack[parentStack.length - 2];
          s.prependRight(topNode.start, `const ${id2.name} = ${binding};
`);
        }
      } else if (!info.classExpression) {
        s.update(id2.start, id2.end, binding);
      }
    },
    onCallExpression(node) {
      if (node.callee.type === "MemberExpression" && isIdentifier(node.callee.object) && utilsObjectNames.includes(node.callee.object.name) && isIdentifier(node.callee.property)) {
        const methodName = node.callee.property.name;
        usedUtilityExports.add(node.callee.object.name);
        if (hoistableMockMethodNames.includes(methodName)) {
          const method = `${node.callee.object.name}.${methodName}`;
          assertNotDefaultExport(node, `Cannot export the result of "${method}". Remove export declaration because "${method}" doesn't return anything.`);
          const declarationNode = getVariableDeclaration(node);
          if (declarationNode) {
            assertNotNamedExport(declarationNode, `Cannot export the result of "${method}". Remove export declaration because "${method}" doesn't return anything.`);
          }
          if (node.type === "CallExpression" && node.callee.type === "MemberExpression" && dynamicImportMockMethodNames.includes(node.callee.property.name)) {
            const moduleInfo = node.arguments[0];
            if (moduleInfo.type === "ImportExpression") {
              const source = moduleInfo.source;
              s.overwrite(moduleInfo.start, moduleInfo.end, s.slice(source.start, source.end));
            }
            if (moduleInfo.type === "AwaitExpression" && moduleInfo.argument.type === "ImportExpression") {
              const source = moduleInfo.argument.source;
              s.overwrite(moduleInfo.start, moduleInfo.end, s.slice(source.start, source.end));
            }
          }
          hoistedNodes.push(node);
        } else if (dynamicImportMockMethodNames.includes(methodName)) {
          const moduleInfo = node.arguments[0];
          let source = null;
          if (moduleInfo.type === "ImportExpression") {
            source = moduleInfo.source;
          }
          if (moduleInfo.type === "AwaitExpression" && moduleInfo.argument.type === "ImportExpression") {
            source = moduleInfo.argument.source;
          }
          if (source) {
            s.overwrite(moduleInfo.start, moduleInfo.end, s.slice(source.start, source.end));
          }
        }
        if (hoistedMethodNames.includes(methodName)) {
          assertNotDefaultExport(node, "Cannot export hoisted variable. You can control hoisting behavior by placing the import from this file first.");
          const declarationNode = getVariableDeclaration(node);
          if (declarationNode) {
            assertNotNamedExport(declarationNode, "Cannot export hoisted variable. You can control hoisting behavior by placing the import from this file first.");
            hoistedNodes.push(declarationNode);
          } else {
            var _findNodeAround4;
            const awaitedExpression = (_findNodeAround4 = findNodeAround(ast, node.start, "AwaitExpression")) === null || _findNodeAround4 === void 0 ? void 0 : _findNodeAround4.node;
            const moveNode = (awaitedExpression === null || awaitedExpression === void 0 ? void 0 : awaitedExpression.argument) === node ? awaitedExpression : node;
            hoistedNodes.push(moveNode);
          }
        }
      }
    }
  });
  function getNodeName(node) {
    const callee = node.callee || {};
    if (callee.type === "MemberExpression" && isIdentifier(callee.property) && isIdentifier(callee.object)) {
      return `${callee.object.name}.${callee.property.name}()`;
    }
    return '"hoisted method"';
  }
  function getNodeCall(node) {
    if (node.type === "CallExpression") {
      return node;
    }
    if (node.type === "VariableDeclaration") {
      const { declarations } = node;
      const init3 = declarations[0].init;
      if (init3) {
        return getNodeCall(init3);
      }
    }
    if (node.type === "AwaitExpression") {
      const { argument } = node;
      if (argument.type === "CallExpression") {
        return getNodeCall(argument);
      }
    }
    return node;
  }
  function createError2(outsideNode, insideNode) {
    const outsideCall = getNodeCall(outsideNode);
    const insideCall = getNodeCall(insideNode);
    throw createSyntaxError(insideCall, `Cannot call ${getNodeName(insideCall)} inside ${getNodeName(outsideCall)}: both methods are hoisted to the top of the file and not actually called inside each other.`);
  }
  for (let i = 0; i < hoistedNodes.length; i++) {
    const node = hoistedNodes[i];
    for (let j = i + 1; j < hoistedNodes.length; j++) {
      const otherNode = hoistedNodes[j];
      if (node.start >= otherNode.start && node.end <= otherNode.end) {
        throw createError2(otherNode, node);
      }
      if (otherNode.start >= node.start && otherNode.end <= node.end) {
        throw createError2(node, otherNode);
      }
    }
  }
  for (const node of hoistedNodes) {
    const end = getNodeTail(code, node);
    if (hoistIndex === end || hoistIndex === node.start) {
      hoistIndex = end;
    } else {
      s.move(node.start, end, hoistIndex);
    }
  }
  for (const { node: importNode, id: importId } of imports) {
    const source = importNode.source.value;
    s.update(importNode.start, importNode.end, `const ${importId} = await import(${JSON.stringify(source)});
`);
    if (importNode.start === hoistIndex) {
      hoistIndex = importNode.end;
    } else {
      s.move(importNode.start, importNode.end, hoistIndex);
    }
  }
  if (!hoistedModuleImported && hoistedNodes.length) {
    const utilityImports = [...usedUtilityExports];
    if (utilityImports.some((name) => idToImportMap.has(name))) {
      s.prepend(API_NOT_FOUND_CHECK(utilityImports));
    } else if (utilityImports.length) {
      s.prepend(`import { ${[...usedUtilityExports].join(", ")} } from ${JSON.stringify(hoistedModule)}
`);
    }
  }
  return {
    code: s.toString(),
    map: s.generateMap({
      hires: "boundary",
      source: id
    })
  };
}

// node_modules/@vitest/utils/dist/resolver.js
var import_node_fs4 = __toESM(require_node_fs());
var packageCache = /* @__PURE__ */ new Map();
function findNearestPackageData(basedir) {
  const originalBasedir = basedir;
  while (basedir) {
    var _tryStatSync;
    const cached = getCachedData(packageCache, basedir, originalBasedir);
    if (cached) {
      return cached;
    }
    const pkgPath = join2(basedir, "package.json");
    if ((_tryStatSync = tryStatSync2(pkgPath)) === null || _tryStatSync === void 0 ? void 0 : _tryStatSync.isFile()) {
      const pkgData = JSON.parse(stripBomTag(import_node_fs4.default.readFileSync(pkgPath, "utf8")));
      if (packageCache) {
        setCacheData(packageCache, pkgData, basedir, originalBasedir);
      }
      return pkgData;
    }
    const nextBasedir = dirname2(basedir);
    if (nextBasedir === basedir) {
      break;
    }
    basedir = nextBasedir;
  }
  return {};
}
function stripBomTag(content) {
  if (content.charCodeAt(0) === 65279) {
    return content.slice(1);
  }
  return content;
}
function tryStatSync2(file) {
  try {
    return import_node_fs4.default.statSync(file, { throwIfNoEntry: false });
  } catch {
  }
}
function getCachedData(cache2, basedir, originalBasedir) {
  const pkgData = cache2.get(getFnpdCacheKey(basedir));
  if (pkgData) {
    traverseBetweenDirs(originalBasedir, basedir, (dir) => {
      cache2.set(getFnpdCacheKey(dir), pkgData);
    });
    return pkgData;
  }
}
function setCacheData(cache2, data, basedir, originalBasedir) {
  cache2.set(getFnpdCacheKey(basedir), data);
  traverseBetweenDirs(originalBasedir, basedir, (dir) => {
    cache2.set(getFnpdCacheKey(dir), data);
  });
}
function getFnpdCacheKey(basedir) {
  return `fnpd_${basedir}`;
}
function traverseBetweenDirs(longerDir, shorterDir, cb) {
  while (longerDir !== shorterDir) {
    cb(longerDir);
    longerDir = dirname2(longerDir);
  }
}

// node_modules/es-module-lexer/dist/lexer.js
var ImportType;
!function(A2) {
  A2[A2.Static = 1] = "Static", A2[A2.Dynamic = 2] = "Dynamic", A2[A2.ImportMeta = 3] = "ImportMeta", A2[A2.StaticSourcePhase = 4] = "StaticSourcePhase", A2[A2.DynamicSourcePhase = 5] = "DynamicSourcePhase", A2[A2.StaticDeferPhase = 6] = "StaticDeferPhase", A2[A2.DynamicDeferPhase = 7] = "DynamicDeferPhase";
}(ImportType || (ImportType = {}));
var A = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
function parse(E2, g = "@") {
  if (!C2) return init2.then(() => parse(E2));
  const I = E2.length + 1, w = (C2.__heap_base.value || C2.__heap_base) + 4 * I - C2.memory.buffer.byteLength;
  w > 0 && C2.memory.grow(Math.ceil(w / 65536));
  const K = C2.sa(I - 1);
  if ((A ? B : Q)(E2, new Uint16Array(C2.memory.buffer, K, I)), !C2.parse()) throw Object.assign(new Error(`Parse error ${g}:${E2.slice(0, C2.e()).split("\n").length}:${C2.e() - E2.lastIndexOf("\n", C2.e() - 1)}`), { idx: C2.e() });
  const o = [], D = [];
  for (; C2.ri(); ) {
    const A2 = C2.is(), Q2 = C2.ie(), B2 = C2.it(), g2 = C2.ai(), I2 = C2.id(), w2 = C2.ss(), K2 = C2.se();
    let D2;
    C2.ip() && (D2 = k(E2.slice(-1 === I2 ? A2 - 1 : A2, -1 === I2 ? Q2 + 1 : Q2))), o.push({ n: D2, t: B2, s: A2, e: Q2, ss: w2, se: K2, d: I2, a: g2 });
  }
  for (; C2.re(); ) {
    const A2 = C2.es(), Q2 = C2.ee(), B2 = C2.els(), g2 = C2.ele(), I2 = E2.slice(A2, Q2), w2 = I2[0], K2 = B2 < 0 ? void 0 : E2.slice(B2, g2), o2 = K2 ? K2[0] : "";
    D.push({ s: A2, e: Q2, ls: B2, le: g2, n: '"' === w2 || "'" === w2 ? k(I2) : I2, ln: '"' === o2 || "'" === o2 ? k(K2) : K2 });
  }
  function k(A2) {
    try {
      return (0, eval)(A2);
    } catch (A3) {
    }
  }
  return [o, D, !!C2.f(), !!C2.ms()];
}
function Q(A2, Q2) {
  const B2 = A2.length;
  let C3 = 0;
  for (; C3 < B2; ) {
    const B3 = A2.charCodeAt(C3);
    Q2[C3++] = (255 & B3) << 8 | B3 >>> 8;
  }
}
function B(A2, Q2) {
  const B2 = A2.length;
  let C3 = 0;
  for (; C3 < B2; ) Q2[C3] = A2.charCodeAt(C3++);
}
var C2;
var E = () => {
  return A2 = "AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKzkQwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQuFDAEKf0EAQQAoArAKIgBBDGoiATYCsApBARApIQJBACgCsAohAwJAAkACQAJAAkACQAJAAkAgAkEuRw0AQQAgA0ECajYCsAoCQEEBECkiAkHkAEYNAAJAIAJB8wBGDQAgAkHtAEcNB0EAKAKwCiICQQJqQZwIQQYQLw0HAkBBACgCnAoiAxAqDQAgAy8BAEEuRg0ICyAAIAAgAkEIakEAKALUCRABDwtBACgCsAoiAkECakGiCEEKEC8NBgJAQQAoApwKIgMQKg0AIAMvAQBBLkYNBwtBACEEQQAgAkEMajYCsApBASEFQQUhBkEBECkhAkEAIQdBASEIDAILQQAoArAKIgIpAAJC5YCYg9CMgDlSDQUCQEEAKAKcCiIDECoNACADLwEAQS5GDQYLQQAhBEEAIAJBCmo2ArAKQQIhCEEHIQZBASEHQQEQKSECQQEhBQwBCwJAAkACQAJAIAJB8wBHDQAgAyABTQ0AIANBAmpBoghBChAvDQACQCADLwEMIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAgsgBEGgAUYNAQtBACEHQQchBkEBIQQgAkHkAEYNAQwCC0EAIQRBACADQQxqIgI2ArAKQQEhBUEBECkhCQJAQQAoArAKIgYgAkYNAEHmACECAkAgCUHmAEYNAEEFIQZBACEHQQEhCCAJIQIMBAtBACEHQQEhCCAGQQJqQawIQQYQLw0EIAYvAQgQIEUNBAtBACEHQQAgAzYCsApBByEGQQEhBEEAIQVBACEIIAkhAgwCCyADIABBCmpNDQBBACEIQeQAIQICQCADKQACQuWAmIPQjIA5Ug0AAkACQCADLwEKIgRBd2oiB0EXSw0AQQEgB3RBn4CABHENAQtBACEIIARBoAFHDQELQQAhBUEAIANBCmo2ArAKQSohAkEBIQdBAiEIQQEQKSIJQSpGDQRBACADNgKwCkEBIQRBACEHQQAhCCAJIQIMAgsgAyEGQQAhBwwCC0EAIQVBACEICwJAIAJBKEcNAEEAKAKkCkEALwGYCiICQQN0aiIDQQAoArAKNgIEQQAgAkEBajsBmAogA0EFNgIAQQAoApwKLwEAQS5GDQRBAEEAKAKwCiIDQQJqNgKwCkEBECkhAiAAQQAoArAKQQAgAxABAkACQCAFDQBBACgC8AkhAQwBC0EAKALwCSIBIAY2AhwLQQBBAC8BlgoiA0EBajsBlgpBACgCqAogA0ECdGogATYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKwCkF+ajYCsAoPCyACEBpBAEEAKAKwCkECaiICNgKwCgJAAkACQEEBEClBV2oOBAECAgACC0EAQQAoArAKQQJqNgKwCkEBECkaQQAoAvAJIgMgAjYCBCADQQE6ABggA0EAKAKwCiICNgIQQQAgAkF+ajYCsAoPC0EAKALwCSIDIAI2AgQgA0EBOgAYQQBBAC8BmApBf2o7AZgKIANBACgCsApBAmo2AgxBAEEALwGWCkF/ajsBlgoPC0EAQQAoArAKQX5qNgKwCg8LAkAgBEEBcyACQfsAR3INAEEAKAKwCiECQQAvAZgKDQUDQAJAAkACQCACQQAoArQKTw0AQQEQKSICQSJGDQEgAkEnRg0BIAJB/QBHDQJBAEEAKAKwCkECajYCsAoLQQEQKSEDQQAoArAKIQICQCADQeYARw0AIAJBAmpBrAhBBhAvDQcLQQAgAkEIajYCsAoCQEEBECkiAkEiRg0AIAJBJ0cNBwsgACACQQAQKw8LIAIQGgtBAEEAKAKwCkECaiICNgKwCgwACwsCQAJAIAJBWWoOBAMBAQMACyACQSJGDQILQQAoArAKIQYLIAYgAUcNAEEAIABBCmo2ArAKDwsgAkEqRyAHcQ0DQQAvAZgKQf//A3ENA0EAKAKwCiECQQAoArQKIQEDQCACIAFPDQECQAJAIAIvAQAiA0EnRg0AIANBIkcNAQsgACADIAgQKw8LQQAgAkECaiICNgKwCgwACwsQJQsPC0EAIAJBfmo2ArAKDwtBAEEAKAKwCkF+ajYCsAoLRwEDf0EAKAKwCkECaiEAQQAoArQKIQECQANAIAAiAkF+aiABTw0BIAJBAmohACACLwEAQXZqDgQBAAABAAsLQQAgAjYCsAoLmAEBA39BAEEAKAKwCiIBQQJqNgKwCiABQQZqIQFBACgCtAohAgNAAkACQAJAIAFBfGogAk8NACABQX5qLwEAIQMCQAJAIAANACADQSpGDQEgA0F2ag4EAgQEAgQLIANBKkcNAwsgAS8BAEEvRw0CQQAgAUF+ajYCsAoMAQsgAUF+aiEBC0EAIAE2ArAKDwsgAUECaiEBDAALC4gBAQR/QQAoArAKIQFBACgCtAohAgJAAkADQCABIgNBAmohASADIAJPDQEgAS8BACIEIABGDQICQCAEQdwARg0AIARBdmoOBAIBAQIBCyADQQRqIQEgAy8BBEENRw0AIANBBmogASADLwEGQQpGGyEBDAALC0EAIAE2ArAKECUPC0EAIAE2ArAKC2wBAX8CQAJAIABBX2oiAUEFSw0AQQEgAXRBMXENAQsgAEFGakH//wNxQQZJDQAgAEEpRyAAQVhqQf//A3FBB0lxDQACQCAAQaV/ag4EAQAAAQALIABB/QBHIABBhX9qQf//A3FBBElxDwtBAQsuAQF/QQEhAQJAIABBpglBBRAdDQAgAEGWCEEDEB0NACAAQbAJQQIQHSEBCyABC0YBA39BACEDAkAgACACQQF0IgJrIgRBAmoiAEEAKALcCSIFSQ0AIAAgASACEC8NAAJAIAAgBUcNAEEBDwsgBBAmIQMLIAMLgwEBAn9BASEBAkACQAJAAkACQAJAIAAvAQAiAkFFag4EBQQEAQALAkAgAkGbf2oOBAMEBAIACyACQSlGDQQgAkH5AEcNAyAAQX5qQbwJQQYQHQ8LIABBfmovAQBBPUYPCyAAQX5qQbQJQQQQHQ8LIABBfmpByAlBAxAdDwtBACEBCyABC7QDAQJ/QQAhAQJAAkACQAJAAkACQAJAAkACQAJAIAAvAQBBnH9qDhQAAQIJCQkJAwkJBAUJCQYJBwkJCAkLAkACQCAAQX5qLwEAQZd/ag4EAAoKAQoLIABBfGpByghBAhAdDwsgAEF8akHOCEEDEB0PCwJAAkACQCAAQX5qLwEAQY1/ag4DAAECCgsCQCAAQXxqLwEAIgJB4QBGDQAgAkHsAEcNCiAAQXpqQeUAECcPCyAAQXpqQeMAECcPCyAAQXxqQdQIQQQQHQ8LIABBfGpB3AhBBhAdDwsgAEF+ai8BAEHvAEcNBiAAQXxqLwEAQeUARw0GAkAgAEF6ai8BACICQfAARg0AIAJB4wBHDQcgAEF4akHoCEEGEB0PCyAAQXhqQfQIQQIQHQ8LIABBfmpB+AhBBBAdDwtBASEBIABBfmoiAEHpABAnDQQgAEGACUEFEB0PCyAAQX5qQeQAECcPCyAAQX5qQYoJQQcQHQ8LIABBfmpBmAlBBBAdDwsCQCAAQX5qLwEAIgJB7wBGDQAgAkHlAEcNASAAQXxqQe4AECcPCyAAQXxqQaAJQQMQHSEBCyABCzQBAX9BASEBAkAgAEF3akH//wNxQQVJDQAgAEGAAXJBoAFGDQAgAEEuRyAAEChxIQELIAELMAEBfwJAAkAgAEF3aiIBQRdLDQBBASABdEGNgIAEcQ0BCyAAQaABRg0AQQAPC0EBC04BAn9BACEBAkACQCAALwEAIgJB5QBGDQAgAkHrAEcNASAAQX5qQfgIQQQQHQ8LIABBfmovAQBB9QBHDQAgAEF8akHcCEEGEB0hAQsgAQveAQEEf0EAKAKwCiEAQQAoArQKIQECQAJAAkADQCAAIgJBAmohACACIAFPDQECQAJAAkAgAC8BACIDQaR/ag4FAgMDAwEACyADQSRHDQIgAi8BBEH7AEcNAkEAIAJBBGoiADYCsApBAEEALwGYCiICQQFqOwGYCkEAKAKkCiACQQN0aiICQQQ2AgAgAiAANgIEDwtBACAANgKwCkEAQQAvAZgKQX9qIgA7AZgKQQAoAqQKIABB//8DcUEDdGooAgBBA0cNAwwECyACQQRqIQAMAAsLQQAgADYCsAoLECULC3ABAn8CQAJAA0BBAEEAKAKwCiIAQQJqIgE2ArAKIABBACgCtApPDQECQAJAAkAgAS8BACIBQaV/ag4CAQIACwJAIAFBdmoOBAQDAwQACyABQS9HDQIMBAsQLhoMAQtBACAAQQRqNgKwCgwACwsQJQsLNQEBf0EAQQE6APwJQQAoArAKIQBBAEEAKAK0CkECajYCsApBACAAQQAoAtwJa0EBdTYCkAoLQwECf0EBIQECQCAALwEAIgJBd2pB//8DcUEFSQ0AIAJBgAFyQaABRg0AQQAhASACEChFDQAgAkEuRyAAECpyDwsgAQs9AQJ/QQAhAgJAQQAoAtwJIgMgAEsNACAALwEAIAFHDQACQCADIABHDQBBAQ8LIABBfmovAQAQICECCyACC2gBAn9BASEBAkACQCAAQV9qIgJBBUsNAEEBIAJ0QTFxDQELIABB+P8DcUEoRg0AIABBRmpB//8DcUEGSQ0AAkAgAEGlf2oiAkEDSw0AIAJBAUcNAQsgAEGFf2pB//8DcUEESSEBCyABC5wBAQN/QQAoArAKIQECQANAAkACQCABLwEAIgJBL0cNAAJAIAEvAQIiAUEqRg0AIAFBL0cNBBAYDAILIAAQGQwBCwJAAkAgAEUNACACQXdqIgFBF0sNAUEBIAF0QZ+AgARxRQ0BDAILIAIQIUUNAwwBCyACQaABRw0CC0EAQQAoArAKIgNBAmoiATYCsAogA0EAKAK0CkkNAAsLIAILMQEBf0EAIQECQCAALwEAQS5HDQAgAEF+ai8BAEEuRw0AIABBfGovAQBBLkYhAQsgAQumBAEBfwJAIAFBIkYNACABQSdGDQAQJQ8LQQAoArAKIQMgARAaIAAgA0ECakEAKAKwCkEAKALQCRABAkAgAkEBSA0AQQAoAvAJQQRBBiACQQFGGzYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQIMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhAiABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIAJBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiACECA0BBACACQQJqNgKwCgJAAkACQEEBECkiAkEiRg0AIAJBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQIMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSECDAELIAIQLCECCwJAIAJBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAkEiRg0AIAJBJ0YNAEEAIAE2ArAKDwsgAhAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAkEsRg0AIAJB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiECDAELC0EAKALwCSIBIAA2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=", "undefined" != typeof Buffer ? Buffer.from(A2, "base64") : Uint8Array.from(atob(A2), (A3) => A3.charCodeAt(0));
  var A2;
};
var init2 = WebAssembly.compile(E()).then(WebAssembly.instantiate).then(({ exports: A2 }) => {
  C2 = A2;
});

// node_modules/vitest/dist/chunks/index.BdSLhLDZ.js
var import_node_fs5 = __toESM(require_node_fs(), 1);
var import_node_util2 = __toESM(require_node_util(), 1);
function createBenchmarkJsonReport(files) {
  var _a2;
  const report = { files: [] };
  for (const file of files) {
    const groups = [];
    for (const task of getTasks(file)) if ((task == null ? void 0 : task.type) === "suite") {
      const benchmarks = [];
      for (const t of task.tasks) {
        const benchmark2 = t.meta.benchmark && ((_a2 = t.result) == null ? void 0 : _a2.benchmark);
        if (benchmark2) benchmarks.push({
          id: t.id,
          ...benchmark2,
          samples: []
        });
      }
      if (benchmarks.length) groups.push({
        fullName: getFullName(task, " > "),
        benchmarks
      });
    }
    report.files.push({
      filepath: file.filepath,
      groups
    });
  }
  return report;
}
function flattenFormattedBenchmarkReport(report) {
  const flat = {};
  for (const file of report.files) for (const group of file.groups) for (const t of group.benchmarks) flat[t.id] = t;
  return flat;
}
var outputMap = /* @__PURE__ */ new WeakMap();
function formatNumber(number) {
  const res = String(number.toFixed(number < 100 ? 4 : 2)).split(".");
  return res[0].replace(/(?=(?:\d{3})+$)\B/g, ",") + (res[1] ? `.${res[1]}` : "");
}
var tableHead = [
  "name",
  "hz",
  "min",
  "max",
  "mean",
  "p75",
  "p99",
  "p995",
  "p999",
  "rme",
  "samples"
];
function renderBenchmarkItems(result) {
  return [
    result.name,
    formatNumber(result.hz || 0),
    formatNumber(result.min || 0),
    formatNumber(result.max || 0),
    formatNumber(result.mean || 0),
    formatNumber(result.p75 || 0),
    formatNumber(result.p99 || 0),
    formatNumber(result.p995 || 0),
    formatNumber(result.p999 || 0),
    `${(result.rme || 0).toFixed(2)}%`,
    (result.sampleCount || 0).toString()
  ];
}
function computeColumnWidths(results) {
  const rows = [tableHead, ...results.map((v) => renderBenchmarkItems(v))];
  return Array.from(tableHead, (_, i) => Math.max(...rows.map((row) => (0, import_node_util2.stripVTControlCharacters)(row[i]).length)));
}
function padRow(row, widths) {
  return row.map((v, i) => i ? v.padStart(widths[i], " ") : v.padEnd(widths[i], " "));
}
function renderTableHead(widths) {
  return " ".repeat(3) + padRow(tableHead, widths).map(C.bold).join("  ");
}
function renderBenchmark(result, widths) {
  const padded = padRow(renderBenchmarkItems(result), widths);
  return [
    padded[0],
    C.blue(padded[1]),
    C.cyan(padded[2]),
    C.cyan(padded[3]),
    C.cyan(padded[4]),
    C.cyan(padded[5]),
    C.cyan(padded[6]),
    C.cyan(padded[7]),
    C.cyan(padded[8]),
    C.dim(padded[9]),
    C.dim(padded[10])
  ].join("  ");
}
function renderTable(options) {
  var _a2, _b2, _c, _d, _e, _f;
  const output = [], benchMap = {};
  for (const task of options.tasks) if (task.meta.benchmark && ((_a2 = task.result) == null ? void 0 : _a2.benchmark)) benchMap[task.id] = {
    current: task.result.benchmark,
    baseline: (_b2 = options.compare) == null ? void 0 : _b2[task.id]
  };
  const benchCount = Object.entries(benchMap).length, columnWidths = computeColumnWidths(Object.values(benchMap).flatMap((v) => [v.current, v.baseline]).filter(notNullish));
  let idx = 0;
  const padding = "  ".repeat(1);
  for (const task of options.tasks) {
    const duration = (_c = task.result) == null ? void 0 : _c.duration, bench = benchMap[task.id];
    let prefix = "";
    if (idx === 0 && ((_d = task.meta) == null ? void 0 : _d.benchmark)) prefix += `${renderTableHead(columnWidths)}
${padding}`;
    prefix += ` ${getStateSymbol(task)} `;
    let suffix = "";
    if (task.type === "suite") suffix += C.dim(` (${getTests(task).length})`);
    if (task.mode === "skip" || task.mode === "todo") suffix += C.dim(C.gray(" [skipped]"));
    if (duration != null) {
      const color = duration > options.slowTestThreshold ? C.yellow : C.green;
      suffix += color(` ${Math.round(duration)}${C.dim("ms")}`);
    }
    if (options.showHeap && ((_e = task.result) == null ? void 0 : _e.heap) != null) suffix += C.magenta(` ${Math.floor(task.result.heap / 1024 / 1024)} MB heap used`);
    if (bench) {
      let body = renderBenchmark(bench.current, columnWidths);
      if (options.compare && bench.baseline) {
        if (bench.current.hz) {
          const diff = bench.current.hz / bench.baseline.hz, diffFixed = diff.toFixed(2);
          if (diffFixed === "1.0.0") body += C.gray(`  [${diffFixed}x]`);
          if (diff > 1) body += C.blue(`  [${diffFixed}x] `);
          else body += C.red(`  [${diffFixed}x] `);
        }
        output.push(padding + prefix + body + suffix);
        const bodyBaseline = renderBenchmark(bench.baseline, columnWidths);
        output.push(`${padding}   ${bodyBaseline}  ${C.dim("(baseline)")}`);
      } else {
        if (bench.current.rank === 1 && benchCount > 1) body += C.bold(C.green("   fastest"));
        if (bench.current.rank === benchCount && benchCount > 2) body += C.bold(C.gray("   slowest"));
        output.push(padding + prefix + body + suffix);
      }
    } else output.push(padding + prefix + task.name + suffix);
    if (((_f = task.result) == null ? void 0 : _f.state) !== "pass" && outputMap.get(task) != null) {
      let data = outputMap.get(task);
      if (typeof data === "string") {
        if (data = (0, import_node_util2.stripVTControlCharacters)(data.trim().split("\n").filter(Boolean).pop()), data === "") data = void 0;
      }
      if (data != null) {
        const out = `   ${"  ".repeat(options.level)}${F_RIGHT} ${data}`;
        output.push(C.gray(truncateString(out, options.columns)));
      }
    }
    idx++;
  }
  return output.filter(Boolean).join("\n");
}
var BenchmarkReporter = class extends DefaultReporter {
  constructor() {
    super(...arguments);
    __publicField(this, "compare");
  }
  async onInit(ctx) {
    var _a2, _b2;
    if (super.onInit(ctx), (_a2 = this.ctx.config.benchmark) == null ? void 0 : _a2.compare) {
      const compareFile = resolve(this.ctx.config.root, (_b2 = this.ctx.config.benchmark) == null ? void 0 : _b2.compare);
      try {
        this.compare = flattenFormattedBenchmarkReport(JSON.parse(await import_node_fs5.default.promises.readFile(compareFile, "utf-8")));
      } catch (e) {
        this.error(`Failed to read '${compareFile}'`, e);
      }
    }
  }
  onTaskUpdate(packs) {
    var _a2;
    for (const pack of packs) {
      const task = this.ctx.state.idMap.get(pack[0]);
      if ((task == null ? void 0 : task.type) === "suite" && ((_a2 = task.result) == null ? void 0 : _a2.state) !== "run") task.tasks.filter((task2) => {
        var _a3;
        return (_a3 = task2.result) == null ? void 0 : _a3.benchmark;
      }).sort((benchA, benchB) => benchA.result.benchmark.mean - benchB.result.benchmark.mean).forEach((bench, idx) => {
        bench.result.benchmark.rank = Number(idx) + 1;
      });
    }
  }
  onTestSuiteResult(testSuite) {
    super.onTestSuiteResult(testSuite), this.printSuiteTable(testSuite);
  }
  printTestModule(testModule) {
    this.printSuiteTable(testModule);
  }
  printSuiteTable(testTask) {
    var _a2;
    const state = testTask.state();
    if (state === "pending" || state === "queued") return;
    const benches = testTask.task.tasks.filter((t) => t.meta.benchmark), duration = ((_a2 = testTask.task.result) == null ? void 0 : _a2.duration) || 0;
    if (benches.length > 0 && benches.every((t) => {
      var _a3, _b2;
      return ((_a3 = t.result) == null ? void 0 : _a3.state) !== "run" && ((_b2 = t.result) == null ? void 0 : _b2.state) !== "queued";
    })) {
      let title = `
 ${getStateSymbol(testTask.task)} ${formatProjectName(testTask.project)}${getFullName(testTask.task, separator)}`;
      if (duration != null && duration > this.ctx.config.slowTestThreshold) title += C.yellow(` ${Math.round(duration)}${C.dim("ms")}`);
      this.log(title), this.log(renderTable({
        tasks: benches,
        level: 1,
        columns: this.ctx.logger.getColumns(),
        compare: this.compare,
        showHeap: this.ctx.config.logHeapUsage,
        slowTestThreshold: this.ctx.config.slowTestThreshold
      }));
    }
  }
  async onTestRunEnd(testModules, unhandledErrors, reason) {
    var _a2;
    super.onTestRunEnd(testModules, unhandledErrors, reason);
    let outputFile = (_a2 = this.ctx.config.benchmark) == null ? void 0 : _a2.outputJson;
    if (outputFile) {
      outputFile = resolve(this.ctx.config.root, outputFile);
      const outputDirectory = dirname(outputFile);
      if (!import_node_fs5.default.existsSync(outputDirectory)) await import_node_fs5.default.promises.mkdir(outputDirectory, { recursive: true });
      const files = testModules.map((t) => t.task.file), output = createBenchmarkJsonReport(files);
      await import_node_fs5.default.promises.writeFile(outputFile, JSON.stringify(output, null, 2)), this.log(`Benchmark report written to ${outputFile}`);
    }
  }
};
var VerboseBenchmarkReporter = class extends BenchmarkReporter {
  constructor() {
    super(...arguments);
    __publicField(this, "verbose", true);
  }
};
var BenchmarkReportsMap = {
  default: BenchmarkReporter,
  verbose: VerboseBenchmarkReporter
};

// node_modules/vitest/dist/chunks/cli-api.6GYRwzrM.js
var import_node_assert2 = __toESM(require_node_assert(), 1);
var import_node_readline = __toESM(require_node_readline(), 1);
var import_node_util3 = __toESM(require_node_util(), 1);
var bufferUtil = { exports: {} };
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
  const hasBlob = typeof Blob !== "undefined";
  if (hasBlob) BINARY_TYPES.push("blob");
  constants = {
    BINARY_TYPES,
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    hasBlob,
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {
    }
  };
  return constants;
}
var hasRequiredBufferUtil;
function requireBufferUtil() {
  if (hasRequiredBufferUtil) return bufferUtil.exports;
  hasRequiredBufferUtil = 1;
  const { EMPTY_BUFFER } = requireConstants();
  const FastBuffer = Buffer[Symbol.species];
  function concat(list, totalLength) {
    if (list.length === 0) return EMPTY_BUFFER;
    if (list.length === 1) return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0; i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  }
  function _mask(source, mask, output, offset, length) {
    for (let i = 0; i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  }
  function _unmask(buffer, mask) {
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  }
  function toArrayBuffer(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  }
  function toBuffer(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data)) return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  }
  bufferUtil.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil$1 = __require("bufferutil");
      bufferUtil.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48) _mask(source, mask, output, offset, length);
        else bufferUtil$1.mask(source, mask, output, offset, length);
      };
      bufferUtil.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32) _unmask(buffer, mask);
        else bufferUtil$1.unmask(buffer, mask);
      };
    } catch (e) {
    }
  }
  return bufferUtil.exports;
}
var limiter;
var hasRequiredLimiter;
function requireLimiter() {
  if (hasRequiredLimiter) return limiter;
  hasRequiredLimiter = 1;
  const kDone = Symbol("kDone");
  const kRun = Symbol("kRun");
  class Limiter {
    /**
     * Creates a new `Limiter`.
     *
     * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
     *     to run concurrently
     */
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    /**
     * Adds a job to the queue.
     *
     * @param {Function} job The job to run
     * @public
     */
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    /**
     * Removes a job from the queue and runs it if possible.
     *
     * @private
     */
    [kRun]() {
      if (this.pending === this.concurrency) return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  limiter = Limiter;
  return limiter;
}
var permessageDeflate;
var hasRequiredPermessageDeflate;
function requirePermessageDeflate() {
  if (hasRequiredPermessageDeflate) return permessageDeflate;
  hasRequiredPermessageDeflate = 1;
  const zlib = import_zlib.default;
  const bufferUtil2 = requireBufferUtil();
  const Limiter = requireLimiter();
  const { kStatusCode } = requireConstants();
  const FastBuffer = Buffer[Symbol.species];
  const TRAILER = Buffer.from([0, 0, 255, 255]);
  const kPerMessageDeflate = Symbol("permessage-deflate");
  const kTotalLength = Symbol("total-length");
  const kCallback = Symbol("callback");
  const kBuffers = Symbol("buffers");
  const kError = Symbol("error");
  let zlibLimiter;
  class PerMessageDeflate {
    /**
     * Creates a PerMessageDeflate instance.
     *
     * @param {Object} [options] Configuration options
     * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
     *     for, or request, a custom client window size
     * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
     *     acknowledge disabling of client context takeover
     * @param {Number} [options.concurrencyLimit=10] The number of concurrent
     *     calls to zlib
     * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
     *     use of a custom server window size
     * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
     *     disabling of server context takeover
     * @param {Number} [options.threshold=1024] Size (in bytes) below which
     *     messages should not be compressed if context takeover is disabled
     * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
     *     deflate
     * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
     *     inflate
     * @param {Boolean} [isServer=false] Create the instance in either server or
     *     client mode
     * @param {Number} [maxPayload=0] The maximum allowed message length
     */
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    /**
     * @type {String}
     */
    static get extensionName() {
      return "permessage-deflate";
    }
    /**
     * Create an extension negotiation offer.
     *
     * @return {Object} Extension parameters
     * @public
     */
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    /**
     * Accept an extension negotiation offer/response.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Object} Accepted configuration
     * @public
     */
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    /**
     * Releases all resources used by the extension.
     *
     * @public
     */
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(
            new Error(
              "The deflate stream was closed while data was being processed"
            )
          );
        }
      }
    }
    /**
     *  Accept an extension negotiation offer.
     *
     * @param {Array} offers The extension negotiation offers
     * @return {Object} Accepted configuration
     * @private
     */
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    /**
     * Accept the extension negotiation response.
     *
     * @param {Array} response The extension negotiation response
     * @return {Object} Accepted configuration
     * @private
     */
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error(
          'Unexpected or invalid parameter "client_max_window_bits"'
        );
      }
      return params;
    }
    /**
     * Normalize parameters.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Array} The offers/response with normalized parameters
     * @private
     */
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    /**
     * Decompress data. Concurrency limited.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Compress data. Concurrency limited.
     *
     * @param {(Buffer|String)} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Decompress data.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin) this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil2.concat(
          this._inflate[kBuffers],
          this._inflate[kTotalLength]
        );
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    /**
     * Compress data.
     *
     * @param {(Buffer|String)} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil2.concat(
          this._deflate[kBuffers],
          this._deflate[kTotalLength]
        );
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  permessageDeflate = PerMessageDeflate;
  function deflateOnData(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  }
  function inflateOnData(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  }
  function inflateOnError(err) {
    this[kPerMessageDeflate]._inflate = null;
    if (this[kError]) {
      this[kCallback](this[kError]);
      return;
    }
    err[kStatusCode] = 1007;
    this[kCallback](err);
  }
  return permessageDeflate;
}
var validation = { exports: {} };
var hasRequiredValidation;
function requireValidation() {
  if (hasRequiredValidation) return validation.exports;
  hasRequiredValidation = 1;
  const { isUtf8 } = import_buffer.default;
  const { hasBlob } = requireConstants();
  const tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 0 - 15
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 16 - 31
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    // 32 - 47
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    // 48 - 63
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    // 64 - 79
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    // 80 - 95
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    // 96 - 111
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
    // 112 - 127
  ];
  function isValidStatusCode(code) {
    return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
  }
  function _isValidUTF8(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
        buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
        buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  }
  function isBlob(value) {
    return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
  }
  validation.exports = {
    isBlob,
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    validation.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = __require("utf-8-validate");
      validation.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
    }
  }
  return validation.exports;
}
var receiver;
var hasRequiredReceiver;
function requireReceiver() {
  if (hasRequiredReceiver) return receiver;
  hasRequiredReceiver = 1;
  const { Writable } = import_stream.default;
  const PerMessageDeflate = requirePermessageDeflate();
  const {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = requireConstants();
  const { concat, toArrayBuffer, unmask } = requireBufferUtil();
  const { isValidStatusCode, isValidUTF8 } = requireValidation();
  const FastBuffer = Buffer[Symbol.species];
  const GET_INFO = 0;
  const GET_PAYLOAD_LENGTH_16 = 1;
  const GET_PAYLOAD_LENGTH_64 = 2;
  const GET_MASK = 3;
  const GET_DATA = 4;
  const INFLATING = 5;
  const DEFER_EVENT = 6;
  class Receiver extends Writable {
    /**
     * Creates a Receiver instance.
     *
     * @param {Object} [options] Options object
     * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
     *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
     *     multiple times in the same tick
     * @param {String} [options.binaryType=nodebuffer] The type for binary data
     * @param {Object} [options.extensions] An object containing the negotiated
     *     extensions
     * @param {Boolean} [options.isServer=false] Specifies whether to operate in
     *     client or server mode
     * @param {Number} [options.maxPayload=0] The maximum allowed message length
     * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
     *     not to skip UTF-8 validation for text and close messages
     */
    constructor(options = {}) {
      super();
      this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = void 0;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = void 0;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._errored = false;
      this._loop = false;
      this._state = GET_INFO;
    }
    /**
     * Implements `Writable.prototype._write()`.
     *
     * @param {Buffer} chunk The chunk of data to write
     * @param {String} encoding The character encoding of `chunk`
     * @param {Function} cb Callback
     * @private
     */
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO) return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    /**
     * Consumes `n` bytes from the buffered data.
     *
     * @param {Number} n The number of bytes to consume
     * @return {Buffer} The consumed bytes
     * @private
     */
    consume(n2) {
      this._bufferedBytes -= n2;
      if (n2 === this._buffers[0].length) return this._buffers.shift();
      if (n2 < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n2,
          buf.length - n2
        );
        return new FastBuffer(buf.buffer, buf.byteOffset, n2);
      }
      const dst = Buffer.allocUnsafe(n2);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n2;
        if (n2 >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n2), offset);
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n2,
            buf.length - n2
          );
        }
        n2 -= buf.length;
      } while (n2 > 0);
      return dst;
    }
    /**
     * Starts the parsing loop.
     *
     * @param {Function} cb Callback
     * @private
     */
    startLoop(cb) {
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            this.getInfo(cb);
            break;
          case GET_PAYLOAD_LENGTH_16:
            this.getPayloadLength16(cb);
            break;
          case GET_PAYLOAD_LENGTH_64:
            this.getPayloadLength64(cb);
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            this.getData(cb);
            break;
          case INFLATING:
          case DEFER_EVENT:
            this._loop = false;
            return;
        }
      } while (this._loop);
      if (!this._errored) cb();
    }
    /**
     * Reads the first two bytes of a frame.
     *
     * @param {Function} cb Callback
     * @private
     */
    getInfo(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        const error = this.createError(
          RangeError,
          "RSV2 and RSV3 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_2_3"
        );
        cb(error);
        return;
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        const error = this.createError(
          RangeError,
          "RSV1 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
        cb(error);
        return;
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        if (!this._fragmented) {
          const error = this.createError(
            RangeError,
            "invalid opcode 0",
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          const error = this.createError(
            RangeError,
            "FIN must be set",
            true,
            1002,
            "WS_ERR_EXPECTED_FIN"
          );
          cb(error);
          return;
        }
        if (compressed) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          const error = this.createError(
            RangeError,
            `invalid payload length ${this._payloadLength}`,
            true,
            1002,
            "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
      } else {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
        cb(error);
        return;
      }
      if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be set",
            true,
            1002,
            "WS_ERR_EXPECTED_MASK"
          );
          cb(error);
          return;
        }
      } else if (this._masked) {
        const error = this.createError(
          RangeError,
          "MASK must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_MASK"
        );
        cb(error);
        return;
      }
      if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
      else this.haveLength(cb);
    }
    /**
     * Gets extended payload length (7+16).
     *
     * @param {Function} cb Callback
     * @private
     */
    getPayloadLength16(cb) {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      this.haveLength(cb);
    }
    /**
     * Gets extended payload length (7+64).
     *
     * @param {Function} cb Callback
     * @private
     */
    getPayloadLength64(cb) {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        const error = this.createError(
          RangeError,
          "Unsupported WebSocket frame: payload length > 2^53 - 1",
          false,
          1009,
          "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
        );
        cb(error);
        return;
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      this.haveLength(cb);
    }
    /**
     * Payload length has been read.
     *
     * @param {Function} cb Callback
     * @private
     */
    haveLength(cb) {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            "Max payload size exceeded",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
          );
          cb(error);
          return;
        }
      }
      if (this._masked) this._state = GET_MASK;
      else this._state = GET_DATA;
    }
    /**
     * Reads mask bytes.
     *
     * @private
     */
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    /**
     * Reads data bytes.
     *
     * @param {Function} cb Callback
     * @private
     */
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7) {
        this.controlMessage(data, cb);
        return;
      }
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      this.dataMessage(cb);
    }
    /**
     * Decompresses data.
     *
     * @param {Buffer} data Compressed data
     * @param {Function} cb Callback
     * @private
     */
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err) return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
          this._fragments.push(buf);
        }
        this.dataMessage(cb);
        if (this._state === GET_INFO) this.startLoop(cb);
      });
    }
    /**
     * Handles a data message.
     *
     * @param {Function} cb Callback
     * @private
     */
    dataMessage(cb) {
      if (!this._fin) {
        this._state = GET_INFO;
        return;
      }
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data;
        if (this._binaryType === "nodebuffer") {
          data = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data = toArrayBuffer(concat(fragments, messageLength));
        } else if (this._binaryType === "blob") {
          data = new Blob(fragments);
        } else {
          data = fragments;
        }
        if (this._allowSynchronousEvents) {
          this.emit("message", data, true);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", data, true);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            "invalid UTF-8 sequence",
            true,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
          cb(error);
          return;
        }
        if (this._state === INFLATING || this._allowSynchronousEvents) {
          this.emit("message", buf, false);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit("message", buf, false);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
    }
    /**
     * Handles a control message.
     *
     * @param {Buffer} data Data to handle
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */
    controlMessage(data, cb) {
      if (this._opcode === 8) {
        if (data.length === 0) {
          this._loop = false;
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            const error = this.createError(
              RangeError,
              `invalid status code ${code}`,
              true,
              1002,
              "WS_ERR_INVALID_CLOSE_CODE"
            );
            cb(error);
            return;
          }
          const buf = new FastBuffer(
            data.buffer,
            data.byteOffset + 2,
            data.length - 2
          );
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          this._loop = false;
          this.emit("conclude", code, buf);
          this.end();
        }
        this._state = GET_INFO;
        return;
      }
      if (this._allowSynchronousEvents) {
        this.emit(this._opcode === 9 ? "ping" : "pong", data);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
    /**
     * Builds an error object.
     *
     * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
     * @param {String} message The error message
     * @param {Boolean} prefix Specifies whether or not to add a default prefix to
     *     `message`
     * @param {Number} statusCode The status code
     * @param {String} errorCode The exposed error code
     * @return {(Error|RangeError)} The error
     * @private
     */
    createError(ErrorCtor, message, prefix, statusCode, errorCode) {
      this._loop = false;
      this._errored = true;
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, this.createError);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
  receiver = Receiver;
  return receiver;
}
var sender;
var hasRequiredSender;
function requireSender() {
  if (hasRequiredSender) return sender;
  hasRequiredSender = 1;
  const { Duplex } = import_stream.default;
  const { randomFillSync } = import_crypto.default;
  const PerMessageDeflate = requirePermessageDeflate();
  const { EMPTY_BUFFER, kWebSocket, NOOP } = requireConstants();
  const { isBlob, isValidStatusCode } = requireValidation();
  const { mask: applyMask, toBuffer } = requireBufferUtil();
  const kByteLength = Symbol("kByteLength");
  const maskBuffer = Buffer.alloc(4);
  const RANDOM_POOL_SIZE = 8 * 1024;
  let randomPool;
  let randomPoolPointer = RANDOM_POOL_SIZE;
  const DEFAULT = 0;
  const DEFLATING = 1;
  const GET_BLOB_DATA = 2;
  class Sender {
    /**
     * Creates a Sender instance.
     *
     * @param {Duplex} socket The connection socket
     * @param {Object} [extensions] An object containing the negotiated extensions
     * @param {Function} [generateMask] The function used to generate the masking
     *     key
     */
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._queue = [];
      this._state = DEFAULT;
      this.onerror = NOOP;
      this[kWebSocket] = void 0;
    }
    /**
     * Frames a piece of data according to the HyBi WebSocket protocol.
     *
     * @param {(Buffer|String)} data The data to frame
     * @param {Object} options Options object
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Function} [options.generateMask] The function used to generate the
     *     masking key
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
     *     key
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @return {(Buffer|String)[]} The framed data
     * @public
     */
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          if (randomPoolPointer === RANDOM_POOL_SIZE) {
            if (randomPool === void 0) {
              randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
            }
            randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
            randomPoolPointer = 0;
          }
          mask[0] = randomPool[randomPoolPointer++];
          mask[1] = randomPool[randomPoolPointer++];
          mask[2] = randomPool[randomPoolPointer++];
          mask[3] = randomPool[randomPoolPointer++];
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1) target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask) return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking) return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    /**
     * Sends a close message to the other peer.
     *
     * @param {Number} [code] The status code component of the body
     * @param {(String|Buffer)} [data] The message component of the body
     * @param {Boolean} [mask=false] Specifies whether or not to mask the message
     * @param {Function} [cb] Callback
     * @public
     */
    close(code, data, mask, cb) {
      let buf;
      if (code === void 0) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === void 0 || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    /**
     * Sends a ping message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    /**
     * Sends a pong message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, false, options, cb]);
        } else {
          this.getBlobData(data, false, options, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    /**
     * Sends a data message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Object} options Options object
     * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
     *     or text
     * @param {Boolean} [options.compress=false] Specifies whether or not to
     *     compress `data`
     * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Function} [cb] Callback
     * @public
     */
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else if (isBlob(data)) {
        byteLength = data.size;
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin) this._firstFragment = true;
      const opts = {
        [kByteLength]: byteLength,
        fin: options.fin,
        generateMask: this._generateMask,
        mask: options.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (isBlob(data)) {
        if (this._state !== DEFAULT) {
          this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
        } else {
          this.getBlobData(data, this._compress, opts, cb);
        }
      } else if (this._state !== DEFAULT) {
        this.enqueue([this.dispatch, data, this._compress, opts, cb]);
      } else {
        this.dispatch(data, this._compress, opts, cb);
      }
    }
    /**
     * Gets the contents of a blob as binary data.
     *
     * @param {Blob} blob The blob
     * @param {Boolean} [compress=false] Specifies whether or not to compress
     *     the data
     * @param {Object} options Options object
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Function} [options.generateMask] The function used to generate the
     *     masking key
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
     *     key
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @param {Function} [cb] Callback
     * @private
     */
    getBlobData(blob, compress, options, cb) {
      this._bufferedBytes += options[kByteLength];
      this._state = GET_BLOB_DATA;
      blob.arrayBuffer().then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error(
            "The socket was closed while the blob was being read"
          );
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);
        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      }).catch((err) => {
        process.nextTick(onError, this, err, cb);
      });
    }
    /**
     * Dispatches a message.
     *
     * @param {(Buffer|String)} data The message to send
     * @param {Boolean} [compress=false] Specifies whether or not to compress
     *     `data`
     * @param {Object} options Options object
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Function} [options.generateMask] The function used to generate the
     *     masking key
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
     *     key
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @param {Function} [cb] Callback
     * @private
     */
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._state = DEFLATING;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error(
            "The socket was closed while data was being compressed"
          );
          callCallbacks(this, err, cb);
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._state = DEFAULT;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    /**
     * Executes queued send operations.
     *
     * @private
     */
    dequeue() {
      while (this._state === DEFAULT && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    /**
     * Enqueues a send operation.
     *
     * @param {Array} params Send operation parameters.
     * @private
     */
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    /**
     * Sends a frame.
     *
     * @param {(Buffer | String)[]} list The frame to send
     * @param {Function} [cb] Callback
     * @private
     */
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  sender = Sender;
  function callCallbacks(sender2, err, cb) {
    if (typeof cb === "function") cb(err);
    for (let i = 0; i < sender2._queue.length; i++) {
      const params = sender2._queue[i];
      const callback = params[params.length - 1];
      if (typeof callback === "function") callback(err);
    }
  }
  function onError(sender2, err, cb) {
    callCallbacks(sender2, err, cb);
    sender2.onerror(err);
  }
  return sender;
}
var eventTarget;
var hasRequiredEventTarget;
function requireEventTarget() {
  if (hasRequiredEventTarget) return eventTarget;
  hasRequiredEventTarget = 1;
  const { kForOnEventAttribute, kListener } = requireConstants();
  const kCode = Symbol("kCode");
  const kData = Symbol("kData");
  const kError = Symbol("kError");
  const kMessage = Symbol("kMessage");
  const kReason = Symbol("kReason");
  const kTarget = Symbol("kTarget");
  const kType = Symbol("kType");
  const kWasClean = Symbol("kWasClean");
  class Event {
    /**
     * Create a new `Event`.
     *
     * @param {String} type The name of the event
     * @throws {TypeError} If the `type` argument is not specified
     */
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    /**
     * @type {*}
     */
    get target() {
      return this[kTarget];
    }
    /**
     * @type {String}
     */
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event.prototype, "target", { enumerable: true });
  Object.defineProperty(Event.prototype, "type", { enumerable: true });
  class CloseEvent extends Event {
    /**
     * Create a new `CloseEvent`.
     *
     * @param {String} type The name of the event
     * @param {Object} [options] A dictionary object that allows for setting
     *     attributes via object members of the same name
     * @param {Number} [options.code=0] The status code explaining why the
     *     connection was closed
     * @param {String} [options.reason=''] A human-readable string explaining why
     *     the connection was closed
     * @param {Boolean} [options.wasClean=false] Indicates whether or not the
     *     connection was cleanly closed
     */
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === void 0 ? 0 : options.code;
      this[kReason] = options.reason === void 0 ? "" : options.reason;
      this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
    }
    /**
     * @type {Number}
     */
    get code() {
      return this[kCode];
    }
    /**
     * @type {String}
     */
    get reason() {
      return this[kReason];
    }
    /**
     * @type {Boolean}
     */
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
  class ErrorEvent extends Event {
    /**
     * Create a new `ErrorEvent`.
     *
     * @param {String} type The name of the event
     * @param {Object} [options] A dictionary object that allows for setting
     *     attributes via object members of the same name
     * @param {*} [options.error=null] The error that generated this event
     * @param {String} [options.message=''] The error message
     */
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === void 0 ? null : options.error;
      this[kMessage] = options.message === void 0 ? "" : options.message;
    }
    /**
     * @type {*}
     */
    get error() {
      return this[kError];
    }
    /**
     * @type {String}
     */
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
  class MessageEvent extends Event {
    /**
     * Create a new `MessageEvent`.
     *
     * @param {String} type The name of the event
     * @param {Object} [options] A dictionary object that allows for setting
     *     attributes via object members of the same name
     * @param {*} [options.data=null] The message content
     */
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === void 0 ? null : options.data;
    }
    /**
     * @type {*}
     */
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  const EventTarget = {
    /**
     * Register an event listener.
     *
     * @param {String} type A string representing the event type to listen for
     * @param {(Function|Object)} handler The listener to add
     * @param {Object} [options] An options object specifies characteristics about
     *     the event listener
     * @param {Boolean} [options.once=false] A `Boolean` indicating that the
     *     listener should be invoked at most once after being added. If `true`,
     *     the listener would be automatically removed when invoked.
     * @public
     */
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage2(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    /**
     * Remove an event listener.
     *
     * @param {String} type A string representing the event type to remove
     * @param {(Function|Object)} handler The listener to remove
     * @public
     */
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  eventTarget = {
    CloseEvent,
    ErrorEvent,
    Event,
    EventTarget,
    MessageEvent
  };
  function callListener(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  }
  return eventTarget;
}
var extension;
var hasRequiredExtension;
function requireExtension() {
  if (hasRequiredExtension) return extension;
  hasRequiredExtension = 1;
  const { tokenChars } = requireValidation();
  function push(dest, name, elem) {
    if (dest[name] === void 0) dest[name] = [elem];
    else dest[name].push(elem);
  }
  function parse2(header) {
    const offers = /* @__PURE__ */ Object.create(null);
    let params = /* @__PURE__ */ Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start2 = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (; i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === void 0) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start2 === -1) start2 = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start2 !== -1) end = i;
        } else if (code === 59 || code === 44) {
          if (start2 === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const name = header.slice(start2, end);
          if (code === 44) {
            push(offers, name, params);
            params = /* @__PURE__ */ Object.create(null);
          } else {
            extensionName = name;
          }
          start2 = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === void 0) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start2 === -1) start2 = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start2 !== -1) end = i;
        } else if (code === 59 || code === 44) {
          if (start2 === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          push(params, header.slice(start2, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = /* @__PURE__ */ Object.create(null);
            extensionName = void 0;
          }
          start2 = end = -1;
        } else if (code === 61 && start2 !== -1 && end === -1) {
          paramName = header.slice(start2, i);
          start2 = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start2 === -1) start2 = i;
          else if (!mustUnescape) mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start2 === -1) start2 = i;
          } else if (code === 34 && start2 !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start2 === -1) start2 = i;
        } else if (start2 !== -1 && (code === 32 || code === 9)) {
          if (end === -1) end = i;
        } else if (code === 59 || code === 44) {
          if (start2 === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          let value = header.slice(start2, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = /* @__PURE__ */ Object.create(null);
            extensionName = void 0;
          }
          paramName = void 0;
          start2 = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start2 === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1) end = i;
    const token = header.slice(start2, end);
    if (extensionName === void 0) {
      push(offers, token, params);
    } else {
      if (paramName === void 0) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  }
  function format2(extensions) {
    return Object.keys(extensions).map((extension2) => {
      let configurations = extensions[extension2];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations.map((params) => {
        return [extension2].concat(
          Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values)) values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })
        ).join("; ");
      }).join(", ");
    }).join(", ");
  }
  extension = { format: format2, parse: parse2 };
  return extension;
}
var websocket;
var hasRequiredWebsocket;
function requireWebsocket() {
  if (hasRequiredWebsocket) return websocket;
  hasRequiredWebsocket = 1;
  const EventEmitter3 = import_events2.default;
  const https = import_https.default;
  const http = import_http.default;
  const net = import_net.default;
  const tls = import_tls.default;
  const { randomBytes, createHash: createHash2 } = import_crypto.default;
  const { Duplex, Readable } = import_stream.default;
  const { URL: URL2 } = import_url.default;
  const PerMessageDeflate = requirePermessageDeflate();
  const Receiver = requireReceiver();
  const Sender = requireSender();
  const { isBlob } = requireValidation();
  const {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = requireConstants();
  const {
    EventTarget: { addEventListener, removeEventListener }
  } = requireEventTarget();
  const { format: format2, parse: parse2 } = requireExtension();
  const { toBuffer } = requireBufferUtil();
  const closeTimeout = 30 * 1e3;
  const kAborted = Symbol("kAborted");
  const protocolVersions = [8, 13];
  const readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
  class WebSocket extends EventEmitter3 {
    /**
     * Create a new `WebSocket`.
     *
     * @param {(String|URL)} address The URL to which to connect
     * @param {(String|String[])} [protocols] The subprotocols
     * @param {Object} [options] Connection options
     */
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._errorEmitted = false;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === void 0) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._autoPong = options.autoPong;
        this._isServer = true;
      }
    }
    /**
     * For historical reasons, the custom "nodebuffer" type is used by the default
     * instead of "blob".
     *
     * @type {String}
     */
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type)) return;
      this._binaryType = type;
      if (this._receiver) this._receiver._binaryType = type;
    }
    /**
     * @type {Number}
     */
    get bufferedAmount() {
      if (!this._socket) return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    /**
     * @type {String}
     */
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    /**
     * @type {Boolean}
     */
    get isPaused() {
      return this._paused;
    }
    /**
     * @type {Function}
     */
    /* istanbul ignore next */
    get onclose() {
      return null;
    }
    /**
     * @type {Function}
     */
    /* istanbul ignore next */
    get onerror() {
      return null;
    }
    /**
     * @type {Function}
     */
    /* istanbul ignore next */
    get onopen() {
      return null;
    }
    /**
     * @type {Function}
     */
    /* istanbul ignore next */
    get onmessage() {
      return null;
    }
    /**
     * @type {String}
     */
    get protocol() {
      return this._protocol;
    }
    /**
     * @type {Number}
     */
    get readyState() {
      return this._readyState;
    }
    /**
     * @type {String}
     */
    get url() {
      return this._url;
    }
    /**
     * Set up the socket and the internal resources.
     *
     * @param {Duplex} socket The network socket between the server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Object} options Options object
     * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
     *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
     *     multiple times in the same tick
     * @param {Function} [options.generateMask] The function used to generate the
     *     masking key
     * @param {Number} [options.maxPayload=0] The maximum allowed message size
     * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
     *     not to skip UTF-8 validation for text and close messages
     * @private
     */
    setSocket(socket, head, options) {
      const receiver2 = new Receiver({
        allowSynchronousEvents: options.allowSynchronousEvents,
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      const sender2 = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver2;
      this._sender = sender2;
      this._socket = socket;
      receiver2[kWebSocket] = this;
      sender2[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver2.on("conclude", receiverOnConclude);
      receiver2.on("drain", receiverOnDrain);
      receiver2.on("error", receiverOnError);
      receiver2.on("message", receiverOnMessage);
      receiver2.on("ping", receiverOnPing);
      receiver2.on("pong", receiverOnPong);
      sender2.onerror = senderOnError;
      if (socket.setTimeout) socket.setTimeout(0);
      if (socket.setNoDelay) socket.setNoDelay();
      if (head.length > 0) socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    /**
     * Emit the `'close'` event.
     *
     * @private
     */
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    /**
     * Start a closing handshake.
     *
     *          +----------+   +-----------+   +----------+
     *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
     *    |     +----------+   +-----------+   +----------+     |
     *          +----------+   +-----------+         |
     * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
     *          +----------+   +-----------+   |
     *    |           |                        |   +---+        |
     *                +------------------------+-->|fin| - - - -
     *    |         +---+                      |   +---+
     *     - - - - -|fin|<---------------------+
     *              +---+
     *
     * @param {Number} [code] Status code explaining why the connection is closing
     * @param {(String|Buffer)} [data] The reason why the connection is
     *     closing
     * @public
     */
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED) return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err) return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      setCloseTimer(this);
    }
    /**
     * Pause the socket.
     *
     * @public
     */
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    /**
     * Send a ping.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the ping is sent
     * @public
     */
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = void 0;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = void 0;
      }
      if (typeof data === "number") data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === void 0) mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    /**
     * Send a pong.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the pong is sent
     * @public
     */
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = void 0;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = void 0;
      }
      if (typeof data === "number") data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === void 0) mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    /**
     * Resume the socket.
     *
     * @public
     */
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain) this._socket.resume();
    }
    /**
     * Send a data message.
     *
     * @param {*} data The message to send
     * @param {Object} [options] Options object
     * @param {Boolean} [options.binary] Specifies whether `data` is binary or
     *     text
     * @param {Boolean} [options.compress] Specifies whether or not to compress
     *     `data`
     * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when data is written out
     * @public
     */
    send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number") data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    /**
     * Forcibly close the connection.
     *
     * @public
     */
    terminate() {
      if (this.readyState === WebSocket.CLOSED) return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function") return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  websocket = WebSocket;
  function initAsClient(websocket2, address, protocols, options) {
    const opts = {
      allowSynchronousEvents: true,
      autoPong: true,
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      socketPath: void 0,
      hostname: void 0,
      protocol: void 0,
      timeout: void 0,
      method: "GET",
      host: void 0,
      path: void 0,
      port: void 0
    };
    websocket2._autoPong = opts.autoPong;
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(
        `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
      );
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket2._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket2._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket2, err);
        return;
      }
    }
    const defaultPort2 = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = /* @__PURE__ */ new Set();
    let perMessageDeflate;
    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
    opts.defaultPort = opts.defaultPort || defaultPort2;
    opts.port = parsedUrl.port || defaultPort2;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(
        opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
        false,
        opts.maxPayload
      );
      opts.headers["Sec-WebSocket-Extensions"] = format2({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError(
            "An invalid or duplicated subprotocol was specified"
          );
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket2._redirects === 0) {
        websocket2._originalIpc = isIpcUrl;
        websocket2._originalSecure = isSecure;
        websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket2.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;
        if (!isSameHost || websocket2._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost) delete opts.headers.host;
          opts.auth = void 0;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket2._req = request(opts);
      if (websocket2._redirects) {
        websocket2.emit("redirect", websocket2.url, req);
      }
    } else {
      req = websocket2._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket2, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted]) return;
      req = websocket2._req = null;
      emitErrorAndClose(websocket2, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket2._redirects > opts.maxRedirects) {
          abortHandshake(websocket2, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket2, err);
          return;
        }
        initAsClient(websocket2, addr, protocols, options);
      } else if (!websocket2.emit("unexpected-response", req, res)) {
        abortHandshake(
          websocket2,
          req,
          `Unexpected server response: ${res.statusCode}`
        );
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket2.emit("upgrade", res);
      if (websocket2.readyState !== WebSocket.CONNECTING) return;
      req = websocket2._req = null;
      const upgrade = res.headers.upgrade;
      if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket2, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash2("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== void 0) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket2, socket, protError);
        return;
      }
      if (serverProt) websocket2._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== void 0) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
          abortHandshake(websocket2, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse2(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket2, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket2, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket2, socket, message);
          return;
        }
        websocket2._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket2.setSocket(socket, head, {
        allowSynchronousEvents: opts.allowSynchronousEvents,
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket2);
    } else {
      req.end();
    }
  }
  function emitErrorAndClose(websocket2, err) {
    websocket2._readyState = WebSocket.CLOSING;
    websocket2._errorEmitted = true;
    websocket2.emit("error", err);
    websocket2.emitClose();
  }
  function netConnect(options) {
    options.path = options.socketPath;
    return net.connect(options);
  }
  function tlsConnect(options) {
    options.path = void 0;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  }
  function abortHandshake(websocket2, stream2, message) {
    websocket2._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream2.setHeader) {
      stream2[kAborted] = true;
      stream2.abort();
      if (stream2.socket && !stream2.socket.destroyed) {
        stream2.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket2, err);
    } else {
      stream2.destroy(err);
      stream2.once("error", websocket2.emit.bind(websocket2, "error"));
      stream2.once("close", websocket2.emitClose.bind(websocket2));
    }
  }
  function sendAfterClose(websocket2, data, cb) {
    if (data) {
      const length = isBlob(data) ? data.size : toBuffer(data).length;
      if (websocket2._socket) websocket2._sender._bufferedBytes += length;
      else websocket2._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(
        `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`
      );
      process.nextTick(cb, err);
    }
  }
  function receiverOnConclude(code, reason) {
    const websocket2 = this[kWebSocket];
    websocket2._closeFrameReceived = true;
    websocket2._closeMessage = reason;
    websocket2._closeCode = code;
    if (websocket2._socket[kWebSocket] === void 0) return;
    websocket2._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket2._socket);
    if (code === 1005) websocket2.close();
    else websocket2.close(code, reason);
  }
  function receiverOnDrain() {
    const websocket2 = this[kWebSocket];
    if (!websocket2.isPaused) websocket2._socket.resume();
  }
  function receiverOnError(err) {
    const websocket2 = this[kWebSocket];
    if (websocket2._socket[kWebSocket] !== void 0) {
      websocket2._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket2._socket);
      websocket2.close(err[kStatusCode]);
    }
    if (!websocket2._errorEmitted) {
      websocket2._errorEmitted = true;
      websocket2.emit("error", err);
    }
  }
  function receiverOnFinish() {
    this[kWebSocket].emitClose();
  }
  function receiverOnMessage(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  }
  function receiverOnPing(data) {
    const websocket2 = this[kWebSocket];
    if (websocket2._autoPong) websocket2.pong(data, !this._isServer, NOOP);
    websocket2.emit("ping", data);
  }
  function receiverOnPong(data) {
    this[kWebSocket].emit("pong", data);
  }
  function resume(stream2) {
    stream2.resume();
  }
  function senderOnError(err) {
    const websocket2 = this[kWebSocket];
    if (websocket2.readyState === WebSocket.CLOSED) return;
    if (websocket2.readyState === WebSocket.OPEN) {
      websocket2._readyState = WebSocket.CLOSING;
      setCloseTimer(websocket2);
    }
    this._socket.end();
    if (!websocket2._errorEmitted) {
      websocket2._errorEmitted = true;
      websocket2.emit("error", err);
    }
  }
  function setCloseTimer(websocket2) {
    websocket2._closeTimer = setTimeout(
      websocket2._socket.destroy.bind(websocket2._socket),
      closeTimeout
    );
  }
  function socketOnClose() {
    const websocket2 = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket2._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
      websocket2._receiver.write(chunk);
    }
    websocket2._receiver.end();
    this[kWebSocket] = void 0;
    clearTimeout(websocket2._closeTimer);
    if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
      websocket2.emitClose();
    } else {
      websocket2._receiver.on("error", receiverOnFinish);
      websocket2._receiver.on("finish", receiverOnFinish);
    }
  }
  function socketOnData(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  }
  function socketOnEnd() {
    const websocket2 = this[kWebSocket];
    websocket2._readyState = WebSocket.CLOSING;
    websocket2._receiver.end();
    this.end();
  }
  function socketOnError() {
    const websocket2 = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket2) {
      websocket2._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
  return websocket;
}
var stream;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream;
  hasRequiredStream = 1;
  requireWebsocket();
  const { Duplex } = import_stream.default;
  function emitClose(stream2) {
    stream2.emit("close");
  }
  function duplexOnEnd() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  }
  function duplexOnError(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  }
  function createWebSocketStream(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data)) ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed) return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed) return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called) callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy) ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null) return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted) duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused) ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  }
  stream = createWebSocketStream;
  return stream;
}
requireStream();
requireReceiver();
requireSender();
requireWebsocket();
var subprotocol;
var hasRequiredSubprotocol;
function requireSubprotocol() {
  if (hasRequiredSubprotocol) return subprotocol;
  hasRequiredSubprotocol = 1;
  const { tokenChars } = requireValidation();
  function parse2(header) {
    const protocols = /* @__PURE__ */ new Set();
    let start2 = -1;
    let end = -1;
    let i = 0;
    for (i; i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start2 === -1) start2 = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start2 !== -1) end = i;
      } else if (code === 44) {
        if (start2 === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1) end = i;
        const protocol2 = header.slice(start2, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start2 = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start2 === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start2, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  }
  subprotocol = { parse: parse2 };
  return subprotocol;
}
var websocketServer;
var hasRequiredWebsocketServer;
function requireWebsocketServer() {
  if (hasRequiredWebsocketServer) return websocketServer;
  hasRequiredWebsocketServer = 1;
  const EventEmitter3 = import_events2.default;
  const http = import_http.default;
  const { Duplex } = import_stream.default;
  const { createHash: createHash2 } = import_crypto.default;
  const extension2 = requireExtension();
  const PerMessageDeflate = requirePermessageDeflate();
  const subprotocol2 = requireSubprotocol();
  const WebSocket = requireWebsocket();
  const { GUID, kWebSocket } = requireConstants();
  const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  const RUNNING = 0;
  const CLOSING = 1;
  const CLOSED = 2;
  class WebSocketServer2 extends EventEmitter3 {
    /**
     * Create a `WebSocketServer` instance.
     *
     * @param {Object} options Configuration options
     * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
     *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
     *     multiple times in the same tick
     * @param {Boolean} [options.autoPong=true] Specifies whether or not to
     *     automatically send a pong in response to a ping
     * @param {Number} [options.backlog=511] The maximum length of the queue of
     *     pending connections
     * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
     *     track clients
     * @param {Function} [options.handleProtocols] A hook to handle protocols
     * @param {String} [options.host] The hostname where to bind the server
     * @param {Number} [options.maxPayload=104857600] The maximum allowed message
     *     size
     * @param {Boolean} [options.noServer=false] Enable no server mode
     * @param {String} [options.path] Accept only connections matching this path
     * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
     *     permessage-deflate
     * @param {Number} [options.port] The port where to bind the server
     * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
     *     server to use
     * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
     *     not to skip UTF-8 validation for text and close messages
     * @param {Function} [options.verifyClient] A hook to reject connections
     * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
     *     class to use. It must be the `WebSocket` class or class that extends it
     * @param {Function} [callback] A listener for the `listening` event
     */
    constructor(options, callback) {
      super();
      options = {
        allowSynchronousEvents: true,
        autoPong: true,
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        // use default (511 as implemented in net.js)
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError(
          'One and only one of the "port", "server", or "noServer" options must be specified'
        );
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(
          options.port,
          options.host,
          options.backlog,
          callback
        );
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true) options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = /* @__PURE__ */ new Set();
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    /**
     * Returns the bound address, the address family name, and port of the server
     * as reported by the operating system if listening on an IP socket.
     * If the server is listening on a pipe or UNIX domain socket, the name is
     * returned as a string.
     *
     * @return {(Object|String|null)} The address of the server
     * @public
     */
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server) return null;
      return this._server.address();
    }
    /**
     * Stop the server from accepting new connections and emit the `'close'` event
     * when all existing connections are closed.
     *
     * @param {Function} [cb] A one-time listener for the `'close'` event
     * @public
     */
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb) this.once("close", cb);
      if (this._state === CLOSING) return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    /**
     * See if a given request should be handled by this server instance.
     *
     * @param {http.IncomingMessage} req Request object to inspect
     * @return {Boolean} `true` if the request is valid, else `false`
     * @public
     */
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path) return false;
      }
      return true;
    }
    /**
     * Handle a HTTP Upgrade request.
     *
     * @param {http.IncomingMessage} req The request object
     * @param {Duplex} socket The network socket between the server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @public
     */
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const upgrade = req.headers.upgrade;
      const version2 = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (key === void 0 || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version2 !== 13 && version2 !== 8) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
          "Sec-WebSocket-Version": "13, 8"
        });
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = /* @__PURE__ */ new Set();
      if (secWebSocketProtocol !== void 0) {
        try {
          protocols = subprotocol2.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
        const perMessageDeflate = new PerMessageDeflate(
          this.options.perMessageDeflate,
          true,
          this.options.maxPayload
        );
        try {
          const offers = extension2.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(
              extensions,
              key,
              protocols,
              req,
              socket,
              head,
              cb
            );
          });
          return;
        }
        if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    /**
     * Upgrade the connection to WebSocket.
     *
     * @param {Object} extensions The accepted extensions
     * @param {String} key The value of the `Sec-WebSocket-Key` header
     * @param {Set} protocols The subprotocols
     * @param {http.IncomingMessage} req The request object
     * @param {Duplex} socket The network socket between the server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @throws {Error} If called more than once with the same socket
     * @private
     */
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable) return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error(
          "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
        );
      }
      if (this._state > RUNNING) return abortHandshake(socket, 503);
      const digest = createHash2("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null, void 0, this.options);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension2.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        allowSynchronousEvents: this.options.allowSynchronousEvents,
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  websocketServer = WebSocketServer2;
  function addListeners(server, map) {
    for (const event of Object.keys(map)) server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  }
  function emitClose(server) {
    server._state = CLOSED;
    server.emit("close");
  }
  function socketOnError() {
    this.destroy();
  }
  function abortHandshake(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(
      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
    );
  }
  function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message, headers);
    }
  }
  return websocketServer;
}
var websocketServerExports = requireWebsocketServer();
var WebSocketServer = getDefaultExportFromCjs(websocketServerExports);
async function getModuleGraph(ctx, projectName, id, browser = false) {
  const graph = {}, externalized = /* @__PURE__ */ new Set(), inlined = /* @__PURE__ */ new Set(), project = ctx.getProjectByName(projectName);
  async function get(mod, seen = /* @__PURE__ */ new Map()) {
    var _a2;
    if (!mod || !mod.id || mod.id === "\0vitest/browser") return;
    if (seen.has(mod)) return seen.get(mod);
    let id2 = clearId(mod.id);
    seen.set(mod, id2);
    const rewrote = browser ? ((_a2 = mod.file) == null ? void 0 : _a2.includes(project.browser.vite.config.cacheDir)) ? mod.id : false : false;
    if (rewrote) id2 = rewrote, externalized.add(id2), seen.set(mod, id2);
    else inlined.add(id2);
    const mods = Array.from(mod.importedModules).filter((i) => i.id && !i.id.includes("/vitest/dist/"));
    return graph[id2] = (await Promise.all(mods.map((m) => get(m, seen)))).filter(Boolean), id2;
  }
  if (browser && project.browser) await get(project.browser.vite.moduleGraph.getModuleById(id));
  else await get(project.vite.moduleGraph.getModuleById(id));
  return {
    graph,
    externalized: Array.from(externalized),
    inlined: Array.from(inlined)
  };
}
function clearId(id) {
  return (id == null ? void 0 : id.replace(/\?v=\w+$/, "")) || "";
}
function cloneByOwnProperties(value) {
  return Object.getOwnPropertyNames(value).reduce((clone, prop) => {
    return clone[prop] = value[prop], clone;
  }, {});
}
function stringifyReplace(key, value) {
  if (value instanceof Error) {
    const cloned = cloneByOwnProperties(value);
    return {
      name: value.name,
      message: value.message,
      stack: value.stack,
      ...cloned
    };
  } else return value;
}
function isValidApiRequest(config, req) {
  const url2 = new URL(req.url ?? "", "http://localhost");
  try {
    const token = url2.searchParams.get("token");
    if (token && import_node_crypto2.default.timingSafeEqual(Buffer.from(token), Buffer.from(config.api.token))) return true;
  } catch {
  }
  return false;
}
function setup(ctx, _server) {
  var _a2;
  const wss = new WebSocketServer({ noServer: true }), clients = /* @__PURE__ */ new Map();
  (_a2 = (_server || ctx.vite).httpServer) == null ? void 0 : _a2.on("upgrade", (request, socket, head) => {
    if (!request.url) return;
    const { pathname } = new URL(request.url, "http://localhost");
    if (pathname === API_PATH) {
      if (!isValidApiRequest(ctx.config, request)) {
        socket.destroy();
        return;
      }
      wss.handleUpgrade(request, socket, head, (ws) => {
        wss.emit("connection", ws, request), setupClient(ws);
      });
    }
  });
  function setupClient(ws) {
    const rpc = createBirpc({
      async onTaskUpdate(packs, events) {
        await ctx._testRun.updated(packs, events);
      },
      getFiles() {
        return ctx.state.getFiles();
      },
      getPaths() {
        return ctx.state.getPaths();
      },
      async readTestFile(id) {
        return !ctx.state.filesMap.has(id) || !(0, import_node_fs6.existsSync)(id) ? null : import_node_fs6.promises.readFile(id, "utf-8");
      },
      async saveTestFile(id, content) {
        if (!ctx.state.filesMap.has(id) || !(0, import_node_fs6.existsSync)(id)) throw new Error(`Test file "${id}" was not registered, so it cannot be updated using the API.`);
        return import_node_fs6.promises.writeFile(id, content, "utf-8");
      },
      async rerun(files, resetTestNamePattern) {
        await ctx.rerunFiles(files, void 0, true, resetTestNamePattern);
      },
      async rerunTask(id) {
        await ctx.rerunTask(id);
      },
      getConfig() {
        return ctx.getRootProject().serializedConfig;
      },
      getResolvedProjectLabels() {
        return ctx.projects.map((p2) => ({
          name: p2.name,
          color: p2.color
        }));
      },
      async getTransformResult(projectName, id, browser = false) {
        const project = ctx.getProjectByName(projectName), result = browser ? await project.browser.vite.transformRequest(id) : await project.vite.transformRequest(id);
        if (result) {
          try {
            result.source = result.source || await import_node_fs6.promises.readFile(id, "utf-8");
          } catch {
          }
          return result;
        }
      },
      async getModuleGraph(project, id, browser) {
        return getModuleGraph(ctx, project, id, browser);
      },
      async updateSnapshot(file) {
        if (!file) await ctx.updateSnapshot();
        else await ctx.updateSnapshot([file.filepath]);
      },
      getUnhandledErrors() {
        return ctx.state.getUnhandledErrors();
      },
      async getTestFiles() {
        return (await ctx.globTestSpecifications()).map((spec) => [
          {
            name: spec.project.config.name,
            root: spec.project.config.root
          },
          spec.moduleId,
          { pool: spec.pool }
        ]);
      }
    }, {
      post: (msg) => ws.send(msg),
      on: (fn) => ws.on("message", fn),
      eventNames: [
        "onUserConsoleLog",
        "onFinished",
        "onFinishedReportCoverage",
        "onCollected",
        "onTaskUpdate"
      ],
      serialize: (data) => stringify(data, stringifyReplace),
      deserialize: parse$1,
      timeout: -1
    });
    clients.set(ws, rpc), ws.on("close", () => {
      clients.delete(ws), rpc.$close(new Error("[vitest-api]: Pending methods while closing rpc"));
    });
  }
  ctx.reporters.push(new WebSocketReporter(ctx, wss, clients));
}
var WebSocketReporter = class {
  constructor(ctx, wss, clients) {
    this.ctx = ctx, this.wss = wss, this.clients = clients;
  }
  onTestModuleCollected(testModule) {
    this.clients.size !== 0 && this.clients.forEach((client) => {
      var _a2, _b2, _c;
      (_c = (_b2 = (_a2 = client.onCollected) == null ? void 0 : _a2.call(client, [testModule.task])) == null ? void 0 : _b2.catch) == null ? void 0 : _c.call(_b2, noop);
    });
  }
  onTestRunStart(specifications) {
    if (this.clients.size === 0) return;
    const serializedSpecs = specifications.map((spec) => spec.toJSON());
    this.clients.forEach((client) => {
      var _a2, _b2, _c;
      (_c = (_b2 = (_a2 = client.onSpecsCollected) == null ? void 0 : _a2.call(client, serializedSpecs)) == null ? void 0 : _b2.catch) == null ? void 0 : _c.call(_b2, noop);
    });
  }
  async onTestCaseAnnotate(testCase, annotation) {
    this.clients.size !== 0 && this.clients.forEach((client) => {
      var _a2, _b2, _c;
      (_c = (_b2 = (_a2 = client.onTestAnnotate) == null ? void 0 : _a2.call(client, testCase.id, annotation)) == null ? void 0 : _b2.catch) == null ? void 0 : _c.call(_b2, noop);
    });
  }
  async onTaskUpdate(packs, events) {
    this.clients.size !== 0 && this.clients.forEach((client) => {
      var _a2, _b2, _c;
      (_c = (_b2 = (_a2 = client.onTaskUpdate) == null ? void 0 : _a2.call(client, packs, events)) == null ? void 0 : _b2.catch) == null ? void 0 : _c.call(_b2, noop);
    });
  }
  onTestRunEnd(testModules, unhandledErrors) {
    if (!this.clients.size) return;
    const files = testModules.map((testModule) => testModule.task), errors = [...unhandledErrors];
    this.clients.forEach((client) => {
      var _a2, _b2, _c;
      (_c = (_b2 = (_a2 = client.onFinished) == null ? void 0 : _a2.call(client, files, errors)) == null ? void 0 : _b2.catch) == null ? void 0 : _c.call(_b2, noop);
    });
  }
  onFinishedReportCoverage() {
    this.clients.forEach((client) => {
      var _a2, _b2, _c;
      (_c = (_b2 = (_a2 = client.onFinishedReportCoverage) == null ? void 0 : _a2.call(client)) == null ? void 0 : _b2.catch) == null ? void 0 : _c.call(_b2, noop);
    });
  }
  onUserConsoleLog(log) {
    this.clients.forEach((client) => {
      var _a2, _b2, _c;
      (_c = (_b2 = (_a2 = client.onUserConsoleLog) == null ? void 0 : _a2.call(client, log)) == null ? void 0 : _b2.catch) == null ? void 0 : _c.call(_b2, noop);
    });
  }
};
var setup$1 = Object.freeze({
  __proto__: null,
  WebSocketReporter,
  setup
});
function groupBy(collection, iteratee) {
  return collection.reduce((acc, item) => {
    const key = iteratee(item);
    return acc[key] || (acc[key] = []), acc[key].push(item), acc;
  }, {});
}
function stdout() {
  return console._stdout || process.stdout;
}
function escapeRegExp(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function wildcardPatternToRegExp(pattern) {
  const negated = pattern[0] === "!";
  if (negated) pattern = pattern.slice(1);
  let regexp = `${pattern.split("*").map(escapeRegExp).join(".*")}$`;
  if (negated) regexp = `(?!${regexp})`;
  return new RegExp(`^${regexp}`, "i");
}
function createDebugger(namespace) {
  const debug2 = (0, import_debug.default)(namespace);
  if (debug2.enabled) return debug2;
}
var debug$1 = createDebugger("vitest:ast-collect-info");
var verbose = createDebugger("vitest:ast-collect-verbose");
function astParseFile(filepath, code) {
  const ast = parseAst(code);
  if (verbose) verbose("Collecting", filepath, code);
  else debug$1 == null ? void 0 : debug$1("Collecting", filepath);
  const definitions = [], getName = (callee) => {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j;
    if (!callee) return null;
    if (callee.type === "Identifier") return callee.name;
    if (callee.type === "CallExpression") return getName(callee.callee);
    if (callee.type === "TaggedTemplateExpression") return getName(callee.tag);
    if (callee.type === "MemberExpression")
      return ((_a2 = callee.object) == null ? void 0 : _a2.type) === "Identifier" && [
        "it",
        "test",
        "describe",
        "suite"
      ].includes(callee.object.name) ? (_b2 = callee.object) == null ? void 0 : _b2.name : ((_d = (_c = callee.object) == null ? void 0 : _c.name) == null ? void 0 : _d.startsWith("__vite_ssr_")) || ((_g = (_f = (_e = callee.object) == null ? void 0 : _e.object) == null ? void 0 : _f.name) == null ? void 0 : _g.startsWith("__vite_ssr_")) && ((_i = (_h = callee.object) == null ? void 0 : _h.property) == null ? void 0 : _i.name) === "Vitest" ? getName(callee.property) : getName((_j = callee.object) == null ? void 0 : _j.property);
    if (callee.type === "SequenceExpression" && callee.expressions.length === 2) {
      const [e0, e1] = callee.expressions;
      if (e0.type === "Literal" && e0.value === 0) return getName(e1);
    }
    return null;
  };
  return ancestor(ast, { CallExpression(node) {
    var _a2, _b2, _c, _d, _e;
    const { callee } = node, name = getName(callee);
    if (!name) return;
    if (![
      "it",
      "test",
      "describe",
      "suite"
    ].includes(name)) {
      verbose == null ? void 0 : verbose(`Skipping ${name} (unknown call)`);
      return;
    }
    const property = (_a2 = callee == null ? void 0 : callee.property) == null ? void 0 : _a2.name;
    let mode = !property || property === name ? "run" : property;
    if ([
      "each",
      "for",
      "skipIf",
      "runIf"
    ].includes(mode)) return;
    let start2;
    const end = node.end;
    if (callee.type === "CallExpression" || callee.type === "SequenceExpression" || callee.type === "TaggedTemplateExpression") start2 = callee.end;
    else start2 = node.start;
    const messageNode = (_b2 = node.arguments) == null ? void 0 : _b2[0];
    if (messageNode == null) {
      verbose == null ? void 0 : verbose(`Skipping node at ${node.start} because it doesn't have a name`);
      return;
    }
    let message;
    if ((messageNode == null ? void 0 : messageNode.type) === "Literal" || (messageNode == null ? void 0 : messageNode.type) === "TemplateLiteral") message = code.slice(messageNode.start + 1, messageNode.end - 1);
    else message = code.slice(messageNode.start, messageNode.end);
    if (message.startsWith("0,")) message = message.slice(2);
    if (message = message.replace(/__vite_ssr_import_\d+__\./g, "").replace(/__vi_import_\d+__\./g, ""), mode === "skipIf" || mode === "runIf") mode = "skip";
    const parentCalleeName = typeof (callee == null ? void 0 : callee.callee) === "object" && (callee == null ? void 0 : callee.callee.type) === "MemberExpression" && ((_c = callee == null ? void 0 : callee.callee.property) == null ? void 0 : _c.name);
    let isDynamicEach = parentCalleeName === "each" || parentCalleeName === "for";
    if (!isDynamicEach && callee.type === "TaggedTemplateExpression") {
      const property2 = (_e = (_d = callee.tag) == null ? void 0 : _d.property) == null ? void 0 : _e.name;
      isDynamicEach = property2 === "each" || property2 === "for";
    }
    debug$1 == null ? void 0 : debug$1("Found", name, message, `(${mode})`), definitions.push({
      start: start2,
      end,
      name: message,
      type: name === "it" || name === "test" ? "test" : "suite",
      mode,
      task: null,
      dynamic: isDynamicEach
    });
  } }), {
    ast,
    definitions
  };
}
function createFailedFileTask(project, filepath, error) {
  const testFilepath = relative(project.config.root, filepath), file = {
    filepath,
    type: "suite",
    id: generateHash(`${testFilepath}${project.config.name || ""}`),
    name: testFilepath,
    mode: "run",
    tasks: [],
    start: 0,
    end: 0,
    projectName: project.name,
    meta: {},
    pool: project.browser ? "browser" : project.config.pool,
    file: null,
    result: {
      state: "fail",
      errors: serializeError(project, error)
    }
  };
  return file.file = file, file;
}
function serializeError(ctx, error) {
  return "errors" in error && "pluginCode" in error ? error.errors.map((e) => {
    return {
      name: error.name,
      message: e.text,
      stack: e.location ? `${error.name}: ${e.text}
  at ${relative(ctx.config.root, e.location.file)}:${e.location.line}:${e.location.column}` : ""
    };
  }) : [{
    name: error.name,
    stack: error.stack,
    message: error.message
  }];
}
function createFileTask2(testFilepath, code, requestMap, options) {
  const { definitions, ast } = astParseFile(testFilepath, code), file = {
    filepath: options.filepath,
    type: "suite",
    id: generateHash(`${testFilepath}${options.name || ""}`),
    name: testFilepath,
    mode: "run",
    tasks: [],
    start: ast.start,
    end: ast.end,
    projectName: options.name,
    meta: {},
    pool: "browser",
    file: null
  };
  file.file = file;
  const indexMap = createIndexMap(code), map = requestMap && new TraceMap(requestMap);
  let lastSuite = file;
  const updateLatestSuite = (index) => {
    while (lastSuite.suite && lastSuite.end < index) lastSuite = lastSuite.suite;
    return lastSuite;
  };
  definitions.sort((a, b) => a.start - b.start).forEach((definition) => {
    const latestSuite = updateLatestSuite(definition.start);
    let mode = definition.mode;
    if (latestSuite.mode !== "run")
      mode = latestSuite.mode;
    const processedLocation = indexMap.get(definition.start);
    let location;
    if (map && processedLocation) {
      const originalLocation = originalPositionFor(map, {
        line: processedLocation.line,
        column: processedLocation.column
      });
      if (originalLocation.column != null) verbose == null ? void 0 : verbose(`Found location for`, definition.type, definition.name, `${processedLocation.line}:${processedLocation.column}`, "->", `${originalLocation.line}:${originalLocation.column}`), location = originalLocation;
      else debug$1 == null ? void 0 : debug$1("Cannot find original location for", definition.type, definition.name, `${processedLocation.column}:${processedLocation.line}`);
    } else debug$1 == null ? void 0 : debug$1("Cannot find original location for", definition.type, definition.name, `${definition.start}`);
    if (definition.type === "suite") {
      const task2 = {
        type: definition.type,
        id: "",
        suite: latestSuite,
        file,
        tasks: [],
        mode,
        name: definition.name,
        end: definition.end,
        start: definition.start,
        location,
        dynamic: definition.dynamic,
        meta: {}
      };
      definition.task = task2, latestSuite.tasks.push(task2), lastSuite = task2;
      return;
    }
    const task = {
      type: definition.type,
      id: "",
      suite: latestSuite,
      file,
      mode,
      context: {},
      name: definition.name,
      end: definition.end,
      start: definition.start,
      location,
      dynamic: definition.dynamic,
      meta: {},
      timeout: 0,
      annotations: []
    };
    definition.task = task, latestSuite.tasks.push(task);
  }), calculateSuiteHash(file);
  const hasOnly = someTasksAreOnly(file);
  if (interpretTaskModes(file, options.testNamePattern, void 0, hasOnly, false, options.allowOnly), markDynamicTests(file.tasks), !file.tasks.length) file.result = {
    state: "fail",
    errors: [{
      name: "Error",
      message: `No test suite found in file ${options.filepath}`
    }]
  };
  return file;
}
async function astCollectTests(project, filepath) {
  const request = await transformSSR(project, filepath), testFilepath = relative(project.config.root, filepath);
  return request ? createFileTask2(testFilepath, request.code, request.map, {
    name: project.config.name,
    filepath,
    allowOnly: project.config.allowOnly,
    testNamePattern: project.config.testNamePattern,
    pool: project.browser ? "browser" : project.config.pool
  }) : (debug$1 == null ? void 0 : debug$1("Cannot parse", testFilepath, "(vite didn't return anything)"), createFailedFileTask(project, filepath, new Error(`Failed to parse ${testFilepath}. Vite didn't return anything.`)));
}
async function transformSSR(project, filepath) {
  const request = await project.vite.transformRequest(filepath, { ssr: false });
  return request ? await project.vite.ssrTransform(request.code, request.map, filepath) : null;
}
function createIndexMap(source) {
  const map = /* @__PURE__ */ new Map();
  let index = 0, line = 1, column = 1;
  for (const char of source) if (map.set(index++, {
    line,
    column
  }), char === "\n" || char === "\r\n") line++, column = 0;
  else column++;
  return map;
}
function markDynamicTests(tasks) {
  for (const task of tasks) {
    if (task.dynamic) task.id += "-dynamic";
    if ("tasks" in task) markDynamicTests(task.tasks);
  }
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var kReplacers = /* @__PURE__ */ new Map([
  ["%i", "\\d+?"],
  ["%#", "\\d+?"],
  ["%d", "[\\d.eE+-]+?"],
  ["%f", "[\\d.eE+-]+?"],
  ["%s", ".+?"],
  ["%j", ".+?"],
  ["%o", ".+?"],
  ["%%", "%"]
]);
function escapeTestName(label, dynamic) {
  if (!dynamic) return escapeRegex(label);
  let pattern = label.replace(/\$[a-z_.]+/gi, "%s");
  return pattern = escapeRegex(pattern), pattern = pattern.replace(/%[i#dfsjo%]/g, (m) => kReplacers.get(m) || m), pattern;
}
var BrowserSessions = class {
  constructor() {
    __publicField(this, "sessions", /* @__PURE__ */ new Map());
    __publicField(this, "sessionIds", /* @__PURE__ */ new Set());
  }
  getSession(sessionId) {
    return this.sessions.get(sessionId);
  }
  destroySession(sessionId) {
    this.sessions.delete(sessionId);
  }
  createSession(sessionId, project, pool) {
    const defer = createDefer(), timeout = setTimeout(() => {
      defer.reject(new Error(`Failed to connect to the browser session "${sessionId}" [${project.name}] within the timeout.`));
    }, project.vitest.config.browser.connectTimeout ?? 6e4).unref();
    return this.sessions.set(sessionId, {
      project,
      connected: () => {
        defer.resolve(), clearTimeout(timeout);
      },
      fail: (error) => {
        defer.resolve(), clearTimeout(timeout), pool.reject(error);
      }
    }), defer;
  }
};
var FilesStatsCache = class {
  constructor() {
    __publicField(this, "cache", /* @__PURE__ */ new Map());
  }
  getStats(key) {
    return this.cache.get(key);
  }
  async populateStats(root, specs) {
    const promises3 = specs.map((spec) => {
      const key = `${spec.project.name}:${relative(root, spec.moduleId)}`;
      return this.updateStats(spec.moduleId, key);
    });
    await Promise.all(promises3);
  }
  async updateStats(fsPath, key) {
    if (!import_node_fs6.default.existsSync(fsPath)) return;
    const stats = await import_node_fs6.default.promises.stat(fsPath);
    this.cache.set(key, { size: stats.size });
  }
  removeStats(fsPath) {
    this.cache.forEach((_, key) => {
      if (key.endsWith(fsPath)) this.cache.delete(key);
    });
  }
};
var ResultsCache = class {
  constructor(version2) {
    __publicField(this, "cache", /* @__PURE__ */ new Map());
    __publicField(this, "workspacesKeyMap", /* @__PURE__ */ new Map());
    __publicField(this, "cachePath", null);
    __publicField(this, "version");
    __publicField(this, "root", "/");
    this.version = version2;
  }
  getCachePath() {
    return this.cachePath;
  }
  setConfig(root, config) {
    if (this.root = root, config) this.cachePath = resolve(config.dir, "results.json");
  }
  getResults(key) {
    return this.cache.get(key);
  }
  async readFromCache() {
    if (!this.cachePath || !import_node_fs6.default.existsSync(this.cachePath)) return;
    const resultsCache = await import_node_fs6.default.promises.readFile(this.cachePath, "utf8"), { results, version: version2 } = JSON.parse(resultsCache || "[]"), [major, minor] = version2.split(".");
    if (major > 0 || Number(minor) >= 30) this.cache = new Map(results), this.version = version2, results.forEach(([spec]) => {
      const [projectName, relativePath] = spec.split(":"), keyMap = this.workspacesKeyMap.get(relativePath) || [];
      keyMap.push(projectName), this.workspacesKeyMap.set(relativePath, keyMap);
    });
  }
  updateResults(files) {
    files.forEach((file) => {
      const result = file.result;
      if (!result) return;
      const duration = result.duration || 0, relativePath = relative(this.root, file.filepath);
      this.cache.set(`${file.projectName || ""}:${relativePath}`, {
        duration: duration >= 0 ? duration : 0,
        failed: result.state === "fail"
      });
    });
  }
  removeFromCache(filepath) {
    this.cache.forEach((_, key) => {
      if (key.endsWith(filepath)) this.cache.delete(key);
    });
  }
  async writeToCache() {
    if (!this.cachePath) return;
    const results = Array.from(this.cache.entries()), cacheDirname = dirname(this.cachePath);
    if (!import_node_fs6.default.existsSync(cacheDirname)) await import_node_fs6.default.promises.mkdir(cacheDirname, { recursive: true });
    const cache2 = JSON.stringify({
      version: this.version,
      results
    });
    await import_node_fs6.default.promises.writeFile(this.cachePath, cache2);
  }
};
var VitestCache = class {
  constructor(version2) {
    __publicField(this, "results");
    __publicField(this, "stats", new FilesStatsCache());
    this.results = new ResultsCache(version2);
  }
  getFileTestResults(key) {
    return this.results.getResults(key);
  }
  getFileStats(key) {
    return this.stats.getStats(key);
  }
  static resolveCacheDir(root, dir, projectName) {
    const baseDir = slash(dir || "node_modules/.vite");
    return resolve(root, baseDir, "vitest", hash("sha1", projectName || "", "hex"));
  }
};
var created = /* @__PURE__ */ new Set();
var promises2 = /* @__PURE__ */ new Map();
function createFetchModuleFunction(resolver, tmpDir = join((0, import_node_os3.tmpdir)(), nanoid()), dump) {
  return async (url2, importer, environment, cacheFs, options) => {
    if (url2.startsWith("data:")) return {
      externalize: url2,
      type: "builtin"
    };
    if (url2 === "/@vite/client" || url2 === "@vite/client")
      return {
        externalize: "/@vite/client",
        type: "module"
      };
    const isFileUrl = url2.startsWith("file://");
    if (isExternalUrl(url2) && !isFileUrl) return {
      externalize: url2,
      type: "network"
    };
    const moduleGraphModule = await environment.moduleGraph.ensureEntryFromUrl(unwrapId(url2)), cached = !!moduleGraphModule.transformResult;
    if ((options == null ? void 0 : options.cached) && cached) return { cache: true };
    if (moduleGraphModule.id) {
      const externalize = await resolver.shouldExternalize(moduleGraphModule.id);
      if (externalize) return {
        externalize,
        type: "module"
      };
    }
    let moduleRunnerModule;
    if ((dump == null ? void 0 : dump.dumpFolder) && dump.readFromDump) {
      const path3 = resolve(dump == null ? void 0 : dump.dumpFolder, url2.replace(/[^\w+]/g, "-"));
      if ((0, import_node_fs6.existsSync)(path3)) {
        const code2 = await (0, import_promises3.readFile)(path3, "utf-8"), matchIndex = code2.lastIndexOf("\n//");
        if (matchIndex !== -1) {
          const { id, file } = JSON.parse(code2.slice(matchIndex + 4));
          moduleRunnerModule = {
            code: code2,
            id,
            url: url2,
            file,
            invalidate: false
          };
        }
      }
    }
    if (!moduleRunnerModule) moduleRunnerModule = await fetchModule(environment, url2, importer, {
      ...options,
      inlineSourceMap: false
    }).catch(handleRollupError);
    const result = processResultSource(environment, moduleRunnerModule);
    if ((dump == null ? void 0 : dump.dumpFolder) && "code" in result) {
      const path3 = resolve(dump == null ? void 0 : dump.dumpFolder, result.url.replace(/[^\w+]/g, "-"));
      await (0, import_promises3.writeFile)(path3, `${result.code}
// ${JSON.stringify({
        id: result.id,
        file: result.file
      })}`, "utf-8");
    }
    if (!cacheFs || !("code" in result)) return result;
    const code = result.code, transformResult = result.transformResult;
    if (!transformResult) throw new Error(`"transformResult" in not defined. This is a bug in Vitest.`);
    if ("_vitestTmp" in transformResult) return getCachedResult(result, Reflect.get(transformResult, "_vitestTmp"));
    const dir = join(tmpDir, environment.name), name = hash("sha1", result.id, "hex"), tmp = join(dir, name);
    if (!created.has(dir)) (0, import_node_fs6.mkdirSync)(dir, { recursive: true }), created.add(dir);
    return promises2.has(tmp) ? (await promises2.get(tmp), Reflect.set(transformResult, "_vitestTmp", tmp), getCachedResult(result, tmp)) : (promises2.set(tmp, atomicWriteFile(tmp, code).catch(() => (0, import_promises3.writeFile)(tmp, code, "utf-8")).finally(() => promises2.delete(tmp))), await promises2.get(tmp), getCachedResult(result, tmp));
  };
}
var SOURCEMAPPING_URL = "sourceMa";
SOURCEMAPPING_URL += "ppingURL";
var MODULE_RUNNER_SOURCEMAPPING_SOURCE = "//# sourceMappingSource=vite-generated";
function processResultSource(environment, result) {
  var _a2;
  if (!("code" in result)) return result;
  const node = environment.moduleGraph.getModuleById(result.id);
  if (node == null ? void 0 : node.transformResult)
    inlineSourceMap(node.transformResult);
  return {
    ...result,
    code: ((_a2 = node == null ? void 0 : node.transformResult) == null ? void 0 : _a2.code) || result.code,
    transformResult: node == null ? void 0 : node.transformResult
  };
}
var OTHER_SOURCE_MAP_REGEXP = new RegExp(`//# ${SOURCEMAPPING_URL}=data:application/json[^,]+base64,([A-Za-z0-9+/=]+)$`, "gm");
function inlineSourceMap(result) {
  const map = result.map;
  let code = result.code;
  if (!map || !("version" in map) || code.includes(MODULE_RUNNER_SOURCEMAPPING_SOURCE)) return result;
  if (OTHER_SOURCE_MAP_REGEXP.lastIndex = 0, OTHER_SOURCE_MAP_REGEXP.test(code)) code = code.replace(OTHER_SOURCE_MAP_REGEXP, "");
  const sourceMap = { ...map };
  if (sourceMap.mappings[0] === ";") sourceMap.mappings = `AAAA,CAAA${sourceMap.mappings}`;
  return result.code = `${code.trimEnd()}
${MODULE_RUNNER_SOURCEMAPPING_SOURCE}
//# ${SOURCEMAPPING_URL}=${genSourceMapUrl(sourceMap)}
`, result;
}
function genSourceMapUrl(map) {
  if (typeof map !== "string") map = JSON.stringify(map);
  return `data:application/json;base64,${Buffer.from(map).toString("base64")}`;
}
function getCachedResult(result, tmp) {
  return {
    cached: true,
    file: result.file,
    id: result.id,
    tmp,
    url: result.url,
    invalidate: result.invalidate
  };
}
function handleRollupError(e) {
  throw e instanceof Error && ("plugin" in e || "frame" in e || "id" in e) ? {
    name: e.name,
    message: e.message,
    stack: e.stack,
    cause: e.cause,
    __vitest_rollup_error__: {
      plugin: e.plugin,
      id: e.id,
      loc: e.loc,
      frame: e.frame
    }
  } : e;
}
async function atomicWriteFile(realFilePath, data) {
  const dir = dirname(realFilePath), tmpFilePath = join(dir, `.tmp-${Date.now()}-${Math.random().toString(36).slice(2)}`);
  try {
    await (0, import_promises3.writeFile)(tmpFilePath, data, "utf-8"), await (0, import_promises3.rename)(tmpFilePath, realFilePath);
  } finally {
    try {
      if (await (0, import_promises3.stat)(tmpFilePath)) await (0, import_promises3.unlink)(tmpFilePath);
    } catch {
    }
  }
}
function normalizeResolvedIdToUrl(environment, resolvedId) {
  const root = environment.config.root, depsOptimizer = environment.depsOptimizer;
  let url2;
  if (resolvedId.startsWith(withTrailingSlash(root)))
    url2 = resolvedId.slice(root.length);
  else if ((depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(resolvedId)) || resolvedId !== "/@react-refresh" && import_node_path2.default.isAbsolute(resolvedId) && (0, import_node_fs6.existsSync)(cleanUrl(resolvedId)))
    url2 = import_node_path2.default.posix.join("/@fs/", resolvedId);
  else url2 = resolvedId;
  if (url2[0] !== "." && url2[0] !== "/") url2 = wrapId(resolvedId);
  return url2;
}
var ServerModuleRunner = class extends ModuleRunner {
  constructor(environment, fetcher, config) {
    super({
      hmr: false,
      transport: { async invoke(event) {
        if (event.type !== "custom") throw new Error(`Vitest Module Runner doesn't support Vite HMR events.`);
        const { name, data } = event.data;
        if (name === "getBuiltins") return await environment.hot.handleInvoke(event);
        if (name !== "fetchModule") return { error: new Error(`Unknown method: ${name}. Expected "fetchModule".`) };
        try {
          return { result: await fetcher(data[0], data[1], environment, false, data[2]) };
        } catch (error) {
          return { error };
        }
      } }
    }, new VitestModuleEvaluator()), this.environment = environment, this.config = config;
  }
  async import(rawId) {
    const resolved = await this.environment.pluginContainer.resolveId(rawId, this.config.root);
    if (!resolved) return super.import(rawId);
    const url2 = normalizeResolvedIdToUrl(this.environment, resolved.id);
    return super.import(url2);
  }
};
var FilesNotFoundError = class extends Error {
  constructor(mode) {
    super(`No ${mode} files found`);
    __publicField(this, "code", "VITEST_FILES_NOT_FOUND");
  }
};
var GitNotFoundError = class extends Error {
  constructor() {
    super("Could not find Git root. Have you initialized git with `git init`?");
    __publicField(this, "code", "VITEST_GIT_NOT_FOUND");
  }
};
var LocationFilterFileNotFoundError = class extends Error {
  constructor(filename) {
    super(`Couldn't find file ${filename}. Note when specifying the test location you have to specify the full test filename.`);
    __publicField(this, "code", "VITEST_LOCATION_FILTER_FILE_NOT_FOUND");
  }
};
var IncludeTaskLocationDisabledError = class extends Error {
  constructor() {
    super("Received line number filters while `includeTaskLocation` option is disabled");
    __publicField(this, "code", "VITEST_INCLUDE_TASK_LOCATION_DISABLED");
  }
};
var RangeLocationFilterProvidedError = class extends Error {
  constructor(filter) {
    super(`Found "-" in location filter ${filter}.  Note that range location filters are not supported.  Consider specifying the exact line numbers of your tests.`);
    __publicField(this, "code", "VITEST_RANGE_LOCATION_FILTER_PROVIDED");
  }
};
var VitestFilteredOutProjectError = class extends Error {
  constructor() {
    super("VITEST_FILTERED_OUT_PROJECT");
    __publicField(this, "code", "VITEST_FILTERED_OUT_PROJECT");
  }
};
var HIGHLIGHT_SUPPORTED_EXTS = new Set(["js", "ts"].flatMap((lang) => [
  `.${lang}`,
  `.m${lang}`,
  `.c${lang}`,
  `.${lang}x`,
  `.m${lang}x`,
  `.c${lang}x`
]));
function highlightCode(id, source, colors) {
  const ext = extname(id);
  if (!HIGHLIGHT_SUPPORTED_EXTS.has(ext)) return source;
  const isJsx = ext.endsWith("x");
  return highlight(source, {
    jsx: isJsx,
    colors: C
  });
}
var PAD = "      ";
var ESC$1 = "\x1B[";
var ERASE_DOWN = `${ESC$1}J`;
var ERASE_SCROLLBACK = `${ESC$1}3J`;
var CURSOR_TO_START = `${ESC$1}1;1H`;
var HIDE_CURSOR = `${ESC$1}?25l`;
var SHOW_CURSOR = `${ESC$1}?25h`;
var CLEAR_SCREEN = "\x1Bc";
var Logger = class {
  constructor(ctx, outputStream = process.stdout, errorStream = process.stderr) {
    __publicField(this, "_clearScreenPending");
    __publicField(this, "_highlights", /* @__PURE__ */ new Map());
    __publicField(this, "cleanupListeners", []);
    __publicField(this, "console");
    if (this.ctx = ctx, this.outputStream = outputStream, this.errorStream = errorStream, this.console = new import_node_console.Console({
      stdout: outputStream,
      stderr: errorStream
    }), this._highlights.clear(), this.addCleanupListeners(), this.registerUnhandledRejection(), this.outputStream.isTTY) this.outputStream.write(HIDE_CURSOR);
  }
  log(...args) {
    this._clearScreen(), this.console.log(...args);
  }
  error(...args) {
    this._clearScreen(), this.console.error(...args);
  }
  warn(...args) {
    this._clearScreen(), this.console.warn(...args);
  }
  clearFullScreen(message = "") {
    if (!this.ctx.config.clearScreen) {
      this.console.log(message);
      return;
    }
    if (message) this.console.log(`${CLEAR_SCREEN}${ERASE_SCROLLBACK}${message}`);
    else this.outputStream.write(`${CLEAR_SCREEN}${ERASE_SCROLLBACK}`);
  }
  clearScreen(message, force = false) {
    if (!this.ctx.config.clearScreen) {
      this.console.log(message);
      return;
    }
    if (this._clearScreenPending = message, force) this._clearScreen();
  }
  _clearScreen() {
    if (this._clearScreenPending == null) return;
    const log = this._clearScreenPending;
    this._clearScreenPending = void 0, this.console.log(`${CURSOR_TO_START}${ERASE_DOWN}${log}`);
  }
  printError(err, options = {}) {
    printError(err, this.ctx, this, options);
  }
  deprecate(message) {
    this.error(C.bold(C.bgYellow(" DEPRECATED ")), C.yellow(message));
  }
  clearHighlightCache(filename) {
    if (filename) this._highlights.delete(filename);
    else this._highlights.clear();
  }
  highlight(filename, source) {
    if (this._highlights.has(filename)) return this._highlights.get(filename);
    const code = highlightCode(filename, source);
    return this._highlights.set(filename, code), code;
  }
  printNoTestFound(filters) {
    var _a2;
    const config = this.ctx.config;
    if (config.watch && (config.changed || ((_a2 = config.related) == null ? void 0 : _a2.length))) this.log(`No affected ${config.mode} files found
`);
    else if (config.watch) this.log(C.red(`No ${config.mode} files found. You can change the file name pattern by pressing "p"
`));
    else if (config.passWithNoTests) this.log(`No ${config.mode} files found, exiting with code 0
`);
    else this.error(C.red(`No ${config.mode} files found, exiting with code 1
`));
    const comma2 = C.dim(", ");
    if (filters == null ? void 0 : filters.length) this.console.error(C.dim("filter: ") + C.yellow(filters.join(comma2)));
    const projectsFilter = toArray(config.project);
    if (projectsFilter.length) this.console.error(C.dim("projects: ") + C.yellow(projectsFilter.join(comma2)));
    this.ctx.projects.forEach((project) => {
      const config2 = project.config;
      if (!project.isRootProject() && project.name) this.console.error(`
${formatProjectName(project)}
`);
      if (config2.include) this.console.error(C.dim("include: ") + C.yellow(config2.include.join(comma2)));
      if (config2.exclude) this.console.error(C.dim("exclude:  ") + C.yellow(config2.exclude.join(comma2)));
      if (config2.typecheck.enabled) this.console.error(C.dim("typecheck include: ") + C.yellow(config2.typecheck.include.join(comma2))), this.console.error(C.dim("typecheck exclude: ") + C.yellow(config2.typecheck.exclude.join(comma2)));
    }), this.console.error();
  }
  printBanner() {
    var _a2, _b2;
    this.log();
    const color = this.ctx.config.watch ? "blue" : "cyan", mode = this.ctx.config.watch ? "DEV" : "RUN";
    if (this.log(withLabel(color, mode, `v${this.ctx.version} `) + C.gray(this.ctx.config.root)), this.ctx.config.sequence.sequencer === RandomSequencer) this.log(PAD + C.gray(`Running tests with seed "${this.ctx.config.sequence.seed}"`));
    if (this.ctx.config.ui) {
      const host = ((_a2 = this.ctx.config.api) == null ? void 0 : _a2.host) || "localhost", port = this.ctx.vite.config.server.port, base2 = this.ctx.config.uiBase;
      this.log(PAD + C.dim(C.green(`UI started at http://${host}:${C.bold(port)}${base2}`)));
    } else if ((_b2 = this.ctx.config.api) == null ? void 0 : _b2.port) {
      const resolvedUrls = this.ctx.vite.resolvedUrls, fallbackUrl = `http://${this.ctx.config.api.host || "localhost"}:${this.ctx.config.api.port}`, origin = (resolvedUrls == null ? void 0 : resolvedUrls.local[0]) ?? (resolvedUrls == null ? void 0 : resolvedUrls.network[0]) ?? fallbackUrl;
      this.log(PAD + C.dim(C.green(`API started at ${new URL("/", origin)}`)));
    }
    if (this.ctx.coverageProvider) this.log(PAD + C.dim("Coverage enabled with ") + C.yellow(this.ctx.coverageProvider.name));
    if (this.ctx.config.standalone) this.log(C.yellow(`
Vitest is running in standalone mode. Edit a test file to rerun tests.`));
    else this.log();
  }
  printBrowserBanner(project) {
    var _a2;
    if (!project.browser) return;
    const resolvedUrls = project.browser.vite.resolvedUrls, origin = (resolvedUrls == null ? void 0 : resolvedUrls.local[0]) ?? (resolvedUrls == null ? void 0 : resolvedUrls.network[0]);
    if (!origin) return;
    const output = project.isRootProject() ? "" : formatProjectName(project), provider = (_a2 = project.browser.provider) == null ? void 0 : _a2.name, providerString = provider === "preview" ? "" : ` by ${C.reset(C.bold(provider))}`;
    this.log(C.dim(`${output}Browser runner started${providerString} ${C.dim("at")} ${C.blue(new URL("/__vitest_test__/", origin))}
`));
  }
  printUnhandledErrors(errors) {
    const errorMessage = C.red(C.bold(`
Vitest caught ${errors.length} unhandled error${errors.length > 1 ? "s" : ""} during the test run.
This might cause false positive tests. Resolve unhandled errors to make sure your tests are not affected.`));
    this.error(errorBanner("Unhandled Errors")), this.error(errorMessage), errors.forEach((err) => {
      this.printError(err, {
        fullStack: true,
        type: err.type || "Unhandled Error"
      });
    }), this.error(C.red(divider()));
  }
  printSourceTypeErrors(errors) {
    const errorMessage = C.red(C.bold(`
Vitest found ${errors.length} error${errors.length > 1 ? "s" : ""} not related to your test files.`));
    this.log(errorBanner("Source Errors")), this.log(errorMessage), errors.forEach((err) => {
      this.printError(err, { fullStack: true });
    }), this.log(C.red(divider()));
  }
  getColumns() {
    return "columns" in this.outputStream ? this.outputStream.columns : 80;
  }
  onTerminalCleanup(listener) {
    this.cleanupListeners.push(listener);
  }
  addCleanupListeners() {
    const cleanup = () => {
      if (this.cleanupListeners.forEach((fn) => fn()), this.outputStream.isTTY) this.outputStream.write(SHOW_CURSOR);
    }, onExit = (signal, exitCode) => {
      if (cleanup(), process.exitCode === void 0) process.exitCode = exitCode !== void 0 ? 128 + exitCode : Number(signal);
      setTimeout(() => process.exit(), 1);
    };
    process.once("SIGINT", onExit), process.once("SIGTERM", onExit), process.once("exit", onExit), this.ctx.onClose(() => {
      process.off("SIGINT", onExit), process.off("SIGTERM", onExit), process.off("exit", onExit), cleanup();
    });
  }
  registerUnhandledRejection() {
    const onUnhandledRejection = (err) => {
      process.exitCode = 1, this.printError(err, {
        fullStack: true,
        type: "Unhandled Rejection"
      }), this.error("\n\n"), process.exit();
    };
    process.on("unhandledRejection", onUnhandledRejection), this.ctx.onClose(() => {
      process.off("unhandledRejection", onUnhandledRejection);
    });
  }
};
var __dirname = import_node_url4.default.fileURLToPath(new URL(".", import.meta.url));
var VitestPackageInstaller = class {
  isPackageExists(name, options) {
    return isPackageExists(name, options);
  }
  async ensureInstalled(dependency, root, version2) {
    if (process.env.VITEST_SKIP_INSTALL_CHECKS) return true;
    if (process.versions.pnp) {
      const targetRequire = (0, import_node_module5.createRequire)(__dirname);
      try {
        return targetRequire.resolve(dependency, { paths: [root, __dirname] }), true;
      } catch {
      }
    }
    if (isPackageExists(dependency, { paths: [root, __dirname] })) return true;
    if (process.stderr.write(C.red(`${C.inverse(C.red(" MISSING DEPENDENCY "))} Cannot find dependency '${dependency}'

`)), !isTTY) return false;
    const { install } = await (await import("./index.Dc3xnDvT-MPEO75WJ.js").then(function(n2) {
      return n2.i;
    })).default({
      type: "confirm",
      name: "install",
      message: C.reset(`Do you want to install ${C.green(dependency)}?`)
    });
    if (install) {
      const packageName = version2 ? `${dependency}@${version2}` : dependency;
      return await (await import("./index.D3XRDfWc-6APYU5F3.js")).installPackage(packageName, { dev: true }), process.stderr.write(C.yellow(`
Package ${packageName} installed, re-run the command to start.
`)), process.exit(), true;
    }
    return false;
  }
};
function getDefaultThreadsCount(config) {
  const numCpus = typeof nodeos.availableParallelism === "function" ? nodeos.availableParallelism() : nodeos.cpus().length;
  return config.watch ? Math.max(Math.floor(numCpus / 2), 1) : Math.max(numCpus - 1, 1);
}
function getWorkerMemoryLimit(config) {
  return config.vmMemoryLimit ? config.vmMemoryLimit : 1 / (config.maxWorkers ?? getDefaultThreadsCount(config));
}
function stringToBytes(input, percentageReference) {
  if (input === null || input === void 0) return input;
  if (typeof input === "string") if (Number.isNaN(Number.parseFloat(input.slice(-1)))) {
    let [, numericString, trailingChars] = input.match(/(.*?)([^0-9.-]+)$/) || [];
    if (trailingChars && numericString) {
      const numericValue = Number.parseFloat(numericString);
      switch (trailingChars = trailingChars.toLowerCase(), trailingChars) {
        case "%":
          input = numericValue / 100;
          break;
        case "kb":
        case "k":
          return numericValue * 1e3;
        case "kib":
          return numericValue * 1024;
        case "mb":
        case "m":
          return numericValue * 1e3 * 1e3;
        case "mib":
          return numericValue * 1024 * 1024;
        case "gb":
        case "g":
          return numericValue * 1e3 * 1e3 * 1e3;
        case "gib":
          return numericValue * 1024 * 1024 * 1024;
      }
    }
  } else input = Number.parseFloat(input);
  if (typeof input === "number") if (input <= 1 && input > 0) {
    if (percentageReference) return Math.floor(input * percentageReference);
    throw new Error("For a percentage based memory limit a percentageReference must be supplied");
  } else if (input > 1) return Math.floor(input);
  else throw new Error('Unexpected numerical input for "memoryLimit"');
  return null;
}
async function getSpecificationsEnvironments(specifications) {
  const environments = /* @__PURE__ */ new WeakMap(), cache2 = /* @__PURE__ */ new Map();
  return await Promise.all(specifications.map(async (spec) => {
    var _a2, _b2;
    const { moduleId: filepath, project } = spec;
    let code = cache2.get(filepath);
    if (!code) code = await import_node_fs6.promises.readFile(filepath, "utf-8"), cache2.set(filepath, code);
    let env = (_a2 = code.match(/@(?:vitest|jest)-environment\s+([\w-]+)\b/)) == null ? void 0 : _a2[1];
    env || (env = project.config.environment || "node");
    let envOptionsJson = (_b2 = code.match(/@(?:vitest|jest)-environment-options\s+(.+)/)) == null ? void 0 : _b2[1];
    if (envOptionsJson == null ? void 0 : envOptionsJson.endsWith("*/"))
      envOptionsJson = envOptionsJson.slice(0, -2);
    const envOptions = JSON.parse(envOptionsJson || "null"), environment = {
      name: env,
      options: envOptions ? { [env === "happy-dom" ? "happyDOM" : env]: envOptions } : null
    };
    environments.set(spec, environment);
  })), environments;
}
var debug = createDebugger("vitest:browser:pool");
function createBrowserPool(vitest) {
  const providers = /* @__PURE__ */ new Set(), numCpus = typeof nodeos.availableParallelism === "function" ? nodeos.availableParallelism() : nodeos.cpus().length, maxThreadsCount = Math.min(12, numCpus - 1), threadsCount = vitest.config.watch ? Math.max(Math.floor(maxThreadsCount / 2), 1) : Math.max(maxThreadsCount, 1), projectPools = /* @__PURE__ */ new WeakMap(), ensurePool = (project) => {
    if (projectPools.has(project)) return projectPools.get(project);
    debug == null ? void 0 : debug("creating pool for project %s", project.name);
    const resolvedUrls = project.browser.vite.resolvedUrls, origin = (resolvedUrls == null ? void 0 : resolvedUrls.local[0]) ?? (resolvedUrls == null ? void 0 : resolvedUrls.network[0]);
    if (!origin) throw new Error(`Can't find browser origin URL for project "${project.name}"`);
    const pool = new BrowserPool(project, {
      maxWorkers: getThreadsCount(project),
      origin
    });
    return projectPools.set(project, pool), vitest.onCancel(() => {
      pool.cancel();
    }), pool;
  }, runWorkspaceTests = async (method, specs) => {
    const groupedFiles = /* @__PURE__ */ new Map();
    for (const { project, moduleId, testLines } of specs) {
      const files = groupedFiles.get(project) || [];
      files.push({
        filepath: moduleId,
        testLocations: testLines
      }), groupedFiles.set(project, files);
    }
    let isCancelled = false;
    vitest.onCancel(() => {
      isCancelled = true;
    });
    const initialisedPools = await Promise.all([...groupedFiles.entries()].map(async ([project, files]) => {
      if (await project._initBrowserProvider(), !project.browser) throw new TypeError(`The browser server was not initialized${project.name ? ` for the "${project.name}" project` : ""}. This is a bug in Vitest. Please, open a new issue with reproduction.`);
      if (isCancelled) return;
      debug == null ? void 0 : debug("provider is ready for %s project", project.name);
      const pool = ensurePool(project);
      return vitest.state.clearFiles(project, files.map((f) => f.filepath)), providers.add(project.browser.provider), {
        pool,
        provider: project.browser.provider,
        runTests: () => pool.runTests(method, files)
      };
    }));
    if (isCancelled) return;
    const parallelPools = [], nonParallelPools = [];
    for (const pool of initialisedPools) {
      if (!pool)
        return;
      if (pool.provider.mocker && pool.provider.supportsParallelism) parallelPools.push(pool.runTests);
      else nonParallelPools.push(pool.runTests);
    }
    await Promise.all(parallelPools.map((runTests) => runTests()));
    for (const runTests of nonParallelPools) {
      if (isCancelled) return;
      await runTests();
    }
  };
  function getThreadsCount(project) {
    const config = project.config.browser;
    return !config.headless || !config.fileParallelism || !project.browser.provider.supportsParallelism ? 1 : project.config.maxWorkers ? project.config.maxWorkers : threadsCount;
  }
  return {
    name: "browser",
    async close() {
      await Promise.all([...providers].map((provider) => provider.close())), vitest._browserSessions.sessionIds.clear(), providers.clear(), vitest.projects.forEach((project) => {
        var _a2;
        (_a2 = project.browser) == null ? void 0 : _a2.state.orchestrators.forEach((orchestrator) => {
          orchestrator.$close();
        });
      }), debug == null ? void 0 : debug("browser pool closed all providers");
    },
    runTests: (files) => runWorkspaceTests("run", files),
    collectTests: (files) => runWorkspaceTests("collect", files)
  };
}
function escapePathToRegexp(path3) {
  return path3.replace(/[/\\.?*()^${}|[\]+]/g, "\\$&");
}
var BrowserPool = class {
  constructor(project, options) {
    __publicField(this, "_queue", []);
    __publicField(this, "_promise");
    __publicField(this, "_providedContext");
    __publicField(this, "readySessions", /* @__PURE__ */ new Set());
    this.project = project, this.options = options;
  }
  cancel() {
    this._queue = [];
  }
  reject(error) {
    var _a2;
    (_a2 = this._promise) == null ? void 0 : _a2.reject(error), this._promise = void 0, this.cancel();
  }
  get orchestrators() {
    return this.project.browser.state.orchestrators;
  }
  async runTests(method, files) {
    if (this._promise ?? (this._promise = createDefer()), !files.length) return debug == null ? void 0 : debug("no tests found, finishing test run immediately"), this._promise.resolve(), this._promise;
    if (this._providedContext = stringify(this.project.getProvidedContext()), this._queue.push(...files), this.readySessions.forEach((sessionId) => {
      if (this._queue.length) this.readySessions.delete(sessionId), this.runNextTest(method, sessionId);
    }), this.orchestrators.size >= this.options.maxWorkers) return debug == null ? void 0 : debug("all orchestrators are ready, not creating more"), this._promise;
    const workerCount = Math.min(this.options.maxWorkers - this.orchestrators.size, files.length), promises3 = [];
    for (let i = 0; i < workerCount; i++) {
      const sessionId = import_node_crypto2.default.randomUUID();
      this.project.vitest._browserSessions.sessionIds.add(sessionId);
      const project = this.project.name;
      debug == null ? void 0 : debug("[%s] creating session for %s", sessionId, project);
      const page = this.openPage(sessionId).then(() => {
        this.runNextTest(method, sessionId);
      });
      promises3.push(page);
    }
    return await Promise.all(promises3), debug == null ? void 0 : debug("all sessions are created"), this._promise;
  }
  async openPage(sessionId) {
    const sessionPromise = this.project.vitest._browserSessions.createSession(sessionId, this.project, this), browser = this.project.browser, url2 = new URL("/__vitest_test__/", this.options.origin);
    url2.searchParams.set("sessionId", sessionId);
    const pagePromise = browser.provider.openPage(sessionId, url2.toString());
    await Promise.all([sessionPromise, pagePromise]);
  }
  getOrchestrator(sessionId) {
    const orchestrator = this.orchestrators.get(sessionId);
    if (!orchestrator) throw new Error(`Orchestrator not found for session ${sessionId}. This is a bug in Vitest. Please, open a new issue with reproduction.`);
    return orchestrator;
  }
  finishSession(sessionId) {
    var _a2;
    if (this.readySessions.add(sessionId), this.readySessions.size === this.orchestrators.size) (_a2 = this._promise) == null ? void 0 : _a2.resolve(), this._promise = void 0, debug == null ? void 0 : debug("[%s] all tests finished running", sessionId);
    else debug == null ? void 0 : debug(`did not finish sessions for ${sessionId}: |ready - %s| |overall - %s|`, [...this.readySessions].join(", "), [...this.orchestrators.keys()].join(", "));
  }
  runNextTest(method, sessionId) {
    const file = this._queue.shift();
    if (!file) {
      if (debug == null ? void 0 : debug("[%s] no more tests to run", sessionId), this.project.config.browser.isolate) {
        this.finishSession(sessionId);
        return;
      }
      this.getOrchestrator(sessionId).cleanupTesters().catch((error) => this.reject(error)).finally(() => this.finishSession(sessionId));
      return;
    }
    if (!this._promise) throw new Error(`Unexpected empty queue`);
    const orchestrator = this.getOrchestrator(sessionId);
    debug == null ? void 0 : debug("[%s] run test %s", sessionId, file), this.setBreakpoint(sessionId, file.filepath).then(() => {
      orchestrator.createTesters({
        method,
        files: [file],
        providedContext: this._providedContext || "[{}]"
      }).then(() => {
        debug == null ? void 0 : debug("[%s] test %s finished running", sessionId, file), this.runNextTest(method, sessionId);
      }).catch((error) => {
        var _a2;
        if (this.project.vitest.isCancelling && error instanceof Error && error.message.startsWith("Browser connection was closed while running tests")) {
          this.cancel(), (_a2 = this._promise) == null ? void 0 : _a2.resolve(), this._promise = void 0, debug == null ? void 0 : debug("[%s] browser connection was closed", sessionId);
          return;
        }
        debug == null ? void 0 : debug("[%s] error during %s test run: %s", sessionId, file, error), this.reject(error);
      });
    }).catch((err) => this.reject(err));
  }
  async setBreakpoint(sessionId, file) {
    if (!this.project.config.inspector.waitForDebugger) return;
    const provider = this.project.browser.provider, browser = this.project.config.browser.name;
    if (shouldIgnoreDebugger(provider.name, browser)) {
      debug == null ? void 0 : debug("[$s] ignoring debugger in %s browser because it is not supported", sessionId, browser);
      return;
    }
    if (!provider.getCDPSession) throw new Error("Unable to set breakpoint, CDP not supported");
    debug == null ? void 0 : debug("[%s] set breakpoint for %s", sessionId, file);
    const session = await provider.getCDPSession(sessionId);
    await session.send("Debugger.enable", {}), await session.send("Debugger.setBreakpointByUrl", {
      lineNumber: 0,
      urlRegex: escapePathToRegexp(file)
    });
  }
};
function shouldIgnoreDebugger(provider, browser) {
  return provider === "webdriverio" ? browser !== "chrome" && browser !== "edge" : browser !== "chromium";
}
function createMethodsRPC(project, options = {}) {
  var _a2, _b2;
  const vitest = project.vitest, cacheFs = options.cacheFs ?? false;
  if ((_a2 = project.vitest.state.metadata)[_b2 = project.name] ?? (_a2[_b2] = {
    externalized: {},
    duration: {},
    tmps: {}
  }), project.config.dumpDir && !(0, import_node_fs6.existsSync)(project.config.dumpDir)) (0, import_node_fs6.mkdirSync)(project.config.dumpDir, { recursive: true });
  return project.vitest.state.metadata[project.name].dumpDir = project.config.dumpDir, {
    async fetch(url2, importer, environmentName, options2) {
      const environment = project.vite.environments[environmentName];
      if (!environment) throw new Error(`The environment ${environmentName} was not defined in the Vite config.`);
      const start2 = performance.now();
      return await project._fetcher(url2, importer, environment, cacheFs, options2).then((result) => {
        var _a3;
        const duration = performance.now() - start2;
        project.vitest.state.transformTime += duration;
        const metadata = project.vitest.state.metadata[project.name];
        if ("externalize" in result) metadata.externalized[url2] = result.externalize;
        if ("tmp" in result) metadata.tmps[url2] = result.tmp;
        return (_a3 = metadata.duration)[url2] ?? (_a3[url2] = []), metadata.duration[url2].push(duration), result;
      });
    },
    async resolve(id, importer, environmentName) {
      const environment = project.vite.environments[environmentName];
      if (!environment) throw new Error(`The environment ${environmentName} was not defined in the Vite config.`);
      const resolved = await environment.pluginContainer.resolveId(id, importer);
      if (!resolved) return null;
      const file = cleanUrl(resolved.id);
      return resolved.external ? {
        file,
        url: !resolved.id.startsWith("node:") && (0, import_node_module5.isBuiltin)(resolved.id) ? `node:${resolved.id}` : resolved.id,
        id: resolved.id
      } : {
        file: cleanUrl(resolved.id),
        url: normalizeResolvedIdToUrl(environment, resolved.id),
        id: resolved.id
      };
    },
    snapshotSaved(snapshot) {
      vitest.snapshot.add(snapshot);
    },
    resolveSnapshotPath(testPath) {
      return vitest.snapshot.resolvePath(testPath, { config: project.serializedConfig });
    },
    async transform(id) {
      var _a3;
      const environment = project.vite.environments.__vitest_vm__;
      if (!environment) throw new Error(`The VM environment was not defined in the Vite config. This is a bug in Vitest. Please, open a new issue with reproduction.`);
      const url2 = normalizeResolvedIdToUrl(environment, (0, import_node_url4.fileURLToPath)(id));
      return { code: (_a3 = await environment.transformRequest(url2).catch(handleRollupError)) == null ? void 0 : _a3.code };
    },
    async onQueued(file) {
      if (options.collect) vitest.state.collectFiles(project, [file]);
      else await vitest._testRun.enqueued(project, file);
    },
    async onCollected(files) {
      if (options.collect) vitest.state.collectFiles(project, files);
      else await vitest._testRun.collected(project, files);
    },
    onAfterSuiteRun(meta) {
      var _a3;
      (_a3 = vitest.coverageProvider) == null ? void 0 : _a3.onAfterSuiteRun(meta);
    },
    async onTaskAnnotate(testId, annotation) {
      return vitest._testRun.annotate(testId, annotation);
    },
    async onTaskUpdate(packs, events) {
      if (options.collect) vitest.state.updateTasks(packs);
      else await vitest._testRun.updated(packs, events);
    },
    async onUserConsoleLog(log) {
      if (options.collect) vitest.state.updateUserLog(log);
      else await vitest._testRun.log(log);
    },
    onUnhandledError(err, type) {
      vitest.state.catchError(err, type);
    },
    onCancel(reason) {
      vitest.cancelCurrentRun(reason);
    },
    getCountOfFailedTests() {
      return vitest.state.getCountOfFailedTests();
    }
  };
}
var RunnerState = function(RunnerState2) {
  return RunnerState2["IDLE"] = "idle", RunnerState2["STARTING"] = "starting", RunnerState2["STARTED"] = "started", RunnerState2["STOPPING"] = "stopping", RunnerState2["STOPPED"] = "stopped", RunnerState2;
}(RunnerState || {});
var START_TIMEOUT = 1e4;
var STOP_TIMEOUT = 1e4;
var PoolRunner = class {
  constructor(options, worker) {
    /** Exposed to test runner as `VITEST_POOL_ID`. Value is between 1-`maxWorkers`. */
    __publicField(this, "poolId");
    __publicField(this, "project");
    __publicField(this, "environment");
    __publicField(this, "_state", RunnerState.IDLE);
    __publicField(this, "_operationLock", null);
    __publicField(this, "_eventEmitter", new import_node_events.EventEmitter());
    __publicField(this, "_rpc");
    __publicField(this, "emitWorkerError", (maybeError) => {
      const error = maybeError instanceof Error ? maybeError : new Error(String(maybeError));
      this._eventEmitter.emit("error", error);
    });
    __publicField(this, "emitWorkerMessage", (response) => {
      try {
        const message = this.worker.deserialize(response);
        if (typeof message === "object" && message != null && message.__vitest_worker_response__) this._eventEmitter.emit("message", message);
        else this._eventEmitter.emit("rpc", message);
      } catch (error) {
        this._eventEmitter.emit("error", error);
      }
    });
    __publicField(this, "emitUnexpectedExit", () => {
      const error = new Error("Worker exited unexpectedly");
      this._eventEmitter.emit("error", error);
    });
    this.worker = worker, this.project = options.project, this.environment = options.environment, this._rpc = createBirpc(createMethodsRPC(this.project, {
      collect: options.method === "collect",
      cacheFs: worker.cacheFs
    }), {
      eventNames: ["onCancel"],
      post: (request) => this.postMessage(request),
      on: (callback) => this._eventEmitter.on("rpc", callback),
      timeout: -1
    }), this.project.vitest.onCancel((reason) => this._rpc.onCancel(reason));
  }
  get isTerminated() {
    return this._state === RunnerState.STOPPED;
  }
  get isStarted() {
    return this._state === RunnerState.STARTED;
  }
  postMessage(message) {
    if (this._state !== RunnerState.STOPPED) return this.worker.send(message);
  }
  async start() {
    if (this._operationLock) await this._operationLock;
    if (!(this._state === RunnerState.STARTED || this._state === RunnerState.STARTING)) {
      if (this._state === RunnerState.STOPPED) throw new Error("[vitest-pool-runner]: Cannot start a stopped runner");
      this._operationLock = createDefer();
      try {
        this._state = RunnerState.STARTING, await this.worker.start(), this.worker.on("error", this.emitWorkerError), this.worker.on("exit", this.emitUnexpectedExit), this.worker.on("message", this.emitWorkerMessage);
        const startPromise = this.withTimeout(this.waitForStart(), START_TIMEOUT);
        this.postMessage({
          type: "start",
          __vitest_worker_request__: true,
          options: { reportMemory: this.worker.reportMemory ?? false }
        }), await startPromise, this._state = RunnerState.STARTED;
      } catch (error) {
        throw this._state = RunnerState.IDLE, error;
      } finally {
        this._operationLock.resolve(), this._operationLock = null;
      }
    }
  }
  async stop() {
    if (this._operationLock) await this._operationLock;
    if (!(this._state === RunnerState.STOPPED || this._state === RunnerState.STOPPING)) {
      if (this._state === RunnerState.IDLE) {
        this._state = RunnerState.STOPPED;
        return;
      }
      this._operationLock = createDefer();
      try {
        this._state = RunnerState.STOPPING, this.worker.off("exit", this.emitUnexpectedExit), await this.withTimeout(new Promise((resolve3) => {
          const onStop = (response) => {
            if (response.type === "stopped") {
              if (response.error) this.project.vitest.state.catchError(response.error, "Teardown Error");
              resolve3(), this.off("message", onStop);
            }
          };
          this.on("message", onStop), this.postMessage({
            type: "stop",
            __vitest_worker_request__: true
          });
        }), STOP_TIMEOUT), this._eventEmitter.removeAllListeners(), this._rpc.$close(new Error("[vitest-pool-runner]: Pending methods while closing rpc")), await this.worker.stop(), this._state = RunnerState.STOPPED;
      } catch (error) {
        throw this._state = RunnerState.STOPPED, error;
      } finally {
        this._operationLock.resolve(), this._operationLock = null;
      }
    }
  }
  on(event, callback) {
    this._eventEmitter.on(event, callback);
  }
  off(event, callback) {
    this._eventEmitter.off(event, callback);
  }
  waitForStart() {
    return new Promise((resolve3) => {
      const onStart = (message) => {
        if (message.type === "started") this.off("message", onStart), resolve3();
      };
      this.on("message", onStart);
    });
  }
  withTimeout(promise, timeout) {
    return new Promise((resolve_, reject_) => {
      const timer = setTimeout(() => reject(new Error("[vitest-pool-runner]: Timeout waiting for worker to respond")), timeout);
      function resolve3(value) {
        clearTimeout(timer), resolve_(value);
      }
      function reject(error) {
        clearTimeout(timer), reject_(error);
      }
      promise.then(resolve3, reject);
    });
  }
};
var SIGKILL_TIMEOUT = 500;
var ForksPoolWorker = class {
  constructor(options) {
    __publicField(this, "name", "forks");
    __publicField(this, "cacheFs", true);
    __publicField(this, "entrypoint");
    __publicField(this, "execArgv");
    __publicField(this, "env");
    __publicField(this, "_fork");
    __publicField(this, "stdout");
    __publicField(this, "stderr");
    this.execArgv = options.execArgv, this.env = options.env, this.stdout = options.project.vitest.logger.outputStream, this.stderr = options.project.vitest.logger.errorStream, this.entrypoint = (0, import_node_path2.resolve)(options.distPath, "workers/forks.js");
  }
  on(event, callback) {
    this.fork.on(event, callback);
  }
  off(event, callback) {
    this.fork.off(event, callback);
  }
  send(message) {
    if ("context" in message) message = {
      ...message,
      context: {
        ...message.context,
        config: wrapSerializableConfig(message.context.config)
      }
    };
    this.fork.send(import_node_v82.default.serialize(message));
  }
  async start() {
    if (this._fork || (this._fork = (0, import_node_child_process.fork)(this.entrypoint, [], {
      env: this.env,
      execArgv: this.execArgv,
      stdio: "pipe"
    })), this._fork.stdout) this.stdout.setMaxListeners(1 + this.stdout.getMaxListeners()), this._fork.stdout.pipe(this.stdout);
    if (this._fork.stderr) this.stderr.setMaxListeners(1 + this.stderr.getMaxListeners()), this._fork.stderr.pipe(this.stderr);
  }
  async stop() {
    var _a2, _b2;
    const fork2 = this.fork, waitForExit = new Promise((resolve3) => {
      if (fork2.exitCode != null) resolve3();
      else fork2.once("exit", resolve3);
    }), sigkillTimeout = setTimeout(() => fork2.kill("SIGKILL"), SIGKILL_TIMEOUT);
    if (fork2.kill(), await waitForExit, clearTimeout(sigkillTimeout), fork2.stdout) (_a2 = fork2.stdout) == null ? void 0 : _a2.unpipe(this.stdout), this.stdout.setMaxListeners(this.stdout.getMaxListeners() - 1);
    if (fork2.stderr) (_b2 = fork2.stderr) == null ? void 0 : _b2.unpipe(this.stderr), this.stderr.setMaxListeners(this.stderr.getMaxListeners() - 1);
    this._fork = void 0;
  }
  deserialize(data) {
    try {
      return import_node_v82.default.deserialize(Buffer.from(data));
    } catch (error) {
      let stringified = "";
      try {
        stringified = `
Received value: ${JSON.stringify(data)}`;
      } catch {
      }
      throw new Error(`[vitest-pool]: Unexpected call to process.send(). Make sure your test cases are not interfering with process's channel.${stringified}`, { cause: error });
    }
  }
  get fork() {
    if (!this._fork) throw new Error(`The child process was torn down or never initialized. This is a bug in Vitest.`);
    return this._fork;
  }
};
function wrapSerializableConfig(config) {
  let testNamePattern = config.testNamePattern, defines = config.defines;
  if (testNamePattern && typeof testNamePattern !== "string") testNamePattern = `$$vitest:${testNamePattern.toString()}`;
  if (defines) defines = {
    keys: Object.keys(defines),
    original: defines
  };
  return {
    ...config,
    testNamePattern,
    defines
  };
}
var ThreadsPoolWorker = class {
  constructor(options) {
    __publicField(this, "name", "threads");
    __publicField(this, "entrypoint");
    __publicField(this, "execArgv");
    __publicField(this, "env");
    __publicField(this, "_thread");
    __publicField(this, "stdout");
    __publicField(this, "stderr");
    this.execArgv = options.execArgv, this.env = options.env, this.stdout = options.project.vitest.logger.outputStream, this.stderr = options.project.vitest.logger.errorStream, this.entrypoint = (0, import_node_path2.resolve)(options.distPath, "workers/threads.js");
  }
  on(event, callback) {
    this.thread.on(event, callback);
  }
  off(event, callback) {
    this.thread.off(event, callback);
  }
  send(message) {
    this.thread.postMessage(message);
  }
  async start() {
    this._thread || (this._thread = new import_node_worker_threads.Worker(this.entrypoint, {
      env: this.env,
      execArgv: this.execArgv,
      stdout: true,
      stderr: true
    })), this.stdout.setMaxListeners(1 + this.stdout.getMaxListeners()), this._thread.stdout.pipe(this.stdout), this.stderr.setMaxListeners(1 + this.stderr.getMaxListeners()), this._thread.stderr.pipe(this.stderr);
  }
  async stop() {
    var _a2, _b2, _c, _d;
    await this.thread.terminate(), (_b2 = (_a2 = this._thread) == null ? void 0 : _a2.stdout) == null ? void 0 : _b2.unpipe(this.stdout), this.stdout.setMaxListeners(this.stdout.getMaxListeners() - 1), (_d = (_c = this._thread) == null ? void 0 : _c.stderr) == null ? void 0 : _d.unpipe(this.stderr), this.stderr.setMaxListeners(this.stderr.getMaxListeners() - 1), this._thread = void 0;
  }
  deserialize(data) {
    return data;
  }
  get thread() {
    if (!this._thread) throw new Error(`The worker thread was torn down or never initialized. This is a bug in Vitest.`);
    return this._thread;
  }
};
var TypecheckPoolWorker = class {
  constructor(options) {
    __publicField(this, "name", "typecheck");
    __publicField(this, "project");
    __publicField(this, "_eventEmitter", new import_node_events.default());
    this.project = options.project;
  }
  async start() {
  }
  async stop() {
  }
  canReuse() {
    return true;
  }
  send(message) {
    onMessage(message, this.project).then((response) => {
      if (response) this._eventEmitter.emit("message", response);
    });
  }
  on(event, callback) {
    this._eventEmitter.on(event, callback);
  }
  off(event, callback) {
    this._eventEmitter.on(event, callback);
  }
  deserialize(data) {
    return data;
  }
};
var __vitest_worker_response__ = true;
var runners = /* @__PURE__ */ new WeakMap();
async function onMessage(message, project) {
  var _a2;
  if ((message == null ? void 0 : message.__vitest_worker_request__) !== true) return;
  let runner = runners.get(project.vitest);
  if (!runner) runner = createRunner(project.vitest), runners.set(project.vitest, runner);
  let runPromise;
  switch (message.type) {
    case "start":
      return {
        type: "started",
        __vitest_worker_response__
      };
    case "run":
      return runPromise = runner.runTests(message.context.files, project).catch((error) => error), {
        type: "testfileFinished",
        error: await runPromise,
        __vitest_worker_response__
      };
    case "collect":
      return runPromise = runner.collectTests(message.context.files, project).catch((error) => error), {
        type: "testfileFinished",
        error: await runPromise,
        __vitest_worker_response__
      };
    case "stop":
      return await runPromise, await ((_a2 = project.typechecker) == null ? void 0 : _a2.stop()), {
        type: "stopped",
        __vitest_worker_response__
      };
  }
  throw new Error(`Unexpected message ${JSON.stringify(message, null, 2)}`);
}
function createRunner(vitest) {
  const promisesMap = /* @__PURE__ */ new WeakMap(), rerunTriggered = /* @__PURE__ */ new WeakSet();
  async function onParseEnd(project, { files, sourceErrors }) {
    var _a2;
    const checker = project.typechecker, { packs, events } = checker.getTestPacksAndEvents();
    if (await vitest._testRun.updated(packs, events), !project.config.typecheck.ignoreSourceErrors) sourceErrors.forEach((error) => vitest.state.catchError(error, "Unhandled Source Error"));
    if (!hasFailed(files) && !sourceErrors.length && checker.getExitCode()) {
      const error = new Error(checker.getOutput());
      error.stack = "", vitest.state.catchError(error, "Typecheck Error");
    }
    if ((_a2 = promisesMap.get(project)) == null ? void 0 : _a2.resolve(), rerunTriggered.delete(project), vitest.config.watch && !vitest.runningPromise) {
      const modules = files.map((file) => vitest.state.getReportedEntity(file)).filter((e) => (e == null ? void 0 : e.type) === "module"), state = vitest.isCancelling ? "interrupted" : modules.some((m) => !m.ok()) ? "failed" : "passed";
      await vitest.report("onTestRunEnd", modules, [], state), await vitest.report("onWatcherStart", files, [...project.config.typecheck.ignoreSourceErrors ? [] : sourceErrors, ...vitest.state.getUnhandledErrors()]);
    }
  }
  async function createWorkspaceTypechecker(project, files) {
    const checker = project.typechecker ?? new Typechecker(project);
    return project.typechecker ? checker : (project.typechecker = checker, checker.setFiles(files), checker.onParseStart(async () => {
      const files2 = checker.getTestFiles();
      for (const file of files2) await vitest._testRun.enqueued(project, file);
      await vitest._testRun.collected(project, files2);
    }), checker.onParseEnd((result) => onParseEnd(project, result)), checker.onWatcherRerun(async () => {
      if (rerunTriggered.add(project), !vitest.runningPromise) vitest.state.clearErrors(), await vitest.report("onWatcherRerun", files, "File change detected. Triggering rerun.");
      await checker.collectTests();
      const testFiles = checker.getTestFiles();
      for (const file of testFiles) await vitest._testRun.enqueued(project, file);
      await vitest._testRun.collected(project, testFiles);
      const { packs, events } = checker.getTestPacksAndEvents();
      await vitest._testRun.updated(packs, events);
    }), checker);
  }
  async function startTypechecker(project, files) {
    if (project.typechecker) return;
    const checker = await createWorkspaceTypechecker(project, files);
    await checker.collectTests(), await checker.start();
  }
  async function collectTests(specs, project) {
    const files = specs.map((spec) => spec.filepath), checker = await createWorkspaceTypechecker(project, files);
    checker.setFiles(files), await checker.collectTests();
    const testFiles = checker.getTestFiles();
    vitest.state.collectFiles(project, testFiles);
  }
  async function runTests(specs, project) {
    const promises3 = [], files = specs.map((spec) => spec.filepath), promise = createDefer(), triggered = await new Promise((resolve3) => {
      const _i = setInterval(() => {
        if (!project.typechecker || rerunTriggered.has(project)) resolve3(true), clearInterval(_i);
      });
      setTimeout(() => {
        resolve3(false), clearInterval(_i);
      }, 500).unref();
    });
    if (project.typechecker && !triggered) {
      const testFiles = project.typechecker.getTestFiles();
      for (const file of testFiles) await vitest._testRun.enqueued(project, file);
      await vitest._testRun.collected(project, testFiles), await onParseEnd(project, project.typechecker.getResult());
    }
    promises3.push(promise), promisesMap.set(project, promise), promises3.push(startTypechecker(project, files)), await Promise.all(promises3);
  }
  return {
    runTests,
    collectTests
  };
}
var VmForksPoolWorker = class extends ForksPoolWorker {
  constructor(options) {
    super({
      ...options,
      execArgv: [...options.execArgv, "--experimental-vm-modules"]
    });
    __publicField(this, "name", "vmForks");
    __publicField(this, "reportMemory", true);
    __publicField(this, "entrypoint");
    this.entrypoint = (0, import_node_path2.resolve)(options.distPath, "workers/vmForks.js");
  }
};
var VmThreadsPoolWorker = class extends ThreadsPoolWorker {
  constructor(options) {
    super({
      ...options,
      execArgv: [...options.execArgv, "--experimental-vm-modules"]
    });
    __publicField(this, "name", "vmThreads");
    __publicField(this, "reportMemory", true);
    __publicField(this, "entrypoint");
    this.entrypoint = (0, import_node_path2.resolve)(options.distPath, "workers/vmThreads.js");
  }
};
var WORKER_START_TIMEOUT = 5e3;
var Pool = class {
  constructor(options, logger) {
    __publicField(this, "maxWorkers", 0);
    __publicField(this, "workerIds", /* @__PURE__ */ new Map());
    __publicField(this, "queue", []);
    __publicField(this, "activeTasks", []);
    __publicField(this, "sharedRunners", []);
    __publicField(this, "exitPromises", []);
    __publicField(this, "_isCancelling", false);
    this.options = options, this.logger = logger;
  }
  setMaxWorkers(maxWorkers) {
    this.maxWorkers = maxWorkers, this.workerIds = new Map(Array.from({ length: maxWorkers }).fill(0).map((_, i) => [i + 1, true]));
  }
  async run(task, method) {
    if (this._isCancelling) throw new Error("[vitest-pool]: Cannot run tasks while pool is cancelling");
    const testFinish = withResolvers();
    this.queue.push({
      task,
      resolver: testFinish,
      method
    }), this.schedule(), await testFinish.promise;
  }
  async schedule() {
    var _a2;
    if (this.queue.length === 0 || this.activeTasks.length >= this.maxWorkers) return;
    const { task, resolver, method } = this.queue.shift();
    try {
      let isMemoryLimitReached = false;
      const runner = this.getPoolRunner(task, method), activeTask = {
        task,
        resolver,
        method,
        cancelTask
      };
      this.activeTasks.push(activeTask);
      async function cancelTask() {
        await runner.stop(), resolver.reject(new Error("Cancelled"));
      }
      const onFinished = (message) => {
        if ((message == null ? void 0 : message.__vitest_worker_response__) && message.type === "testfileFinished") {
          if (task.memoryLimit && message.usedMemory) isMemoryLimitReached = message.usedMemory >= task.memoryLimit;
          if (message.error) this.options.state.catchError(message.error, "Test Run Error");
          runner.off("message", onFinished), resolver.resolve();
        }
      };
      if (runner.on("message", onFinished), !runner.isStarted) {
        runner.on("error", (error) => {
          resolver.reject(new Error(`[vitest-pool]: Worker ${task.worker} emitted error.`, { cause: error }));
        });
        const id = setTimeout(() => resolver.reject(new Error(`[vitest-pool]: Timeout starting ${task.worker} runner.`)), WORKER_START_TIMEOUT);
        await runner.start().finally(() => clearTimeout(id));
      }
      const poolId = runner.poolId ?? this.getWorkerId();
      runner.poolId = poolId, runner.postMessage({
        __vitest_worker_request__: true,
        type: method,
        context: task.context,
        poolId
      }), await resolver.promise;
      const index = this.activeTasks.indexOf(activeTask);
      if (index !== -1) this.activeTasks.splice(index, 1);
      if (!task.isolate && !isMemoryLimitReached && ((_a2 = this.queue[0]) == null ? void 0 : _a2.task.isolate) === false && isEqualRunner(runner, this.queue[0].task)) return this.sharedRunners.push(runner), this.schedule();
      if (!runner.isTerminated) {
        const id = setTimeout(() => this.logger.error(`[vitest-pool]: Timeout terminating ${task.worker} worker for test files ${formatFiles(task)}.`), this.options.teardownTimeout);
        this.exitPromises.push(runner.stop().then(() => clearTimeout(id)).catch((error) => this.logger.error(`[vitest-pool]: Failed to terminate ${task.worker} worker for test files ${formatFiles(task)}.`, error)));
      }
      this.freeWorkerId(poolId);
    } catch (error) {
      return resolver.reject(error);
    }
    return this.schedule();
  }
  async cancel() {
    this._isCancelling = true;
    const pendingTasks = this.queue.splice(0);
    if (pendingTasks.length) {
      const error = new Error("Cancelled");
      pendingTasks.forEach((task) => task.resolver.reject(error));
    }
    const activeTasks = this.activeTasks.splice(0);
    await Promise.all(activeTasks.map((task) => task.cancelTask()));
    const sharedRunners = this.sharedRunners.splice(0);
    await Promise.all(sharedRunners.map((runner) => runner.stop())), await Promise.all(this.exitPromises.splice(0)), this.workerIds.forEach((_, id) => this.freeWorkerId(id)), this._isCancelling = false;
  }
  async close() {
    await this.cancel();
  }
  getPoolRunner(task, method) {
    if (task.isolate === false) {
      const index = this.sharedRunners.findIndex((runner) => isEqualRunner(runner, task));
      if (index !== -1) return this.sharedRunners.splice(index, 1)[0];
    }
    const options = {
      distPath: this.options.distPath,
      project: task.project,
      method,
      environment: task.context.environment.name,
      env: task.env,
      execArgv: task.execArgv
    };
    switch (task.worker) {
      case "forks":
        return new PoolRunner(options, new ForksPoolWorker(options));
      case "vmForks":
        return new PoolRunner(options, new VmForksPoolWorker(options));
      case "threads":
        return new PoolRunner(options, new ThreadsPoolWorker(options));
      case "vmThreads":
        return new PoolRunner(options, new VmThreadsPoolWorker(options));
      case "typescript":
        return new PoolRunner(options, new TypecheckPoolWorker(options));
    }
    const customPool = task.project.config.poolRunner;
    if (customPool != null && customPool.name === task.worker) return new PoolRunner(options, customPool.createPoolWorker(options));
    throw new Error(`Runner ${task.worker} is not supported. Test files: ${formatFiles(task)}.`);
  }
  getWorkerId() {
    let workerId = 0;
    return this.workerIds.forEach((state, id) => {
      if (state && !workerId) workerId = id, this.workerIds.set(id, false);
    }), workerId;
  }
  freeWorkerId(id) {
    this.workerIds.set(id, true);
  }
};
function withResolvers() {
  let resolve3 = () => {
  }, reject = (_error) => {
  };
  const promise = new Promise((res, rej) => {
    resolve3 = res, reject = rej;
  });
  return {
    resolve: resolve3,
    reject,
    promise
  };
}
function formatFiles(task) {
  return task.context.files.map((file) => file.filepath).join(", ");
}
function isEqualRunner(runner, task) {
  if (task.isolate) throw new Error("Isolated tasks should not share runners");
  return runner.worker.name === task.worker && runner.project === task.project && runner.environment === task.context.environment.name && (!runner.worker.canReuse || runner.worker.canReuse(task));
}
var suppressWarningsPath = resolve(rootDir, "./suppress-warnings.cjs");
function getFilePoolName(project) {
  return project.config.browser.enabled ? "browser" : project.config.pool;
}
function createPool(ctx) {
  const pool = new Pool({
    distPath: ctx.distPath,
    teardownTimeout: ctx.config.teardownTimeout,
    state: ctx.state
  }, ctx.logger), options = resolveOptions(ctx), Sequencer = ctx.config.sequence.sequencer, sequencer = new Sequencer(ctx);
  let browserPool;
  async function executeTests(method, specs, invalidates) {
    if (ctx.onCancel(() => pool.cancel()), ctx.config.shard) {
      if (!ctx.config.passWithNoTests && ctx.config.shard.count > specs.length) throw new Error(`--shard <count> must be a smaller than count of test files. Resolved ${specs.length} test files for --shard=${ctx.config.shard.index}/${ctx.config.shard.count}.`);
      specs = await sequencer.shard(Array.from(specs));
    }
    const taskGroups = [];
    let workerId = 0;
    const sorted = await sequencer.sort(specs), environments = await getSpecificationsEnvironments(specs), groups = groupSpecs(sorted, environments), projectEnvs = /* @__PURE__ */ new WeakMap(), projectExecArgvs = /* @__PURE__ */ new WeakMap();
    for (const group of groups) {
      if (!group) continue;
      const taskGroup = [], browserSpecs = [];
      taskGroups.push({
        tasks: taskGroup,
        maxWorkers: group.maxWorkers,
        browserSpecs
      });
      for (const specs2 of group.specs) {
        const { project, pool: pool2 } = specs2[0];
        if (pool2 === "browser") {
          browserSpecs.push(...specs2);
          continue;
        }
        const environment = environments.get(specs2[0]);
        if (!environment) throw new Error(`Cannot find the environment. This is a bug in Vitest.`);
        let env = projectEnvs.get(project);
        if (!env) {
          if (env = {
            ...process.env,
            ...options.env,
            ...ctx.config.env,
            ...project.config.env
          }, isWindows) for (const name in env) env[name.toUpperCase()] = env[name];
          projectEnvs.set(project, env);
        }
        let execArgv = projectExecArgvs.get(project);
        if (!execArgv) execArgv = [...options.execArgv, ...project.config.execArgv], projectExecArgvs.set(project, execArgv);
        taskGroup.push({
          context: {
            pool: pool2,
            config: project.serializedConfig,
            files: specs2.map((spec) => ({
              filepath: spec.moduleId,
              testLocations: spec.testLines
            })),
            invalidates,
            environment,
            projectName: project.name,
            providedContext: project.getProvidedContext(),
            workerId: workerId++
          },
          project,
          env,
          execArgv,
          worker: pool2,
          isolate: project.config.isolate,
          memoryLimit: getMemoryLimit(ctx.config, pool2) ?? null
        });
      }
    }
    const results = [];
    for (const { tasks, browserSpecs, maxWorkers } of taskGroups) {
      pool.setMaxWorkers(maxWorkers);
      const promises3 = tasks.map(async (task) => {
        if (ctx.isCancelling) return ctx.state.cancelFiles(task.context.files, task.project);
        try {
          await pool.run(task, method);
        } catch (error) {
          if (ctx.isCancelling && error instanceof Error && error.message === "Cancelled") ctx.state.cancelFiles(task.context.files, task.project);
          else throw error;
        }
      });
      if (browserSpecs.length) if (browserPool ?? (browserPool = createBrowserPool(ctx)), method === "collect") promises3.push(browserPool.collectTests(browserSpecs));
      else promises3.push(browserPool.runTests(browserSpecs));
      const groupResults = await Promise.allSettled(promises3);
      results.push(...groupResults);
    }
    const errors = results.filter((result) => result.status === "rejected").map((result) => result.reason);
    if (errors.length > 0) throw new AggregateError(errors, "Errors occurred while running tests. For more information, see serialized error.");
  }
  return {
    name: "default",
    runTests: (files, invalidates) => executeTests("run", files, invalidates),
    collectTests: (files, invalidates) => executeTests("collect", files, invalidates),
    async close() {
      var _a2;
      await Promise.all([pool.close(), (_a2 = browserPool == null ? void 0 : browserPool.close) == null ? void 0 : _a2.call(browserPool)]);
    }
  };
}
function resolveOptions(ctx) {
  var _a2;
  const viteMajor = Number(VERSION.split(".")[0]), conditions = [...new Set(viteMajor >= 6 ? ((_a2 = ctx.vite.config.ssr.resolve) == null ? void 0 : _a2.conditions) ?? [] : [
    "production",
    "development",
    ...ctx.vite.config.resolve.conditions
  ])].filter((condition) => {
    return condition === "production" ? ctx.vite.config.isProduction : condition === "development" ? !ctx.vite.config.isProduction : true;
  }).map((condition) => {
    return viteMajor >= 6 && condition === "development|production" ? ctx.vite.config.isProduction ? "production" : "development" : condition;
  }).flatMap((c) => ["--conditions", c]);
  return {
    execArgv: [
      ...process.execArgv.filter((execArg) => execArg.startsWith("--cpu-prof") || execArg.startsWith("--heap-prof") || execArg.startsWith("--diagnostic-dir")),
      ...conditions,
      "--experimental-import-meta-resolve",
      "--require",
      suppressWarningsPath
    ],
    env: {
      TEST: "true",
      VITEST: "true",
      NODE_ENV: "development",
      VITEST_MODE: ctx.config.watch ? "WATCH" : "RUN",
      FORCE_TTY: (0, import_node_tty.isatty)(1) ? "true" : ""
    }
  };
}
function resolveMaxWorkers(project) {
  if (project.config.maxWorkers) return project.config.maxWorkers;
  if (project.vitest.config.maxWorkers) return project.vitest.config.maxWorkers;
  const numCpus = typeof nodeos.availableParallelism === "function" ? nodeos.availableParallelism() : nodeos.cpus().length;
  return project.vitest.config.watch ? Math.max(Math.floor(numCpus / 2), 1) : Math.max(numCpus - 1, 1);
}
function getMemoryLimit(config, pool) {
  if (pool !== "vmForks" && pool !== "vmThreads") return null;
  const memory = nodeos.totalmem(), limit = getWorkerMemoryLimit(config);
  return typeof memory === "number" ? stringToBytes(limit, config.watch ? memory / 2 : memory) : typeof limit === "number" && limit > 1 || typeof limit === "string" && limit.at(-1) !== "%" ? stringToBytes(limit) : null;
}
function groupSpecs(specs, environments) {
  const groups = [], sequential = {
    specs: [],
    maxWorkers: 1
  }, typechecks = {}, serializedEnvironmentOptions = /* @__PURE__ */ new Map();
  function getSerializedOptions(env) {
    const options = serializedEnvironmentOptions.get(env);
    if (options) return options;
    const serialized = JSON.stringify(env.options);
    return serializedEnvironmentOptions.set(env, serialized), serialized;
  }
  function isEqualEnvironments(a, b) {
    const aEnv = environments.get(a), bEnv = environments.get(b);
    return !aEnv && !bEnv ? true : !aEnv || !bEnv || aEnv.name !== bEnv.name ? false : !aEnv.options && !bEnv.options ? true : !aEnv.options || !bEnv.options ? false : getSerializedOptions(aEnv) === getSerializedOptions(bEnv);
  }
  specs.forEach((spec) => {
    var _a2, _b2, _c, _d;
    if (spec.pool === "typescript") {
      typechecks[_a2 = spec.project.name] || (typechecks[_a2] = []), typechecks[spec.project.name].push(spec);
      return;
    }
    const order2 = spec.project.config.sequence.groupOrder;
    if (order2 === 0 && spec.project.config.fileParallelism === false) return sequential.specs.push([spec]);
    const maxWorkers = resolveMaxWorkers(spec.project), isolate = spec.project.config.isolate;
    if (groups[order2] || (groups[order2] = {
      specs: [],
      maxWorkers
    }), groups[order2].maxWorkers !== maxWorkers) {
      const last = (_c = (_b2 = groups[order2].specs.at(-1)) == null ? void 0 : _b2.at(-1)) == null ? void 0 : _c.project.name;
      throw new Error(`Projects "${last}" and "${spec.project.name}" have different 'maxWorkers' but same 'sequence.groupOrder'.
Provide unique 'sequence.groupOrder' for them.`);
    }
    if (isolate === false && maxWorkers === 1) {
      const previous = (_d = groups[order2].specs[0]) == null ? void 0 : _d[0];
      if (previous && previous.project.name === spec.project.name && isEqualEnvironments(spec, previous)) return groups[order2].specs[0].push(spec);
    }
    groups[order2].specs.push([spec]);
  });
  let order = Math.max(0, ...groups.keys()) + 1;
  for (const projectName in typechecks) {
    const maxWorkers = resolveMaxWorkers(typechecks[projectName][0].project), previous = groups[order - 1];
    if (previous && previous.typecheck && maxWorkers !== previous.maxWorkers) order += 1;
    groups[order] || (groups[order] = {
      specs: [],
      maxWorkers,
      typecheck: true
    }), groups[order].specs.push(typechecks[projectName]);
  }
  if (sequential.specs.length) groups.push(sequential);
  return groups;
}
function serializeConfig(project) {
  var _a2, _b2;
  const { config, globalConfig } = project, viteConfig = (_a2 = project._vite) == null ? void 0 : _a2.config, optimizer = ((_b2 = config.deps) == null ? void 0 : _b2.optimizer) || {};
  return {
    environmentOptions: config.environmentOptions,
    mode: config.mode,
    isolate: config.isolate,
    fileParallelism: config.fileParallelism,
    maxWorkers: config.maxWorkers,
    base: config.base,
    logHeapUsage: config.logHeapUsage,
    runner: config.runner,
    bail: config.bail,
    defines: config.defines,
    chaiConfig: config.chaiConfig,
    setupFiles: config.setupFiles,
    allowOnly: config.allowOnly,
    testTimeout: config.testTimeout,
    testNamePattern: config.testNamePattern,
    hookTimeout: config.hookTimeout,
    clearMocks: config.clearMocks,
    mockReset: config.mockReset,
    restoreMocks: config.restoreMocks,
    unstubEnvs: config.unstubEnvs,
    unstubGlobals: config.unstubGlobals,
    maxConcurrency: config.maxConcurrency,
    pool: config.pool,
    expect: config.expect,
    snapshotSerializers: config.snapshotSerializers,
    diff: config.diff,
    retry: config.retry,
    disableConsoleIntercept: config.disableConsoleIntercept,
    root: config.root,
    name: config.name,
    globals: config.globals,
    snapshotEnvironment: config.snapshotEnvironment,
    passWithNoTests: config.passWithNoTests,
    coverage: ((coverage) => {
      var _a3;
      const htmlReporter = coverage.reporter.find(([reporterName]) => reporterName === "html"), subdir = htmlReporter && ((_a3 = htmlReporter[1]) == null ? void 0 : _a3.subdir);
      return {
        reportsDirectory: coverage.reportsDirectory,
        provider: coverage.provider,
        enabled: coverage.enabled,
        htmlReporter: htmlReporter ? { subdir } : void 0,
        customProviderModule: "customProviderModule" in coverage ? coverage.customProviderModule : void 0
      };
    })(config.coverage),
    fakeTimers: config.fakeTimers,
    deps: {
      web: config.deps.web || {},
      optimizer: Object.entries(optimizer).reduce((acc, [name, option]) => {
        return acc[name] = { enabled: (option == null ? void 0 : option.enabled) ?? false }, acc;
      }, {}),
      interopDefault: config.deps.interopDefault,
      moduleDirectories: config.deps.moduleDirectories
    },
    snapshotOptions: {
      snapshotEnvironment: void 0,
      updateSnapshot: globalConfig.snapshotOptions.updateSnapshot,
      snapshotFormat: { ...globalConfig.snapshotOptions.snapshotFormat },
      expand: config.snapshotOptions.expand ?? globalConfig.snapshotOptions.expand
    },
    sequence: {
      shuffle: globalConfig.sequence.shuffle,
      concurrent: globalConfig.sequence.concurrent,
      seed: globalConfig.sequence.seed,
      hooks: globalConfig.sequence.hooks,
      setupFiles: globalConfig.sequence.setupFiles
    },
    inspect: globalConfig.inspect,
    inspectBrk: globalConfig.inspectBrk,
    inspector: globalConfig.inspector,
    watch: config.watch,
    includeTaskLocation: config.includeTaskLocation ?? globalConfig.includeTaskLocation,
    env: {
      ...viteConfig == null ? void 0 : viteConfig.env,
      ...config.env
    },
    browser: ((browser) => {
      var _a3, _b3;
      const provider = (_a3 = project.browser) == null ? void 0 : _a3.provider;
      return {
        name: browser.name,
        headless: browser.headless,
        isolate: browser.isolate,
        fileParallelism: browser.fileParallelism,
        ui: browser.ui,
        viewport: browser.viewport,
        screenshotFailures: browser.screenshotFailures,
        locators: { testIdAttribute: browser.locators.testIdAttribute },
        providerOptions: (provider == null ? void 0 : provider.name) === "playwright" ? { actionTimeout: (_b3 = provider == null ? void 0 : provider.options) == null ? void 0 : _b3.actionTimeout } : {},
        trackUnhandledErrors: browser.trackUnhandledErrors ?? true,
        trace: browser.trace.mode
      };
    })(config.browser),
    standalone: config.standalone,
    printConsoleTrace: config.printConsoleTrace ?? globalConfig.printConsoleTrace,
    benchmark: config.benchmark && { includeSamples: config.benchmark.includeSamples },
    serializedDefines: config.browser.enabled ? "" : project._serializedDefines || ""
  };
}
async function loadGlobalSetupFiles(runner, globalSetup) {
  const globalSetupFiles = toArray(globalSetup);
  return Promise.all(globalSetupFiles.map((file) => loadGlobalSetupFile(file, runner)));
}
async function loadGlobalSetupFile(file, runner) {
  const m = await runner.import(file);
  for (const exp of [
    "default",
    "setup",
    "teardown"
  ]) if (m[exp] != null && typeof m[exp] !== "function") throw new Error(`invalid export in globalSetup file ${file}: ${exp} must be a function`);
  if (m.default) return {
    file,
    setup: m.default
  };
  if (m.setup || m.teardown) return {
    file,
    setup: m.setup,
    teardown: m.teardown
  };
  throw new Error(`invalid globalSetup file ${file}. Must export setup, teardown or have a default export`);
}
function CoverageTransform(ctx) {
  return {
    name: "vitest:coverage-transform",
    enforce: "post",
    transform(srcCode, id) {
      var _a2, _b2;
      return (_b2 = (_a2 = ctx.coverageProvider) == null ? void 0 : _a2.onFileTransform) == null ? void 0 : _b2.call(_a2, srcCode, id, this);
    }
  };
}
var jsTokens_12;
var hasRequiredJsTokens2;
function requireJsTokens2() {
  if (hasRequiredJsTokens2) return jsTokens_12;
  hasRequiredJsTokens2 = 1;
  var HashbangComment, Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]?|[^\/[\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
  Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
  Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
  StringLiteral = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
  NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
  Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
  WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
  LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
  MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
  SingleLineComment = /\/\/.*/y;
  HashbangComment = /^#!.*/;
  JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
  JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
  JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
  JSXText = /[^<>{}]+/y;
  TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
  TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
  KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
  KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
  Newline = RegExp(LineTerminatorSequence.source);
  jsTokens_12 = function* (input, { jsx = false } = {}) {
    var braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;
    ({ length } = input);
    lastIndex = 0;
    lastSignificantToken = "";
    stack = [
      { tag: "JS" }
    ];
    braces = [];
    parenNesting = 0;
    postfixIncDec = false;
    if (match = HashbangComment.exec(input)) {
      yield {
        type: "HashbangComment",
        value: match[0]
      };
      lastIndex = match[0].length;
    }
    while (lastIndex < length) {
      mode = stack[stack.length - 1];
      switch (mode.tag) {
        case "JS":
        case "JSNonExpressionParen":
        case "InterpolationInTemplate":
        case "InterpolationInJSX":
          if (input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
            RegularExpressionLiteral.lastIndex = lastIndex;
            if (match = RegularExpressionLiteral.exec(input)) {
              lastIndex = RegularExpressionLiteral.lastIndex;
              lastSignificantToken = match[0];
              postfixIncDec = true;
              yield {
                type: "RegularExpressionLiteral",
                value: match[0],
                closed: match[1] !== void 0 && match[1] !== "\\"
              };
              continue;
            }
          }
          Punctuator.lastIndex = lastIndex;
          if (match = Punctuator.exec(input)) {
            punctuator = match[0];
            nextLastIndex = Punctuator.lastIndex;
            nextLastSignificantToken = punctuator;
            switch (punctuator) {
              case "(":
                if (lastSignificantToken === "?NonExpressionParenKeyword") {
                  stack.push({
                    tag: "JSNonExpressionParen",
                    nesting: parenNesting
                  });
                }
                parenNesting++;
                postfixIncDec = false;
                break;
              case ")":
                parenNesting--;
                postfixIncDec = true;
                if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
                  stack.pop();
                  nextLastSignificantToken = "?NonExpressionParenEnd";
                  postfixIncDec = false;
                }
                break;
              case "{":
                Punctuator.lastIndex = 0;
                isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
                braces.push(isExpression);
                postfixIncDec = false;
                break;
              case "}":
                switch (mode.tag) {
                  case "InterpolationInTemplate":
                    if (braces.length === mode.nesting) {
                      Template.lastIndex = lastIndex;
                      match = Template.exec(input);
                      lastIndex = Template.lastIndex;
                      lastSignificantToken = match[0];
                      if (match[1] === "${") {
                        lastSignificantToken = "?InterpolationInTemplate";
                        postfixIncDec = false;
                        yield {
                          type: "TemplateMiddle",
                          value: match[0]
                        };
                      } else {
                        stack.pop();
                        postfixIncDec = true;
                        yield {
                          type: "TemplateTail",
                          value: match[0],
                          closed: match[1] === "`"
                        };
                      }
                      continue;
                    }
                    break;
                  case "InterpolationInJSX":
                    if (braces.length === mode.nesting) {
                      stack.pop();
                      lastIndex += 1;
                      lastSignificantToken = "}";
                      yield {
                        type: "JSXPunctuator",
                        value: "}"
                      };
                      continue;
                    }
                }
                postfixIncDec = braces.pop();
                nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
                break;
              case "]":
                postfixIncDec = true;
                break;
              case "++":
              case "--":
                nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
                break;
              case "<":
                if (jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken))) {
                  stack.push({ tag: "JSXTag" });
                  lastIndex += 1;
                  lastSignificantToken = "<";
                  yield {
                    type: "JSXPunctuator",
                    value: punctuator
                  };
                  continue;
                }
                postfixIncDec = false;
                break;
              default:
                postfixIncDec = false;
            }
            lastIndex = nextLastIndex;
            lastSignificantToken = nextLastSignificantToken;
            yield {
              type: "Punctuator",
              value: punctuator
            };
            continue;
          }
          Identifier.lastIndex = lastIndex;
          if (match = Identifier.exec(input)) {
            lastIndex = Identifier.lastIndex;
            nextLastSignificantToken = match[0];
            switch (match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
                  nextLastSignificantToken = "?NonExpressionParenKeyword";
                }
            }
            lastSignificantToken = nextLastSignificantToken;
            postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
            yield {
              type: match[1] === "#" ? "PrivateIdentifier" : "IdentifierName",
              value: match[0]
            };
            continue;
          }
          StringLiteral.lastIndex = lastIndex;
          if (match = StringLiteral.exec(input)) {
            lastIndex = StringLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            yield {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          NumericLiteral.lastIndex = lastIndex;
          if (match = NumericLiteral.exec(input)) {
            lastIndex = NumericLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            yield {
              type: "NumericLiteral",
              value: match[0]
            };
            continue;
          }
          Template.lastIndex = lastIndex;
          if (match = Template.exec(input)) {
            lastIndex = Template.lastIndex;
            lastSignificantToken = match[0];
            if (match[1] === "${") {
              lastSignificantToken = "?InterpolationInTemplate";
              stack.push({
                tag: "InterpolationInTemplate",
                nesting: braces.length
              });
              postfixIncDec = false;
              yield {
                type: "TemplateHead",
                value: match[0]
              };
            } else {
              postfixIncDec = true;
              yield {
                type: "NoSubstitutionTemplate",
                value: match[0],
                closed: match[1] === "`"
              };
            }
            continue;
          }
          break;
        case "JSXTag":
        case "JSXTagEnd":
          JSXPunctuator.lastIndex = lastIndex;
          if (match = JSXPunctuator.exec(input)) {
            lastIndex = JSXPunctuator.lastIndex;
            nextLastSignificantToken = match[0];
            switch (match[0]) {
              case "<":
                stack.push({ tag: "JSXTag" });
                break;
              case ">":
                stack.pop();
                if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
                  nextLastSignificantToken = "?JSX";
                  postfixIncDec = true;
                } else {
                  stack.push({ tag: "JSXChildren" });
                }
                break;
              case "{":
                stack.push({
                  tag: "InterpolationInJSX",
                  nesting: braces.length
                });
                nextLastSignificantToken = "?InterpolationInJSX";
                postfixIncDec = false;
                break;
              case "/":
                if (lastSignificantToken === "<") {
                  stack.pop();
                  if (stack[stack.length - 1].tag === "JSXChildren") {
                    stack.pop();
                  }
                  stack.push({ tag: "JSXTagEnd" });
                }
            }
            lastSignificantToken = nextLastSignificantToken;
            yield {
              type: "JSXPunctuator",
              value: match[0]
            };
            continue;
          }
          JSXIdentifier.lastIndex = lastIndex;
          if (match = JSXIdentifier.exec(input)) {
            lastIndex = JSXIdentifier.lastIndex;
            lastSignificantToken = match[0];
            yield {
              type: "JSXIdentifier",
              value: match[0]
            };
            continue;
          }
          JSXString.lastIndex = lastIndex;
          if (match = JSXString.exec(input)) {
            lastIndex = JSXString.lastIndex;
            lastSignificantToken = match[0];
            yield {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };
            continue;
          }
          break;
        case "JSXChildren":
          JSXText.lastIndex = lastIndex;
          if (match = JSXText.exec(input)) {
            lastIndex = JSXText.lastIndex;
            lastSignificantToken = match[0];
            yield {
              type: "JSXText",
              value: match[0]
            };
            continue;
          }
          switch (input[lastIndex]) {
            case "<":
              stack.push({ tag: "JSXTag" });
              lastIndex++;
              lastSignificantToken = "<";
              yield {
                type: "JSXPunctuator",
                value: "<"
              };
              continue;
            case "{":
              stack.push({
                tag: "InterpolationInJSX",
                nesting: braces.length
              });
              lastIndex++;
              lastSignificantToken = "?InterpolationInJSX";
              postfixIncDec = false;
              yield {
                type: "JSXPunctuator",
                value: "{"
              };
              continue;
          }
      }
      WhiteSpace.lastIndex = lastIndex;
      if (match = WhiteSpace.exec(input)) {
        lastIndex = WhiteSpace.lastIndex;
        yield {
          type: "WhiteSpace",
          value: match[0]
        };
        continue;
      }
      LineTerminatorSequence.lastIndex = lastIndex;
      if (match = LineTerminatorSequence.exec(input)) {
        lastIndex = LineTerminatorSequence.lastIndex;
        postfixIncDec = false;
        if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
          lastSignificantToken = "?NoLineTerminatorHere";
        }
        yield {
          type: "LineTerminatorSequence",
          value: match[0]
        };
        continue;
      }
      MultiLineComment.lastIndex = lastIndex;
      if (match = MultiLineComment.exec(input)) {
        lastIndex = MultiLineComment.lastIndex;
        if (Newline.test(match[0])) {
          postfixIncDec = false;
          if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
            lastSignificantToken = "?NoLineTerminatorHere";
          }
        }
        yield {
          type: "MultiLineComment",
          value: match[0],
          closed: match[1] !== void 0
        };
        continue;
      }
      SingleLineComment.lastIndex = lastIndex;
      if (match = SingleLineComment.exec(input)) {
        lastIndex = SingleLineComment.lastIndex;
        postfixIncDec = false;
        yield {
          type: "SingleLineComment",
          value: match[0]
        };
        continue;
      }
      firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
      lastIndex += firstCodePoint.length;
      lastSignificantToken = firstCodePoint;
      postfixIncDec = false;
      yield {
        type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
        value: firstCodePoint
      };
    }
    return void 0;
  };
  return jsTokens_12;
}
var jsTokensExports2 = requireJsTokens2();
var jsTokens2 = getDefaultExportFromCjs(jsTokensExports2);
function stripLiteralJsTokens(code, options) {
  const FILL = " ";
  const FILL_COMMENT = " ";
  let result = "";
  const tokens = [];
  for (const token of jsTokens2(code, { jsx: false })) {
    tokens.push(token);
    if (token.type === "SingleLineComment") {
      result += FILL_COMMENT.repeat(token.value.length);
      continue;
    }
    if (token.type === "MultiLineComment") {
      result += token.value.replace(/[^\n]/g, FILL_COMMENT);
      continue;
    }
    if (token.type === "StringLiteral") {
      if (!token.closed) {
        result += token.value;
        continue;
      }
      const body = token.value.slice(1, -1);
      {
        result += token.value[0] + FILL.repeat(body.length) + token.value[token.value.length - 1];
        continue;
      }
    }
    if (token.type === "NoSubstitutionTemplate") {
      const body = token.value.slice(1, -1);
      {
        result += `\`${body.replace(/[^\n]/g, FILL)}\``;
        continue;
      }
    }
    if (token.type === "RegularExpressionLiteral") {
      const body = token.value;
      {
        result += body.replace(/\/(.*)\/(\w?)$/g, (_, $1, $2) => `/${FILL.repeat($1.length)}/${$2}`);
        continue;
      }
    }
    if (token.type === "TemplateHead") {
      const body = token.value.slice(1, -2);
      {
        result += `\`${body.replace(/[^\n]/g, FILL)}\${`;
        continue;
      }
    }
    if (token.type === "TemplateTail") {
      const body = token.value.slice(0, -2);
      {
        result += `}${body.replace(/[^\n]/g, FILL)}\``;
        continue;
      }
    }
    if (token.type === "TemplateMiddle") {
      const body = token.value.slice(1, -2);
      {
        result += `}${body.replace(/[^\n]/g, FILL)}\${`;
        continue;
      }
    }
    result += token.value;
  }
  return {
    result,
    tokens
  };
}
function stripLiteral(code, options) {
  return stripLiteralDetailed(code).result;
}
function stripLiteralDetailed(code, options) {
  return stripLiteralJsTokens(code);
}
function MetaEnvReplacerPlugin() {
  return {
    name: "vitest:meta-env-replacer",
    enforce: "pre",
    transform(code, id) {
      if (!/\bimport\.meta\.env\b/.test(code)) return null;
      let s = null;
      const envs = stripLiteral(code).matchAll(/\bimport\.meta\.env\b/g);
      for (const env of envs) {
        s || (s = new MagicString(code));
        const startIndex = env.index, endIndex = startIndex + env[0].length;
        s.overwrite(startIndex, endIndex, `Object.assign(/* istanbul ignore next */ globalThis.__vitest_worker__?.metaEnv ?? import.meta.env)`);
      }
      if (s) return {
        code: s.toString(),
        map: s.generateMap({
          hires: "boundary",
          source: cleanUrl(id)
        })
      };
    }
  };
}
function MocksPlugins(options = {}) {
  const normalizedDistDir = normalize(distDir);
  return [hoistMocksPlugin({
    filter(id) {
      return id.includes(normalizedDistDir) ? false : options.filter ? options.filter(id) : true;
    },
    codeFrameGenerator(node, id, code) {
      return generateCodeFrame(code, 4, node.start + 1);
    }
  }), automockPlugin()];
}
function generateCssFilenameHash(filepath) {
  return hash("sha1", filepath, "hex").slice(0, 6);
}
function generateScopedClassName(strategy, name, filename) {
  if (strategy === "scoped") return null;
  if (strategy === "non-scoped") return name;
  const hash2 = generateCssFilenameHash(filename);
  return `_${name}_${hash2}`;
}
var LogLevels = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3
};
function clearScreen(logger) {
  const repeatCount = process.stdout.rows - 2, blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
  logger.clearScreen(blank);
}
var lastType;
var lastMsg;
var sameCount = 0;
var timeFormatter;
function getTimeFormatter() {
  return timeFormatter ?? (timeFormatter = new Intl.DateTimeFormat(void 0, {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  })), timeFormatter;
}
function createViteLogger(console2, level = "info", options = {}) {
  const loggedErrors = /* @__PURE__ */ new WeakSet(), { prefix = "[vite]", allowClearScreen = true } = options, thresh = LogLevels[level], canClearScreen = allowClearScreen && process.stdout.isTTY && !process.env.CI, clear = canClearScreen ? clearScreen : () => {
  };
  function format2(type, msg, options2 = {}) {
    if (options2.timestamp) {
      let tag = "";
      if (type === "info") tag = C.cyan(C.bold(prefix));
      else if (type === "warn") tag = C.yellow(C.bold(prefix));
      else tag = C.red(C.bold(prefix));
      const environment = options2.environment ? `${options2.environment} ` : "";
      return `${C.dim(getTimeFormatter().format(/* @__PURE__ */ new Date()))} ${tag} ${environment}${msg}`;
    } else return msg;
  }
  function output(type, msg, options2 = {}) {
    if (thresh >= LogLevels[type]) {
      const method = type === "info" ? "log" : type;
      if (options2.error) loggedErrors.add(options2.error);
      if (canClearScreen) if (type === lastType && msg === lastMsg) sameCount++, clear(console2), console2[method](format2(type, msg, options2), C.yellow(`(x${sameCount + 1})`));
      else {
        if (sameCount = 0, lastMsg = msg, lastType = type, options2.clear) clear(console2);
        console2[method](format2(type, msg, options2));
      }
      else console2[method](format2(type, msg, options2));
    }
  }
  const warnedMessages = /* @__PURE__ */ new Set(), logger = {
    hasWarned: false,
    info(msg, opts) {
      output("info", msg, opts);
    },
    warn(msg, opts) {
      logger.hasWarned = true, output("warn", msg, opts);
    },
    warnOnce(msg, opts) {
      warnedMessages.has(msg) || (logger.hasWarned = true, output("warn", msg, opts), warnedMessages.add(msg));
    },
    error(msg, opts) {
      logger.hasWarned = true, output("error", msg, opts);
    },
    clearScreen(type) {
      if (thresh >= LogLevels[type]) clear(console2);
    },
    hasErrorLogged(error) {
      return loggedErrors.has(error);
    }
  };
  return logger;
}
function silenceImportViteIgnoreWarning(logger) {
  return {
    ...logger,
    warn(msg, options) {
      msg.includes("The above dynamic import cannot be analyzed by Vite") || logger.warn(msg, options);
    }
  };
}
var cssLangs = "\\.(?:css|less|sass|scss|styl|stylus|pcss|postcss)(?:$|\\?)";
var cssLangRE = new RegExp(cssLangs);
var cssModuleRE = new RegExp(`\\.module${cssLangs}`);
var cssInlineRE = /[?&]inline(?:&|$)/;
function isCSS(id) {
  return cssLangRE.test(id);
}
function isCSSModule(id) {
  return cssModuleRE.test(id);
}
function isInline(id) {
  return cssInlineRE.test(id);
}
function getCSSModuleProxyReturn(strategy, filename) {
  return strategy === "non-scoped" ? "style" : `\`_\${style}_${generateCssFilenameHash(filename)}\``;
}
function CSSEnablerPlugin(ctx) {
  const shouldProcessCSS = (id) => {
    const { css } = ctx.config;
    return typeof css === "boolean" ? css : toArray(css.exclude).some((re) => re.test(id)) ? false : !!toArray(css.include).some((re) => re.test(id));
  };
  return [{
    name: "vitest:css-disable",
    enforce: "pre",
    transform(code, id) {
      if (isCSS(id) && !shouldProcessCSS(id)) return { code: "" };
    }
  }, {
    name: "vitest:css-empty-post",
    enforce: "post",
    transform(_, id) {
      var _a2;
      if (!(!isCSS(id) || shouldProcessCSS(id))) {
        if (isCSSModule(id) && !isInline(id)) {
          const scopeStrategy = typeof ctx.config.css !== "boolean" && ((_a2 = ctx.config.css.modules) == null ? void 0 : _a2.classNameStrategy) || "stable";
          return { code: `export default new Proxy(Object.create(null), {
            get(_, style) {
              return ${getCSSModuleProxyReturn(scopeStrategy, relative(ctx.config.root, id))};
            },
          })` };
        }
        return { code: 'export default ""' };
      }
    }
  }];
}
var metaUrlLength = 15;
var locationString = "self.location".padEnd(metaUrlLength, " ");
function NormalizeURLPlugin() {
  return {
    name: "vitest:normalize-url",
    enforce: "post",
    transform(code) {
      if (this.environment.name !== "client" || !code.includes("new URL") || !code.includes("import.meta.url")) return;
      const cleanString = stripLiteral(code), assetImportMetaUrlRE = /\bnew\s+URL\s*\(\s*(?:'[^']+'|"[^"]+"|`[^`]+`)\s*,\s*(?:'' \+ )?import\.meta\.url\s*(?:,\s*)?\)/g;
      let updatedCode = code, match;
      while (match = assetImportMetaUrlRE.exec(cleanString)) {
        const { 0: exp, index } = match, metaUrlIndex = index + exp.indexOf("import.meta.url");
        updatedCode = updatedCode.slice(0, metaUrlIndex) + locationString + updatedCode.slice(metaUrlIndex + metaUrlLength);
      }
      return {
        code: updatedCode,
        map: null
      };
    }
  };
}
function VitestOptimizer() {
  return {
    name: "vitest:normalize-optimizer",
    config: {
      order: "post",
      handler(viteConfig) {
        var _a2;
        const testConfig = viteConfig.test || {}, root = resolve(viteConfig.root || process.cwd()), name = (_a2 = viteConfig.test) == null ? void 0 : _a2.name, label = typeof name === "string" ? name : (name == null ? void 0 : name.label) || "";
        viteConfig.cacheDir = VitestCache.resolveCacheDir(resolve(root || process.cwd()), testConfig.cache != null && testConfig.cache !== false ? testConfig.cache.dir : viteConfig.cacheDir, label);
      }
    }
  };
}
function resolveOptimizerConfig(_testOptions, viteOptions) {
  const testOptions = _testOptions || {};
  let optimizeDeps;
  if (testOptions.enabled !== true) testOptions.enabled ?? (testOptions.enabled = false), optimizeDeps = {
    disabled: true,
    entries: []
  };
  else {
    const currentInclude = testOptions.include || (viteOptions == null ? void 0 : viteOptions.include) || [], exclude = [
      "vitest",
      "react",
      "vue",
      ...testOptions.exclude || (viteOptions == null ? void 0 : viteOptions.exclude) || []
    ], runtime = currentInclude.filter((n2) => n2.endsWith("jsx-dev-runtime") || n2.endsWith("jsx-runtime"));
    exclude.push(...runtime);
    const include = (testOptions.include || (viteOptions == null ? void 0 : viteOptions.include) || []).filter((n2) => !exclude.includes(n2));
    optimizeDeps = {
      ...viteOptions,
      ...testOptions,
      noDiscovery: true,
      disabled: false,
      entries: [],
      exclude,
      include
    };
  }
  if (optimizeDeps.disabled) optimizeDeps.noDiscovery = true, optimizeDeps.include = [];
  return delete optimizeDeps.disabled, optimizeDeps;
}
function deleteDefineConfig(viteConfig) {
  const defines = {};
  if (viteConfig.define) delete viteConfig.define["import.meta.vitest"], delete viteConfig.define["process.env"], delete viteConfig.define.process, delete viteConfig.define.global;
  for (const key in viteConfig.define) {
    const val = viteConfig.define[key];
    let replacement;
    try {
      replacement = typeof val === "string" ? JSON.parse(val) : val;
    } catch {
      continue;
    }
    if (key.startsWith("import.meta.env.")) {
      const envKey = key.slice(16);
      process.env[envKey] = replacement, delete viteConfig.define[key];
    } else if (key.startsWith("process.env.")) {
      const envKey = key.slice(12);
      process.env[envKey] = replacement, delete viteConfig.define[key];
    } else if (!key.includes(".")) defines[key] = replacement, delete viteConfig.define[key];
  }
  return defines;
}
function resolveFsAllow(projectRoot, rootConfigFile) {
  return rootConfigFile ? [
    dirname(rootConfigFile),
    searchForWorkspaceRoot(projectRoot),
    rootDir
  ] : [searchForWorkspaceRoot(projectRoot), rootDir];
}
function getDefaultResolveOptions() {
  return {
    mainFields: [],
    conditions: getDefaultServerConditions()
  };
}
function getDefaultServerConditions() {
  return Number(VERSION.split(".")[0]) >= 6 ? DEFAULT_SERVER_CONDITIONS.filter((c) => c !== "module") : ["node"];
}
function ModuleRunnerTransform() {
  return {
    name: "vitest:environments-module-runner",
    config: {
      order: "post",
      handler(config) {
        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
        const testConfig = config.test || {};
        config.environments ?? (config.environments = {});
        const names = new Set(Object.keys(config.environments));
        names.add("client"), names.add("ssr");
        const pool = (_a2 = config.test) == null ? void 0 : _a2.pool;
        if (pool === "vmForks" || pool === "vmThreads") names.add("__vitest_vm__");
        let moduleDirectories = ((_b2 = testConfig.deps) == null ? void 0 : _b2.moduleDirectories) || [];
        const envModuleDirectories = process.env.VITEST_MODULE_DIRECTORIES || process.env.npm_config_VITEST_MODULE_DIRECTORIES;
        if (envModuleDirectories) moduleDirectories.push(...envModuleDirectories.split(","));
        if (moduleDirectories = moduleDirectories.map((dir) => {
          if (dir[0] !== "/") dir = `/${dir}`;
          if (!dir.endsWith("/")) dir += "/";
          return normalize(dir);
        }), !moduleDirectories.includes("/node_modules/")) moduleDirectories.push("/node_modules/");
        testConfig.deps ?? (testConfig.deps = {}), testConfig.deps.moduleDirectories = moduleDirectories;
        const external = [], noExternal = [];
        let noExternalAll;
        for (const name of names) {
          (_c = config.environments)[name] ?? (_c[name] = {});
          const environment = config.environments[name];
          if (environment.dev ?? (environment.dev = {}), name === "__vitest_vm__") environment.dev.moduleRunnerTransform = false, environment.consumer = "client";
          else environment.dev.moduleRunnerTransform = true;
          environment.dev.preTransformRequests = false, environment.keepProcessEnv = true;
          const resolveExternal = name === "client" ? (_d = config.resolve) == null ? void 0 : _d.external : [], resolveNoExternal = name === "client" ? (_e = config.resolve) == null ? void 0 : _e.noExternal : [], topLevelResolveOptions = {};
          if (resolveExternal != null) topLevelResolveOptions.external = resolveExternal;
          if (resolveNoExternal != null) topLevelResolveOptions.noExternal = resolveNoExternal;
          const currentResolveOptions = mergeConfig(topLevelResolveOptions, environment.resolve || {}), envNoExternal = resolveViteResolveOptions("noExternal", currentResolveOptions, moduleDirectories);
          if (envNoExternal === true) noExternalAll = true;
          else if (envNoExternal.length) noExternal.push(...envNoExternal);
          else if (name === "client" || name === "ssr") {
            const deprecatedNoExternal = resolveDeprecatedOptions(name === "client" ? (_f = config.resolve) == null ? void 0 : _f.noExternal : (_g = config.ssr) == null ? void 0 : _g.noExternal, moduleDirectories);
            if (deprecatedNoExternal === true) noExternalAll = true;
            else noExternal.push(...deprecatedNoExternal);
          }
          const envExternal = resolveViteResolveOptions("external", currentResolveOptions, moduleDirectories);
          if (envExternal !== true && envExternal.length) external.push(...envExternal);
          else if (name === "client" || name === "ssr") {
            const deprecatedExternal = resolveDeprecatedOptions(name === "client" ? (_h = config.resolve) == null ? void 0 : _h.external : (_i = config.ssr) == null ? void 0 : _i.external, moduleDirectories);
            if (deprecatedExternal !== true) external.push(...deprecatedExternal);
          }
          if (environment.resolve ?? (environment.resolve = {}), environment.resolve.external = [...import_node_module5.builtinModules, ...import_node_module5.builtinModules.map((m) => `node:${m}`)], environment.resolve.noExternal = true, name === "__vitest_vm__" || name === "__vitest__") continue;
          const currentOptimizeDeps = environment.optimizeDeps || (name === "client" ? config.optimizeDeps : name === "ssr" ? (_j = config.ssr) == null ? void 0 : _j.optimizeDeps : void 0), optimizeDeps = resolveOptimizerConfig((_l = (_k = testConfig.deps) == null ? void 0 : _k.optimizer) == null ? void 0 : _l[name], currentOptimizeDeps);
          if (name === "client") config.optimizeDeps = optimizeDeps, environment.optimizeDeps = void 0;
          else if (name === "ssr") config.ssr ?? (config.ssr = {}), config.ssr.optimizeDeps = optimizeDeps, environment.optimizeDeps = void 0;
          else environment.optimizeDeps = optimizeDeps;
        }
        if (testConfig.server ?? (testConfig.server = {}), (_m = testConfig.server).deps ?? (_m.deps = {}), testConfig.server.deps.inline !== true) {
          if (noExternalAll) testConfig.server.deps.inline = true;
          else if (noExternal.length) (_n = testConfig.server.deps).inline ?? (_n.inline = []), testConfig.server.deps.inline.push(...noExternal);
        }
        if (external.length) (_o = testConfig.server.deps).external ?? (_o.external = []), testConfig.server.deps.external.push(...external);
      }
    }
  };
}
function resolveViteResolveOptions(key, options, moduleDirectories) {
  return Array.isArray(options[key]) ? options[key].some((p2) => p2 === true) ? true : options[key].map((dep) => processWildcard(dep, moduleDirectories)) : typeof options[key] === "string" || options[key] instanceof RegExp ? [options[key]].map((dep) => processWildcard(dep, moduleDirectories)) : typeof options[key] === "boolean" ? true : [];
}
function resolveDeprecatedOptions(options, moduleDirectories) {
  return options === true ? true : Array.isArray(options) ? options.map((dep) => processWildcard(dep, moduleDirectories)) : options == null ? [] : [processWildcard(options, moduleDirectories)];
}
function processWildcard(dep, moduleDirectories) {
  if (typeof dep !== "string") return dep;
  if (typeof dep === "string" && dep.includes("*")) {
    const directories = (moduleDirectories || ["/node_modules/"]).map((r) => escapeRegExp(r));
    return new RegExp(`(${directories.join("|")})${dep.replace(/\*/g, "[\\w/]+")}`);
  }
  return dep;
}
function VitestProjectResolver(ctx) {
  const plugin = {
    name: "vitest:resolve-root",
    enforce: "pre",
    config: {
      order: "post",
      handler() {
        return { base: "/" };
      }
    },
    async resolveId(id, _, { ssr }) {
      if (id === "vitest" || id.startsWith("@vitest/") || id.startsWith("vitest/")) return await ctx.vite.pluginContainer.resolveId(id, void 0, {
        skip: /* @__PURE__ */ new Set([plugin]),
        ssr
      });
    }
  };
  return plugin;
}
function VitestCoreResolver(ctx) {
  return {
    name: "vitest:resolve-core",
    enforce: "pre",
    config: {
      order: "post",
      handler() {
        return { base: "/" };
      }
    },
    async resolveId(id) {
      if (id === "vitest") return resolve(distDir, "index.js");
      if (id.startsWith("@vitest/") || id.startsWith("vitest/"))
        return this.resolve(id, join(ctx.config.root, "index.html"), { skipSelf: true });
    }
  };
}
function WorkspaceVitestPlugin(project, options) {
  return [
    {
      name: "vitest:project:name",
      enforce: "post",
      config(viteConfig) {
        var _a2, _b2, _c, _d, _e, _f, _g, _h;
        const testConfig = viteConfig.test || {};
        let { label: name, color } = typeof testConfig.name === "string" ? { label: testConfig.name } : {
          label: "",
          ...testConfig.name
        };
        if (!name) if (typeof options.workspacePath === "string") {
          const dir = options.workspacePath.endsWith("/") ? options.workspacePath.slice(0, -1) : dirname(options.workspacePath), pkgJsonPath = resolve(dir, "package.json");
          if ((0, import_node_fs6.existsSync)(pkgJsonPath)) name = JSON.parse((0, import_node_fs6.readFileSync)(pkgJsonPath, "utf-8")).name;
          if (typeof name !== "string" || !name) name = basename(dir);
        } else name = options.workspacePath.toString();
        const isBrowserEnabled2 = ((_b2 = (_a2 = viteConfig.test) == null ? void 0 : _a2.browser) == null ? void 0 : _b2.enabled) ?? (((_c = viteConfig.test) == null ? void 0 : _c.browser) && ((_d = project.vitest._cliOptions.browser) == null ? void 0 : _d.enabled)), workspaceNames = [name], browser = viteConfig.test.browser || {};
        if (isBrowserEnabled2 && browser.name && !((_e = browser.instances) == null ? void 0 : _e.length))
          workspaceNames.push(name ? `${name} (${browser.name})` : browser.name);
        if ((_h = (_g = (_f = viteConfig.test) == null ? void 0 : _f.browser) == null ? void 0 : _g.instances) == null ? void 0 : _h.forEach((instance) => {
          if (instance.name ?? (instance.name = name ? `${name} (${instance.browser})` : instance.browser), isBrowserEnabled2) workspaceNames.push(instance.name);
        }), project.vitest.config.project.length) {
          if (!workspaceNames.some((name2) => {
            return project.vitest.matchesProjectFilter(name2);
          })) throw new VitestFilteredOutProjectError();
        }
        return {
          base: "/",
          environments: { __vitest__: { dev: {} } },
          test: { name: {
            label: name,
            color
          } }
        };
      }
    },
    {
      name: "vitest:project",
      enforce: "pre",
      options() {
        this.meta.watchMode = false;
      },
      config(viteConfig) {
        var _a2, _b2, _c, _d, _e;
        const defines = deleteDefineConfig(viteConfig), testConfig = viteConfig.test || {}, root = testConfig.root || viteConfig.root || options.root, resolveOptions2 = getDefaultResolveOptions();
        let config = {
          root,
          define: { "process.env.NODE_ENV": "process.env.NODE_ENV" },
          resolve: {
            ...resolveOptions2,
            alias: testConfig.alias
          },
          server: {
            watch: null,
            open: false,
            hmr: false,
            ws: false,
            preTransformRequests: false,
            middlewareMode: true,
            fs: { allow: resolveFsAllow(project.vitest.config.root, project.vitest.vite.config.configFile) }
          },
          environments: { ssr: { resolve: resolveOptions2 } },
          test: {}
        };
        if ("rolldownVersion" in node_exports) config = {
          ...config,
          oxc: viteConfig.oxc === false ? false : { target: ((_a2 = viteConfig.oxc) == null ? void 0 : _a2.target) || "node18" }
        };
        else config = {
          ...config,
          esbuild: viteConfig.esbuild === false ? false : {
            target: ((_b2 = viteConfig.esbuild) == null ? void 0 : _b2.target) || "node18",
            sourcemap: "external",
            legalComments: "inline"
          }
        };
        config.test.defines = defines;
        const classNameStrategy = typeof testConfig.css !== "boolean" && ((_d = (_c = testConfig.css) == null ? void 0 : _c.modules) == null ? void 0 : _d.classNameStrategy) || "stable";
        if (classNameStrategy !== "scoped") {
          if (config.css ?? (config.css = {}), (_e = config.css).modules ?? (_e.modules = {}), config.css.modules) config.css.modules.generateScopedName = (name, filename) => {
            const root2 = project.config.root;
            return generateScopedClassName(classNameStrategy, name, relative(root2, filename));
          };
        }
        return config.customLogger = createViteLogger(project.vitest.logger, viteConfig.logLevel || "warn", { allowClearScreen: false }), config.customLogger = silenceImportViteIgnoreWarning(config.customLogger), config;
      }
    },
    {
      name: "vitest:project:server",
      enforce: "post",
      async configureServer(server) {
        const options2 = deepMerge({}, configDefaults, server.config.test || {});
        await project._configureServer(options2, server), await server.watcher.close();
      }
    },
    MetaEnvReplacerPlugin(),
    ...CSSEnablerPlugin(project),
    CoverageTransform(project.vitest),
    ...MocksPlugins(),
    VitestProjectResolver(project.vitest),
    VitestOptimizer(),
    NormalizeURLPlugin(),
    ModuleRunnerTransform()
  ];
}
var VitestResolver = class {
  constructor(cacheDir, config) {
    __publicField(this, "options");
    __publicField(this, "externalizeCache", /* @__PURE__ */ new Map());
    var _a2, _b2;
    this.options = {
      moduleDirectories: config.deps.moduleDirectories,
      inlineFiles: config.setupFiles.flatMap((file) => {
        if (file.startsWith("file://")) return file;
        const resolvedId = resolve(file);
        return [resolvedId, (0, import_node_url4.pathToFileURL)(resolvedId).href];
      }),
      cacheDir,
      inline: (_a2 = config.server.deps) == null ? void 0 : _a2.inline,
      external: (_b2 = config.server.deps) == null ? void 0 : _b2.external
    };
  }
  shouldExternalize(file) {
    return shouldExternalize(normalizeId(file), this.options, this.externalizeCache);
  }
};
function normalizeId(id) {
  if (id.startsWith("/@fs/")) id = id.slice(isWindows ? 5 : 4);
  return id;
}
var BUILTIN_EXTENSIONS = /* @__PURE__ */ new Set([
  ".mjs",
  ".cjs",
  ".node",
  ".wasm"
]);
var ESM_EXT_RE = /\.(es|esm|esm-browser|esm-bundler|es6|module)\.js$/;
var ESM_FOLDER_RE = /\/(es|esm)\/(.*\.js)$/;
var defaultInline = [
  /virtual:/,
  /\.[mc]?ts$/,
  /[?&](init|raw|url|inline)\b/,
  KNOWN_ASSET_RE,
  /^(?!.*node_modules).*\.mjs$/,
  /^(?!.*node_modules).*\.cjs\.js$/,
  /vite\w*\/dist\/client\/env.mjs/
];
var depsExternal = [/\/node_modules\/.*\.cjs\.js$/, /\/node_modules\/.*\.mjs$/];
function guessCJSversion(id) {
  if (id.match(ESM_EXT_RE)) {
    for (const i of [
      id.replace(ESM_EXT_RE, ".mjs"),
      id.replace(ESM_EXT_RE, ".umd.js"),
      id.replace(ESM_EXT_RE, ".cjs.js"),
      id.replace(ESM_EXT_RE, ".js")
    ]) if ((0, import_node_fs6.existsSync)(i)) return i;
  }
  if (id.match(ESM_FOLDER_RE)) {
    for (const i of [
      id.replace(ESM_FOLDER_RE, "/umd/$1"),
      id.replace(ESM_FOLDER_RE, "/cjs/$1"),
      id.replace(ESM_FOLDER_RE, "/lib/$1"),
      id.replace(ESM_FOLDER_RE, "/$1")
    ]) if ((0, import_node_fs6.existsSync)(i)) return i;
  }
}
async function isValidNodeImport(id) {
  const extension2 = extname(id);
  if (BUILTIN_EXTENSIONS.has(extension2)) return true;
  if (extension2 !== ".js") return false;
  if (id = id.replace("file:///", ""), findNearestPackageData(dirname(id)).type === "module") return true;
  if (/\.(?:\w+-)?esm?(?:-\w+)?\.js$|\/esm?\//.test(id)) return false;
  try {
    await init2;
    const code = await import_node_fs6.promises.readFile(id, "utf8"), [, , , hasModuleSyntax] = parse(code);
    return !hasModuleSyntax;
  } catch {
    return false;
  }
}
async function shouldExternalize(id, options, cache2) {
  if (!cache2.has(id)) cache2.set(id, _shouldExternalize(id, options));
  return cache2.get(id);
}
async function _shouldExternalize(id, options) {
  if ((0, import_node_module5.isBuiltin)(id) || id.startsWith("data:") || /^(?:https?:)?\/\//.test(id)) return id;
  const moduleDirectories = (options == null ? void 0 : options.moduleDirectories) || ["/node_modules/"];
  if (matchPattern(id, moduleDirectories, options == null ? void 0 : options.inline) || (options == null ? void 0 : options.inlineFiles) && (options == null ? void 0 : options.inlineFiles.includes(id))) return false;
  if (matchPattern(id, moduleDirectories, options == null ? void 0 : options.external) || (options == null ? void 0 : options.cacheDir) && id.includes(options.cacheDir)) return id;
  const isLibraryModule = moduleDirectories.some((dir) => id.includes(dir));
  return id = isLibraryModule && (options == null ? void 0 : options.fallbackCJS) ? guessCJSversion(id) || id : id, matchPattern(id, moduleDirectories, defaultInline) ? false : matchPattern(id, moduleDirectories, depsExternal) || isLibraryModule && await isValidNodeImport(id) ? id : false;
}
function matchPattern(id, moduleDirectories, patterns) {
  if (patterns == null) return false;
  if (patterns === true) return true;
  for (const ex of patterns) if (typeof ex === "string") {
    if (moduleDirectories.some((dir) => id.includes(join(dir, ex)))) return true;
  } else if (ex.test(id)) return true;
  return false;
}
var TestSpecification = class {
  constructor(project, moduleId, pool, testLines) {
    /**
    * The task ID associated with the test module.
    */
    __publicField(this, "taskId");
    /**
    * The test project that the module belongs to.
    */
    __publicField(this, "project");
    /**
    * The ID of the module in the Vite module graph. It is usually an absolute file path.
    */
    __publicField(this, "moduleId");
    /**
    * The current test pool. It's possible to have multiple pools in a single test project with `poolMatchGlob` and `typecheck.enabled`.
    * @experimental In Vitest 4, the project will only support a single pool and this property will be removed.
    */
    __publicField(this, "pool");
    /**
    * Line numbers of the test locations to run.
    */
    __publicField(this, "testLines");
    const name = project.config.name, hashName = pool !== "typescript" ? name : name ? `${name}:__typecheck__` : "__typecheck__";
    this.taskId = generateFileHash(relative(project.config.root, moduleId), hashName), this.project = project, this.moduleId = moduleId, this.pool = pool, this.testLines = testLines;
  }
  /**
  * Test module associated with the specification.
  */
  get testModule() {
    const task = this.project.vitest.state.idMap.get(this.taskId);
    if (task) return this.project.vitest.state.getReportedEntity(task);
  }
  toJSON() {
    return [
      {
        name: this.project.config.name,
        root: this.project.config.root
      },
      this.moduleId,
      {
        pool: this.pool,
        testLines: this.testLines
      }
    ];
  }
};
async function createViteServer(inlineConfig) {
  const error = console.error;
  console.error = (...args) => {
    typeof args[0] === "string" && args[0].includes("WebSocket server error:") || error(...args);
  };
  const server = await createServer$2(inlineConfig);
  return console.error = error, server;
}
var TestProject = class _TestProject {
  constructor(vitest, options, tmpDir) {
    /**
    * The global Vitest instance.
    */
    __publicField(this, "vitest");
    /**
    * Resolved global configuration. If there are no workspace projects, this will be the same as `config`.
    */
    __publicField(this, "globalConfig");
    /**
    * Browser instance if the browser is enabled. This is initialized when the tests run for the first time.
    */
    __publicField(this, "browser");
    /**
    * Temporary directory for the project. This is unique for each project. Vitest stores transformed content here.
    */
    __publicField(this, "tmpDir");
    /** @internal */
    __publicField(this, "typechecker");
    /** @internal */
    __publicField(this, "_config");
    /** @internal */
    __publicField(this, "_vite");
    /** @internal */
    __publicField(this, "_hash");
    /** @internal */
    __publicField(this, "_resolver");
    /** @internal */
    __publicField(this, "_fetcher");
    /** @internal */
    __publicField(this, "_serializedDefines");
    /** @inetrnal */
    __publicField(this, "testFilesList", null);
    __publicField(this, "runner");
    __publicField(this, "closingPromise");
    __publicField(this, "typecheckFilesList", null);
    __publicField(this, "_globalSetups");
    __publicField(this, "_provided", {});
    // "provide" is a property, not a method to keep the context when destructed in the global setup,
    // making it a method would be a breaking change, and can be done in Vitest 3 at minimum
    /**
    * Provide a value to the test context. This value will be available to all tests with `inject`.
    */
    __publicField(this, "provide", (key, value) => {
      try {
        structuredClone(value);
      } catch (err) {
        throw new Error(`Cannot provide "${key}" because it's not serializable.`, { cause: err });
      }
      this._provided[key] = value;
    });
    __publicField(this, "_parentBrowser");
    /** @internal */
    __publicField(this, "_parent");
    /** @internal */
    __publicField(this, "_initParentBrowser", deduped(async (childProject) => {
      if (!this.isBrowserEnabled() || this._parentBrowser) return;
      const provider = this.config.browser.provider || childProject.config.browser.provider;
      if (provider == null) throw new Error(`Proider was not specified in the "browser.provider" setting. Please, pass down playwright(), webdriverio() or preview() from "@vitest/browser-playwright", "@vitest/browser-webdriverio" or "@vitest/browser-preview" package respectively.`);
      if (typeof provider.serverFactory !== "function") throw new TypeError(`The browser provider options do not return a "serverFactory" function. Are you using the latest "@vitest/browser-${provider.name}" package?`);
      const browser = await provider.serverFactory({
        project: this,
        mocksPlugins: (options) => MocksPlugins(options),
        metaEnvReplacer: () => MetaEnvReplacerPlugin(),
        coveragePlugin: () => CoverageTransform(this.vitest)
      });
      if (this._parentBrowser = browser, this.config.browser.ui) setup(this.vitest, browser.vite);
    }));
    /** @internal */
    __publicField(this, "_initBrowserServer", deduped(async () => {
      var _a2, _b2;
      if (await ((_a2 = this._parent) == null ? void 0 : _a2._initParentBrowser(this)), !this.browser && ((_b2 = this._parent) == null ? void 0 : _b2._parentBrowser)) this.browser = this._parent._parentBrowser.spawn(this), await this.vitest.report("onBrowserInit", this);
    }));
    /** @internal */
    __publicField(this, "_initBrowserProvider", deduped(async () => {
      var _a2, _b2;
      if (!(!this.isBrowserEnabled() || ((_a2 = this.browser) == null ? void 0 : _a2.provider))) {
        if (!this.browser) await this._initBrowserServer();
        await ((_b2 = this.browser) == null ? void 0 : _b2.initBrowserProvider(this));
      }
    }));
    this.options = options, this.vitest = vitest, this.globalConfig = vitest.config, this.tmpDir = tmpDir || join((0, import_node_os3.tmpdir)(), nanoid());
  }
  /**
  * The unique hash of this project. This value is consistent between the reruns.
  *
  * It is based on the root of the project (not consistent between OS) and its name.
  */
  get hash() {
    if (!this._hash) throw new Error("The server was not set. It means that `project.hash` was called before the Vite server was established.");
    return this._hash;
  }
  /**
  * Get the provided context. The project context is merged with the global context.
  */
  getProvidedContext() {
    return this.isRootProject() ? this._provided : {
      ...this.vitest.getRootProject().getProvidedContext(),
      ...this._provided
    };
  }
  /**
  * Creates a new test specification. Specifications describe how to run tests.
  * @param moduleId The file path
  */
  createSpecification(moduleId, locations, pool) {
    return new TestSpecification(this, moduleId, pool || getFilePoolName(this), locations);
  }
  toJSON() {
    return {
      name: this.name,
      serializedConfig: this.serializedConfig,
      context: this.getProvidedContext()
    };
  }
  /**
  * Vite's dev server instance. Every workspace project has its own server.
  */
  get vite() {
    if (!this._vite) throw new Error("The server was not set. It means that `project.vite` was called before the Vite server was established.");
    return Object.defineProperty(this, "vite", {
      configurable: true,
      writable: true,
      value: this._vite
    }), this._vite;
  }
  /**
  * Resolved project configuration.
  */
  get config() {
    if (!this._config) throw new Error("The config was not set. It means that `project.config` was called before the Vite server was established.");
    return this._config;
  }
  /**
  * The name of the project or an empty string if not set.
  */
  get name() {
    return this.config.name || "";
  }
  /**
  * The color used when reporting tasks of this project.
  */
  get color() {
    return this.config.color;
  }
  /**
  * Serialized project configuration. This is the config that tests receive.
  */
  get serializedConfig() {
    return this._serializeOverriddenConfig();
  }
  /**
  * Check if this is the root project. The root project is the one that has the root config.
  */
  isRootProject() {
    return this.vitest.getRootProject() === this;
  }
  /** @internal */
  async _initializeGlobalSetup() {
    var _a2;
    if (!this._globalSetups) {
      this._globalSetups = await loadGlobalSetupFiles(this.runner, this.config.globalSetup);
      for (const globalSetupFile of this._globalSetups) {
        const teardown = await ((_a2 = globalSetupFile.setup) == null ? void 0 : _a2.call(globalSetupFile, this));
        if (teardown == null || !!globalSetupFile.teardown) continue;
        if (typeof teardown !== "function") throw new TypeError(`invalid return value in globalSetup file ${globalSetupFile.file}. Must return a function`);
        globalSetupFile.teardown = teardown;
      }
    }
  }
  onTestsRerun(cb) {
    this.vitest.onTestsRerun(cb);
  }
  /** @internal */
  async _teardownGlobalSetup() {
    var _a2;
    if (this._globalSetups) for (const globalSetupFile of [...this._globalSetups].reverse()) await ((_a2 = globalSetupFile.teardown) == null ? void 0 : _a2.call(globalSetupFile));
  }
  /**
  * Get all files in the project that match the globs in the config and the filters.
  * @param filters String filters to match the test files.
  */
  async globTestFiles(filters = []) {
    const dir = this.config.dir || this.config.root, { include, exclude, includeSource } = this.config, typecheck = this.config.typecheck, [testFiles, typecheckTestFiles] = await Promise.all([typecheck.enabled && typecheck.only ? [] : this.globAllTestFiles(include, exclude, includeSource, dir), typecheck.enabled ? this.typecheckFilesList || this.globFiles(typecheck.include, typecheck.exclude, dir) : []]);
    return this.typecheckFilesList = typecheckTestFiles, {
      testFiles: this.filterFiles(testFiles, filters, dir),
      typecheckTestFiles: this.filterFiles(typecheckTestFiles, filters, dir)
    };
  }
  async globAllTestFiles(include, exclude, includeSource, cwd) {
    if (this.testFilesList) return this.testFilesList;
    const testFiles = await this.globFiles(include, exclude, cwd);
    if (includeSource == null ? void 0 : includeSource.length) {
      const files = await this.globFiles(includeSource, exclude, cwd);
      await Promise.all(files.map(async (file) => {
        try {
          const code = await import_node_fs6.promises.readFile(file, "utf-8");
          if (this.isInSourceTestCode(code)) testFiles.push(file);
        } catch {
          return null;
        }
      }));
    }
    return this.testFilesList = testFiles, testFiles;
  }
  isBrowserEnabled() {
    return isBrowserEnabled(this.config);
  }
  markTestFile(testPath) {
    var _a2;
    (_a2 = this.testFilesList) == null ? void 0 : _a2.push(testPath);
  }
  /** @internal */
  _removeCachedTestFile(testPath) {
    if (this.testFilesList) this.testFilesList = this.testFilesList.filter((file) => file !== testPath);
  }
  /**
  * Returns if the file is a test file. Requires `.globTestFiles()` to be called first.
  * @internal
  */
  _isCachedTestFile(testPath) {
    return !!this.testFilesList && this.testFilesList.includes(testPath);
  }
  /**
  * Returns if the file is a typecheck test file. Requires `.globTestFiles()` to be called first.
  * @internal
  */
  _isCachedTypecheckFile(testPath) {
    return !!this.typecheckFilesList && this.typecheckFilesList.includes(testPath);
  }
  /** @internal */
  async globFiles(include, exclude, cwd) {
    return (await glob(include, {
      dot: true,
      cwd,
      ignore: exclude,
      expandDirectories: false
    })).map((file) => slash(import_node_path2.default.resolve(cwd, file)));
  }
  /**
  * Test if a file matches the test globs. This does the actual glob matching if the test is not cached, unlike `isCachedTestFile`.
  */
  matchesTestGlob(moduleId, source) {
    var _a2;
    if (this._isCachedTestFile(moduleId)) return true;
    const relativeId = relative(this.config.dir || this.config.root, moduleId);
    if (import_picomatch2.default.isMatch(relativeId, this.config.exclude)) return false;
    if (import_picomatch2.default.isMatch(relativeId, this.config.include)) return this.markTestFile(moduleId), true;
    if (((_a2 = this.config.includeSource) == null ? void 0 : _a2.length) && import_picomatch2.default.isMatch(relativeId, this.config.includeSource)) {
      const code = (source == null ? void 0 : source()) || (0, import_node_fs6.readFileSync)(moduleId, "utf-8");
      if (this.isInSourceTestCode(code)) return this.markTestFile(moduleId), true;
    }
    return false;
  }
  isInSourceTestCode(code) {
    return code.includes("import.meta.vitest");
  }
  filterFiles(testFiles, filters, dir) {
    if (filters.length && process.platform === "win32") filters = filters.map((f) => slash(f));
    return filters.length ? testFiles.filter((t) => {
      const testFile = relative(dir, t).toLocaleLowerCase();
      return filters.some((f) => {
        if (isAbsolute(f) && t.startsWith(f)) return true;
        const relativePath = f.endsWith("/") ? join(relative(dir, f), "/") : relative(dir, f);
        return testFile.includes(f.toLocaleLowerCase()) || testFile.includes(relativePath.toLocaleLowerCase());
      });
    }) : testFiles;
  }
  /**
  * Closes the project and all associated resources. This can only be called once; the closing promise is cached until the server restarts.
  * If the resources are needed again, create a new project.
  */
  close() {
    var _a2, _b2, _c;
    if (!this.closingPromise) this.closingPromise = Promise.all([
      (_a2 = this.vite) == null ? void 0 : _a2.close(),
      (_b2 = this.typechecker) == null ? void 0 : _b2.stop(),
      (_c = this.browser) == null ? void 0 : _c.close(),
      this.clearTmpDir()
    ].filter(Boolean)).then(() => {
      if (!this.runner.isClosed()) return this.runner.close();
    }).then(() => {
      this._provided = {}, this._vite = void 0;
    });
    return this.closingPromise;
  }
  /**
  * Import a file using Vite module runner.
  * @param moduleId The ID of the module in Vite module graph
  */
  import(moduleId) {
    return this.runner.import(moduleId);
  }
  _setHash() {
    this._hash = generateHash2(this._config.root + this._config.name);
  }
  /** @internal */
  async _configureServer(options, server) {
    var _a2;
    for (const _providedKey in this._config = resolveConfig$1(this.vitest, {
      ...options,
      coverage: this.vitest.config.coverage
    }, server.config), this._setHash(), this.config.provide) {
      const providedKey = _providedKey;
      this.provide(providedKey, this.config.provide[providedKey]);
    }
    this.closingPromise = void 0, this._resolver = new VitestResolver(server.config.cacheDir, this._config), this._vite = server, this._serializedDefines = createDefinesScript(server.config.define), this._fetcher = createFetchModuleFunction(this._resolver, this.tmpDir, {
      dumpFolder: this.config.dumpDir,
      readFromDump: ((_a2 = this.config.server.debug) == null ? void 0 : _a2.load) ?? process.env.VITEST_DEBUG_LOAD_DUMP != null
    });
    const environment = server.environments.__vitest__;
    this.runner = new ServerModuleRunner(environment, this._fetcher, this._config);
  }
  _serializeOverriddenConfig() {
    const config = serializeConfig(this);
    return this.vitest.configOverride ? deepMerge(config, this.vitest.configOverride) : config;
  }
  async clearTmpDir() {
    try {
      await (0, import_promises3.rm)(this.tmpDir, { recursive: true });
    } catch {
    }
  }
  /** @internal */
  _provideObject(context) {
    for (const _providedKey in context) {
      const providedKey = _providedKey;
      this.provide(providedKey, context[providedKey]);
    }
  }
  /** @internal */
  static _createBasicProject(vitest) {
    const project = new _TestProject(vitest, void 0, vitest._tmpDir);
    return project.runner = vitest.runner, project._vite = vitest.vite, project._config = vitest.config, project._resolver = vitest._resolver, project._fetcher = vitest._fetcher, project._serializedDefines = createDefinesScript(vitest.vite.config.define), project._setHash(), project._provideObject(vitest.config.provide), project;
  }
  /** @internal */
  static _cloneBrowserProject(parent, config) {
    const clone = new _TestProject(parent.vitest, void 0, parent.tmpDir);
    return clone.runner = parent.runner, clone._vite = parent._vite, clone._resolver = parent._resolver, clone._fetcher = parent._fetcher, clone._config = config, clone._setHash(), clone._parent = parent, clone._serializedDefines = parent._serializedDefines, clone._provideObject(config.provide), clone;
  }
};
function deduped(cb) {
  let _promise;
  return (...args) => {
    if (!_promise) _promise = cb(...args).finally(() => {
      _promise = void 0;
    });
    return _promise;
  };
}
async function initializeProject(workspacePath, ctx, options) {
  var _a2;
  const project = new TestProject(ctx, options), { configFile, ...restOptions } = options, config = {
    ...restOptions,
    configFile,
    configLoader: ctx.vite.config.inlineConfig.configLoader,
    mode: ((_a2 = options.test) == null ? void 0 : _a2.mode) || options.mode || ctx.config.mode,
    plugins: [...options.plugins || [], WorkspaceVitestPlugin(project, {
      ...options,
      workspacePath
    })]
  };
  return await createViteServer(config), project;
}
function generateHash2(str) {
  let hash2 = 0;
  if (str.length === 0) return `${hash2}`;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + char, hash2 = hash2 & hash2;
  }
  return `${hash2}`;
}
var CONFIG_REGEXP = /^vite(?:st)?(?:\.\w+)?\.config\./;
async function resolveProjects(vitest, cliOptions, workspaceConfigPath, projectsDefinition, names) {
  var _a2, _b2;
  const { configFiles: configFiles2, projectConfigs, nonConfigDirectories } = await resolveTestProjectConfigs(vitest, workspaceConfigPath, projectsDefinition), cliOverrides = [
    "logHeapUsage",
    "allowOnly",
    "sequence",
    "testTimeout",
    "pool",
    "update",
    "globals",
    "expandSnapshotDiff",
    "disableConsoleIntercept",
    "retry",
    "testNamePattern",
    "passWithNoTests",
    "bail",
    "isolate",
    "printConsoleTrace",
    "inspect",
    "inspectBrk",
    "fileParallelism"
  ].reduce((acc, name) => {
    if (name in cliOptions) acc[name] = cliOptions[name];
    return acc;
  }, {}), projectPromises = [], fileProjects = [...configFiles2, ...nonConfigDirectories], concurrent = limitConcurrency(((_b2 = (_a2 = import_node_os3.default).availableParallelism) == null ? void 0 : _b2.call(_a2)) || import_node_os3.default.cpus().length || 5);
  projectConfigs.forEach((options, index) => {
    const configRoot = vitest.config.root, configFile = typeof options.extends === "string" ? resolve(configRoot, options.extends) : options.extends === true ? vitest.vite.config.configFile || false : false, root = options.root ? resolve(configRoot, options.root) : vitest.config.root;
    projectPromises.push(concurrent(() => initializeProject(index, vitest, {
      ...options,
      root,
      configFile,
      test: {
        ...options.test,
        ...cliOverrides
      }
    })));
  });
  for (const path3 of fileProjects) {
    if (vitest.vite.config.configFile === path3) {
      const project = getDefaultTestProject(vitest);
      if (project) projectPromises.push(Promise.resolve(project));
      continue;
    }
    const configFile = path3.endsWith("/") ? false : path3, root = path3.endsWith("/") ? path3 : dirname(path3);
    projectPromises.push(concurrent(() => initializeProject(path3, vitest, {
      root,
      configFile,
      test: cliOverrides
    })));
  }
  if (!projectPromises.length) throw new Error([
    "No projects were found. Make sure your configuration is correct. ",
    vitest.config.project.length ? `The filter matched no projects: ${vitest.config.project.join(", ")}. ` : "",
    `The projects definition: ${JSON.stringify(projectsDefinition, null, 4)}.`
  ].join(""));
  const resolvedProjectsPromises = await Promise.allSettled(projectPromises), errors = [], resolvedProjects = [];
  for (const result of resolvedProjectsPromises) if (result.status === "rejected") {
    if (result.reason instanceof VitestFilteredOutProjectError)
      continue;
    errors.push(result.reason);
  } else resolvedProjects.push(result.value);
  if (errors.length) throw new AggregateError(errors, "Failed to initialize projects. There were errors during projects setup. See below for more details.");
  for (const project of resolvedProjects) {
    const name = project.name;
    if (names.has(name)) {
      const duplicate = resolvedProjects.find((p2) => p2.name === name && p2 !== project), filesError = fileProjects.length ? [
        "\n\nYour config matched these files:\n",
        fileProjects.map((p2) => ` - ${relative(vitest.config.root, p2)}`).join("\n"),
        "\n\n"
      ].join("") : " ";
      throw new Error([
        `Project name "${name}"`,
        project.vite.config.configFile ? ` from "${relative(vitest.config.root, project.vite.config.configFile)}"` : "",
        " is not unique.",
        (duplicate == null ? void 0 : duplicate.vite.config.configFile) ? ` The project is already defined by "${relative(vitest.config.root, duplicate.vite.config.configFile)}".` : "",
        filesError,
        "All projects should have unique names. Make sure your configuration is correct."
      ].join(""));
    }
    names.add(name);
  }
  return resolveBrowserProjects(vitest, names, resolvedProjects);
}
async function resolveBrowserProjects(vitest, names, resolvedProjects) {
  const removeProjects = /* @__PURE__ */ new Set();
  return resolvedProjects.forEach((project) => {
    if (!project.config.browser.enabled) return;
    const instances = project.config.browser.instances || [];
    if (instances.length === 0) {
      removeProjects.add(project);
      return;
    }
    const originalName = project.config.name, filteredInstances = vitest.matchesProjectFilter(originalName) ? instances : instances.filter((instance) => {
      const newName = instance.name;
      return vitest.matchesProjectFilter(newName);
    });
    if (!filteredInstances.length) {
      removeProjects.add(project);
      return;
    }
    filteredInstances.forEach((config, index) => {
      var _a2, _b2, _c, _d, _e, _f;
      const browser = config.browser;
      if (!browser) {
        const nth = index + 1, ending = nth === 2 ? "nd" : nth === 3 ? "rd" : "th";
        throw new Error(`The browser configuration must have a "browser" property. The ${nth}${ending} item in "browser.instances" doesn't have it. Make sure your${originalName ? ` "${originalName}"` : ""} configuration is correct.`);
      }
      const name = config.name;
      if (name == null) throw new Error(`The browser configuration must have a "name" property. This is a bug in Vitest. Please, open a new issue with reproduction`);
      if (((_a2 = config.provider) == null ? void 0 : _a2.name) != null && ((_b2 = project.config.browser.provider) == null ? void 0 : _b2.name) != null && ((_c = config.provider) == null ? void 0 : _c.name) !== ((_d = project.config.browser.provider) == null ? void 0 : _d.name)) throw new Error(`The instance cannot have a different provider from its parent. The "${name}" instance specifies "${(_e = config.provider) == null ? void 0 : _e.name}" provider, but its parent has a "${(_f = project.config.browser.provider) == null ? void 0 : _f.name}" provider.`);
      if (names.has(name)) throw new Error([
        `Cannot define a nested project for a ${browser} browser. The project name "${name}" was already defined. `,
        'If you have multiple instances for the same browser, make sure to define a custom "name". ',
        "All projects should have unique names. Make sure your configuration is correct."
      ].join(""));
      names.add(name);
      const clonedConfig = cloneConfig(project, config);
      clonedConfig.name = name;
      const clone = TestProject._cloneBrowserProject(project, clonedConfig);
      resolvedProjects.push(clone);
    }), removeProjects.add(project);
  }), resolvedProjects.filter((project) => !removeProjects.has(project));
}
function cloneConfig(project, { browser, ...config }) {
  const { locators, viewport, testerHtmlPath, headless, screenshotDirectory, screenshotFailures, browser: _browser, name, provider, ...overrideConfig } = config, currentConfig = project.config.browser, clonedConfig = deepClone(project.config);
  return mergeConfig({
    ...clonedConfig,
    browser: {
      ...project.config.browser,
      locators: locators ? { testIdAttribute: locators.testIdAttribute ?? currentConfig.locators.testIdAttribute } : project.config.browser.locators,
      viewport: viewport ?? currentConfig.viewport,
      testerHtmlPath: testerHtmlPath ?? currentConfig.testerHtmlPath,
      screenshotDirectory: screenshotDirectory ?? currentConfig.screenshotDirectory,
      screenshotFailures: screenshotFailures ?? currentConfig.screenshotFailures,
      headless: headless ?? currentConfig.headless,
      provider: provider ?? currentConfig.provider,
      name: browser,
      instances: []
    },
    include: overrideConfig.include && overrideConfig.include.length > 0 ? [] : clonedConfig.include,
    exclude: overrideConfig.exclude && overrideConfig.exclude.length > 0 ? [] : clonedConfig.exclude,
    includeSource: overrideConfig.includeSource && overrideConfig.includeSource.length > 0 ? [] : clonedConfig.includeSource
  }, overrideConfig);
}
async function resolveTestProjectConfigs(vitest, workspaceConfigPath, projectsDefinition) {
  const projectsOptions = [], projectsConfigFiles = [], projectsGlobMatches = [], nonConfigProjectDirectories = [];
  for (const definition of projectsDefinition) if (typeof definition === "string") {
    const stringOption = definition.replace("<rootDir>", vitest.config.root);
    if (!isDynamicPattern(stringOption)) {
      const file = resolve(vitest.config.root, stringOption);
      if (!(0, import_node_fs6.existsSync)(file)) {
        const note = "Projects definition";
        throw new Error(`${note} references a non-existing file or a directory: ${file}`);
      }
      const stats = (0, import_node_fs6.statSync)(file);
      if (stats.isFile()) {
        const name = basename(file);
        if (!CONFIG_REGEXP.test(name)) throw new Error(`The file "${relative(vitest.config.root, file)}" must start with "vitest.config"/"vite.config" or match the pattern "(vitest|vite).*.config.*" to be a valid project config.`);
        projectsConfigFiles.push(file);
      } else if (stats.isDirectory()) {
        const configFile = resolveDirectoryConfig(file);
        if (configFile) projectsConfigFiles.push(configFile);
        else {
          const directory = file.at(-1) === "/" ? file : `${file}/`;
          nonConfigProjectDirectories.push(directory);
        }
      } else
        throw new TypeError(`Unexpected file type: ${file}`);
    } else projectsGlobMatches.push(stringOption);
  } else if (typeof definition === "function") projectsOptions.push(await definition({
    command: vitest.vite.config.command,
    mode: vitest.vite.config.mode,
    isPreview: false,
    isSsrBuild: false
  }));
  else projectsOptions.push(await definition);
  if (projectsGlobMatches.length) {
    const globOptions = {
      absolute: true,
      dot: true,
      onlyFiles: false,
      cwd: vitest.config.root,
      expandDirectories: false,
      ignore: [
        "**/node_modules/**",
        "**/*.timestamp-*",
        "**/.DS_Store"
      ]
    };
    (await glob(projectsGlobMatches, globOptions)).forEach((path3) => {
      if (path3.endsWith("/")) {
        const configFile = resolveDirectoryConfig(path3);
        if (configFile) projectsConfigFiles.push(configFile);
        else nonConfigProjectDirectories.push(path3);
      } else {
        const name = basename(path3);
        if (!CONFIG_REGEXP.test(name)) throw new Error(`The projects glob matched a file "${relative(vitest.config.root, path3)}", but it should also either start with "vitest.config"/"vite.config" or match the pattern "(vitest|vite).*.config.*".`);
        projectsConfigFiles.push(path3);
      }
    });
  }
  const projectConfigFiles = Array.from(new Set(projectsConfigFiles));
  return {
    projectConfigs: projectsOptions,
    nonConfigDirectories: nonConfigProjectDirectories,
    configFiles: projectConfigFiles
  };
}
function resolveDirectoryConfig(directory) {
  const files = new Set((0, import_node_fs6.readdirSync)(directory)), configFile = configFiles.find((file) => files.has(file));
  return configFile ? resolve(directory, configFile) : null;
}
function getDefaultTestProject(vitest) {
  const filter = vitest.config.project, project = vitest._ensureRootProject();
  return !filter.length || getPotentialProjectNames(project).some((p2) => vitest.matchesProjectFilter(p2)) ? project : null;
}
function getPotentialProjectNames(project) {
  const names = [project.name];
  if (project.config.browser.instances) names.push(...project.config.browser.instances.map((i) => i.name));
  else if (project.config.browser.name) names.push(project.config.browser.name);
  return names;
}
async function loadCustomReporterModule(path3, runner) {
  let customReporterModule;
  try {
    customReporterModule = await runner.import(path3);
  } catch (customReporterModuleError) {
    throw new Error(`Failed to load custom Reporter from ${path3}`, { cause: customReporterModuleError });
  }
  if (customReporterModule.default === null || customReporterModule.default === void 0) throw new Error(`Custom reporter loaded from ${path3} was not the default export`);
  return customReporterModule.default;
}
function createReporters(reporterReferences, ctx) {
  const runner = ctx.runner, promisedReporters = reporterReferences.map(async (referenceOrInstance) => {
    if (Array.isArray(referenceOrInstance)) {
      const [reporterName, reporterOptions] = referenceOrInstance;
      if (reporterName === "html") return await ctx.packageInstaller.ensureInstalled("@vitest/ui", ctx.config.root, ctx.version), new (await loadCustomReporterModule("@vitest/ui/reporter", runner))(reporterOptions);
      if (reporterName in ReportersMap) {
        const BuiltinReporter = ReportersMap[reporterName];
        return new BuiltinReporter(reporterOptions);
      } else return new (await loadCustomReporterModule(reporterName, runner))(reporterOptions);
    }
    return referenceOrInstance;
  });
  return Promise.all(promisedReporters);
}
function createBenchmarkReporters(reporterReferences, runner) {
  const promisedReporters = reporterReferences.map(async (referenceOrInstance) => {
    if (typeof referenceOrInstance === "string") if (referenceOrInstance in BenchmarkReportsMap) {
      const BuiltinReporter = BenchmarkReportsMap[referenceOrInstance];
      return new BuiltinReporter();
    } else return new (await loadCustomReporterModule(referenceOrInstance, runner))();
    return referenceOrInstance;
  });
  return Promise.all(promisedReporters);
}
function parseFilter(filter) {
  const colonIndex = filter.lastIndexOf(":");
  if (colonIndex === -1) return { filename: filter };
  const [parsedFilename, lineNumber] = [filter.substring(0, colonIndex), filter.substring(colonIndex + 1)];
  if (lineNumber.match(/^\d+$/)) return {
    filename: parsedFilename,
    lineNumber: Number.parseInt(lineNumber)
  };
  if (lineNumber.match(/^\d+-\d+$/)) throw new RangeLocationFilterProvidedError(filter);
  return { filename: filter };
}
function groupFilters(filters) {
  const groupedFilters_ = groupBy(filters, (f) => f.filename);
  return Object.fromEntries(Object.entries(groupedFilters_).map((entry) => {
    const [filename, filters2] = entry, testLocations = filters2.map((f) => f.lineNumber);
    return [filename, testLocations.filter((l) => l !== void 0)];
  }));
}
var VitestSpecifications = class {
  constructor(vitest) {
    __publicField(this, "_cachedSpecs", /* @__PURE__ */ new Map());
    this.vitest = vitest;
  }
  getModuleSpecifications(moduleId) {
    const _cached = this.getCachedSpecifications(moduleId);
    if (_cached) return _cached;
    const specs = [];
    for (const project of this.vitest.projects) {
      if (project._isCachedTestFile(moduleId)) specs.push(project.createSpecification(moduleId));
      if (project._isCachedTypecheckFile(moduleId)) specs.push(project.createSpecification(moduleId, [], "typescript"));
    }
    return specs.forEach((spec) => this.ensureSpecificationCached(spec)), specs;
  }
  async getRelevantTestSpecifications(filters = []) {
    return this.filterTestsBySource(await this.globTestSpecifications(filters));
  }
  async globTestSpecifications(filters = []) {
    const files = [], dir = process.cwd(), parsedFilters = filters.map((f) => parseFilter(f));
    if (!this.vitest.config.includeTaskLocation && parsedFilters.some((f) => f.lineNumber !== void 0)) throw new IncludeTaskLocationDisabledError();
    const testLines = groupFilters(parsedFilters.map((f) => ({
      ...f,
      filename: resolve(dir, f.filename)
    }))), testLocHasMatch = {};
    return await Promise.all(this.vitest.projects.map(async (project) => {
      const { testFiles, typecheckTestFiles } = await project.globTestFiles(parsedFilters.map((f) => f.filename));
      testFiles.forEach((file) => {
        const lines = testLines[file];
        testLocHasMatch[file] = true;
        const spec = project.createSpecification(file, lines);
        this.ensureSpecificationCached(spec), files.push(spec);
      }), typecheckTestFiles.forEach((file) => {
        const lines = testLines[file];
        testLocHasMatch[file] = true;
        const spec = project.createSpecification(file, lines, "typescript");
        this.ensureSpecificationCached(spec), files.push(spec);
      });
    })), Object.entries(testLines).forEach(([filepath, loc]) => {
      if (loc.length !== 0 && !testLocHasMatch[filepath]) throw new LocationFilterFileNotFoundError(relative(dir, filepath));
    }), files;
  }
  clearCache(moduleId) {
    if (moduleId) this._cachedSpecs.delete(moduleId);
    else this._cachedSpecs.clear();
  }
  getCachedSpecifications(moduleId) {
    return this._cachedSpecs.get(moduleId);
  }
  ensureSpecificationCached(spec) {
    const file = spec.moduleId, specs = this._cachedSpecs.get(file) || [], index = specs.findIndex((_s) => _s.project === spec.project && _s.pool === spec.pool);
    if (index === -1) specs.push(spec), this._cachedSpecs.set(file, specs);
    else specs.splice(index, 1, spec);
    return specs;
  }
  async filterTestsBySource(specs) {
    if (this.vitest.config.changed && !this.vitest.config.related) {
      const { VitestGit } = await import("./git.BFNcloKD-DD5KBGK2.js"), related2 = await new VitestGit(this.vitest.config.root).findChangedFiles({ changedSince: this.vitest.config.changed });
      if (!related2) throw process.exitCode = 1, new GitNotFoundError();
      this.vitest.config.related = Array.from(new Set(related2));
    }
    const related = this.vitest.config.related;
    if (!related) return specs;
    const forceRerunTriggers = this.vitest.config.forceRerunTriggers, matcher = forceRerunTriggers.length ? (0, import_picomatch2.default)(forceRerunTriggers) : void 0;
    if (matcher && related.some((file) => matcher(file))) return specs;
    if (!this.vitest.config.watch && !related.length) return [];
    const testGraphs = await Promise.all(specs.map(async (spec) => {
      const deps = await this.getTestDependencies(spec);
      return [spec, deps];
    })), runningTests = [];
    for (const [specification, deps] of testGraphs)
      if (related.some((path3) => path3 === specification.moduleId || deps.has(path3))) runningTests.push(specification);
    return runningTests;
  }
  async getTestDependencies(spec, deps = /* @__PURE__ */ new Set()) {
    const addImports = async (project, filepath) => {
      var _a2;
      if (deps.has(filepath)) return;
      deps.add(filepath);
      const transformed = ((_a2 = project.vite.environments.ssr.moduleGraph.getModuleById(filepath)) == null ? void 0 : _a2.transformResult) || await project.vite.environments.ssr.transformRequest(filepath);
      if (!transformed) return;
      const dependencies = [...transformed.deps || [], ...transformed.dynamicDeps || []];
      await Promise.all(dependencies.map(async (dep) => {
        const fsPath = dep.startsWith("/@fs/") ? dep.slice(isWindows ? 5 : 4) : join(project.config.root, dep);
        if (!fsPath.includes("node_modules") && !deps.has(fsPath) && (0, import_node_fs6.existsSync)(fsPath)) await addImports(project, fsPath);
      }));
    };
    return await addImports(spec.project, spec.moduleId), deps.delete(spec.moduleId), deps;
  }
};
var ReportedTaskImplementation = class {
  /** @internal */
  constructor(task, project) {
    /**
    * Task instance.
    * @internal
    */
    __publicField(this, "task");
    /**
    * The project associated with the test or suite.
    */
    __publicField(this, "project");
    /**
    * Unique identifier.
    * This ID is deterministic and will be the same for the same test across multiple runs.
    * The ID is based on the project name, module url and test order.
    */
    __publicField(this, "id");
    /**
    * Location in the module where the test or suite is defined.
    */
    __publicField(this, "location");
    this.task = task, this.project = project, this.id = task.id, this.location = task.location;
  }
  /**
  * Checks if the test did not fail the suite.
  * If the test is not finished yet or was skipped, it will return `true`.
  */
  ok() {
    const result = this.task.result;
    return !result || result.state !== "fail";
  }
  /**
  * Custom metadata that was attached to the test during its execution.
  */
  meta() {
    return this.task.meta;
  }
  /**
  * Creates a new reported task instance and stores it in the project's state for future use.
  * @internal
  */
  static register(task, project) {
    const state = new this(task, project);
    return storeTask(project, task, state), state;
  }
};
var _fullName;
var TestCase = class extends ReportedTaskImplementation {
  /** @internal */
  constructor(task, project) {
    super(task, project);
    __privateAdd(this, _fullName);
    __publicField(this, "type", "test");
    /**
    * Direct reference to the test module where the test or suite is defined.
    */
    __publicField(this, "module");
    /**
    * Name of the test.
    */
    __publicField(this, "name");
    /**
    * Options that the test was initiated with.
    */
    __publicField(this, "options");
    /**
    * Parent suite. If the test was called directly inside the module, the parent will be the module itself.
    */
    __publicField(this, "parent");
    this.name = task.name, this.module = getReportedTask(project, task.file);
    const suite = this.task.suite;
    if (suite) this.parent = getReportedTask(project, suite);
    else this.parent = this.module;
    this.options = buildOptions(task);
  }
  /**
  * Full name of the test including all parent suites separated with `>`.
  */
  get fullName() {
    if (__privateGet(this, _fullName) === void 0) if (this.parent.type !== "module") __privateSet(this, _fullName, `${this.parent.fullName} > ${this.name}`);
    else __privateSet(this, _fullName, this.name);
    return __privateGet(this, _fullName);
  }
  /**
  * Test results.
  * - **pending**: Test was collected, but didn't finish running yet.
  * - **passed**: Test passed successfully
  * - **failed**: Test failed to execute
  * - **skipped**: Test was skipped during collection or dynamically with `ctx.skip()`.
  */
  result() {
    const result = this.task.result, mode = (result == null ? void 0 : result.state) || this.task.mode;
    if (!result && (mode === "skip" || mode === "todo")) return {
      state: "skipped",
      note: void 0,
      errors: void 0
    };
    if (!result || result.state === "run" || result.state === "queued") return {
      state: "pending",
      errors: void 0
    };
    const state = result.state === "fail" ? "failed" : result.state === "pass" ? "passed" : "skipped";
    return state === "skipped" ? {
      state,
      note: result.note,
      errors: void 0
    } : state === "passed" ? {
      state,
      errors: result.errors
    } : {
      state,
      errors: result.errors || []
    };
  }
  /**
  * Test annotations added via the `task.annotate` API during the test execution.
  */
  annotations() {
    return [...this.task.annotations];
  }
  /**
  * Useful information about the test like duration, memory usage, etc.
  * Diagnostic is only available after the test has finished.
  */
  diagnostic() {
    const result = this.task.result;
    if (!result || !result.startTime) return;
    const duration = result.duration || 0;
    return {
      slow: duration > this.project.globalConfig.slowTestThreshold,
      heap: result.heap,
      duration,
      startTime: result.startTime,
      retryCount: result.retryCount ?? 0,
      repeatCount: result.repeatCount ?? 0,
      flaky: !!result.retryCount && result.state === "pass" && result.retryCount > 0
    };
  }
};
_fullName = new WeakMap();
var _task, _project;
var TestCollection = class {
  constructor(task, project) {
    __privateAdd(this, _task);
    __privateAdd(this, _project);
    __privateSet(this, _task, task), __privateSet(this, _project, project);
  }
  /**
  * Returns the test or suite at a specific index.
  */
  at(index) {
    if (index < 0) index = this.size + index;
    return getReportedTask(__privateGet(this, _project), __privateGet(this, _task).tasks[index]);
  }
  /**
  * The number of tests and suites in the collection.
  */
  get size() {
    return __privateGet(this, _task).tasks.length;
  }
  /**
  * Returns the collection in array form for easier manipulation.
  */
  array() {
    return Array.from(this);
  }
  /**
  * Filters all tests that are part of this collection and its children.
  */
  *allTests(state) {
    for (const child of this) if (child.type === "suite") yield* child.children.allTests(state);
    else if (state) {
      const testState = child.result().state;
      if (state === testState) yield child;
    } else yield child;
  }
  /**
  * Filters only the tests that are part of this collection.
  */
  *tests(state) {
    for (const child of this) {
      if (child.type !== "test") continue;
      if (state) {
        const testState = child.result().state;
        if (state === testState) yield child;
      } else yield child;
    }
  }
  /**
  * Filters only the suites that are part of this collection.
  */
  *suites() {
    for (const child of this) if (child.type === "suite") yield child;
  }
  /**
  * Filters all suites that are part of this collection and its children.
  */
  *allSuites() {
    for (const child of this) if (child.type === "suite") yield child, yield* child.children.allSuites();
  }
  *[Symbol.iterator]() {
    for (const task of __privateGet(this, _task).tasks) yield getReportedTask(__privateGet(this, _project), task);
  }
};
_task = new WeakMap();
_project = new WeakMap();
var SuiteImplementation = class extends ReportedTaskImplementation {
  /** @internal */
  constructor(task, project) {
    super(task, project);
    /**
    * Collection of suites and tests that are part of this suite.
    */
    __publicField(this, "children");
    this.children = new TestCollection(task, project);
  }
  /**
  * Errors that happened outside of the test run during collection, like syntax errors.
  */
  errors() {
    var _a2;
    return ((_a2 = this.task.result) == null ? void 0 : _a2.errors) || [];
  }
};
var _fullName2;
var TestSuite = class extends SuiteImplementation {
  /** @internal */
  constructor(task, project) {
    super(task, project);
    __privateAdd(this, _fullName2);
    __publicField(this, "type", "suite");
    /**
    * Name of the test or the suite.
    */
    __publicField(this, "name");
    /**
    * Direct reference to the test module where the test or suite is defined.
    */
    __publicField(this, "module");
    /**
    * Parent suite. If suite was called directly inside the module, the parent will be the module itself.
    */
    __publicField(this, "parent");
    /**
    * Options that suite was initiated with.
    */
    __publicField(this, "options");
    this.name = task.name, this.module = getReportedTask(project, task.file);
    const suite = this.task.suite;
    if (suite) this.parent = getReportedTask(project, suite);
    else this.parent = this.module;
    this.options = buildOptions(task);
  }
  /**
  * Checks the running state of the suite.
  */
  state() {
    return getSuiteState(this.task);
  }
  /**
  * Full name of the suite including all parent suites separated with `>`.
  */
  get fullName() {
    if (__privateGet(this, _fullName2) === void 0) if (this.parent.type !== "module") __privateSet(this, _fullName2, `${this.parent.fullName} > ${this.name}`);
    else __privateSet(this, _fullName2, this.name);
    return __privateGet(this, _fullName2);
  }
};
_fullName2 = new WeakMap();
var TestModule = class extends SuiteImplementation {
  /** @internal */
  constructor(task, project) {
    super(task, project);
    __publicField(this, "type", "module");
    /**
    * This is usually an absolute UNIX file path.
    * It can be a virtual ID if the file is not on the disk.
    * This value corresponds to the ID in the Vite's module graph.
    */
    __publicField(this, "moduleId");
    /**
    * Module id relative to the project. This is the same as `task.name`.
    */
    __publicField(this, "relativeModuleId");
    this.moduleId = task.filepath, this.relativeModuleId = task.name;
  }
  /**
  * Checks the running state of the test file.
  */
  state() {
    var _a2;
    return ((_a2 = this.task.result) == null ? void 0 : _a2.state) === "queued" ? "queued" : getSuiteState(this.task);
  }
  /**
  * Useful information about the module like duration, memory usage, etc.
  * If the module was not executed yet, all diagnostic values will return `0`.
  */
  diagnostic() {
    var _a2, _b2;
    const setupDuration = this.task.setupDuration || 0, collectDuration = this.task.collectDuration || 0, prepareDuration = this.task.prepareDuration || 0, environmentSetupDuration = this.task.environmentLoad || 0, duration = ((_a2 = this.task.result) == null ? void 0 : _a2.duration) || 0, heap = (_b2 = this.task.result) == null ? void 0 : _b2.heap, importDurations = this.task.importDurations ?? {};
    return {
      environmentSetupDuration,
      prepareDuration,
      collectDuration,
      setupDuration,
      duration,
      heap,
      importDurations
    };
  }
};
function buildOptions(task) {
  return {
    each: task.each,
    fails: task.type === "test" && task.fails,
    concurrent: task.concurrent,
    shuffle: task.shuffle,
    retry: task.retry,
    repeats: task.repeats,
    mode: task.mode
  };
}
function storeTask(project, runnerTask, reportedTask) {
  project.vitest.state.reportedTasksMap.set(runnerTask, reportedTask);
}
function getReportedTask(project, runnerTask) {
  const reportedTask = project.vitest.state.getReportedEntity(runnerTask);
  if (!reportedTask) throw new Error(`Task instance was not found for ${runnerTask.type} "${runnerTask.name}"`);
  return reportedTask;
}
function getSuiteState(task) {
  var _a2;
  const mode = task.mode, state = (_a2 = task.result) == null ? void 0 : _a2.state;
  if (mode === "skip" || mode === "todo" || state === "skip" || state === "todo") return "skipped";
  if (state == null || state === "run" || state === "only") return "pending";
  if (state === "fail") return "failed";
  if (state === "pass") return "passed";
  throw new Error(`Unknown suite state: ${state}`);
}
function experimental_getRunnerTask(entity) {
  return entity.task;
}
function isAggregateError(err) {
  return typeof AggregateError !== "undefined" && err instanceof AggregateError ? true : err instanceof Error && "errors" in err;
}
var StateManager = class {
  constructor(options) {
    __publicField(this, "filesMap", /* @__PURE__ */ new Map());
    __publicField(this, "pathsSet", /* @__PURE__ */ new Set());
    __publicField(this, "idMap", /* @__PURE__ */ new Map());
    __publicField(this, "taskFileMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "errorsSet", /* @__PURE__ */ new Set());
    __publicField(this, "reportedTasksMap", /* @__PURE__ */ new WeakMap());
    __publicField(this, "blobs");
    __publicField(this, "transformTime", 0);
    __publicField(this, "metadata", {});
    __publicField(this, "onUnhandledError");
    /** @internal */
    __publicField(this, "_data", {
      browserLastPort: defaultBrowserPort,
      timeoutIncreased: false
    });
    this.onUnhandledError = options.onUnhandledError;
  }
  catchError(error, type) {
    if (isAggregateError(error)) return error.errors.forEach((error2) => this.catchError(error2, type));
    if (typeof error === "object" && error !== null) error.type = type;
    else error = {
      type,
      message: error
    };
    const _error = error;
    if (_error && typeof _error === "object" && _error.code === "VITEST_PENDING") {
      const task = this.idMap.get(_error.taskId);
      if (task) task.mode = "skip", task.result ?? (task.result = { state: "skip" }), task.result.state = "skip", task.result.note = _error.note;
      return;
    }
    if (!this.onUnhandledError || this.onUnhandledError(error) !== false) this.errorsSet.add(error);
  }
  clearErrors() {
    this.errorsSet.clear();
  }
  getUnhandledErrors() {
    return Array.from(this.errorsSet.values());
  }
  getPaths() {
    return Array.from(this.pathsSet);
  }
  /**
  * Return files that were running or collected.
  */
  getFiles(keys2) {
    return keys2 ? keys2.map((key) => this.filesMap.get(key)).flat().filter((file) => file && !file.local) : Array.from(this.filesMap.values()).flat().filter((file) => !file.local).sort((f1, f2) => {
      var _a2, _b2, _c;
      return ((_a2 = f1.meta) == null ? void 0 : _a2.typecheck) && ((_b2 = f2.meta) == null ? void 0 : _b2.typecheck) ? 0 : ((_c = f1.meta) == null ? void 0 : _c.typecheck) ? -1 : 1;
    });
  }
  getTestModules(keys2) {
    return this.getFiles(keys2).map((file) => this.getReportedEntity(file));
  }
  getFilepaths() {
    return Array.from(this.filesMap.keys());
  }
  getFailedFilepaths() {
    return this.getFiles().filter((i) => {
      var _a2;
      return ((_a2 = i.result) == null ? void 0 : _a2.state) === "fail";
    }).map((i) => i.filepath);
  }
  collectPaths(paths = []) {
    paths.forEach((path3) => {
      this.pathsSet.add(path3);
    });
  }
  collectFiles(project, files = []) {
    files.forEach((file) => {
      const existing = this.filesMap.get(file.filepath) || [], otherFiles = existing.filter((i) => i.projectName !== file.projectName || i.meta.typecheck !== file.meta.typecheck), currentFile = existing.find((i) => i.projectName === file.projectName);
      if (currentFile) file.logs = currentFile.logs;
      otherFiles.push(file), this.filesMap.set(file.filepath, otherFiles), this.updateId(file, project);
    });
  }
  clearFiles(project, paths = []) {
    paths.forEach((path3) => {
      const files = this.filesMap.get(path3), fileTask = createFileTask(path3, project.config.root, project.config.name);
      if (fileTask.local = true, TestModule.register(fileTask, project), this.idMap.set(fileTask.id, fileTask), !files) {
        this.filesMap.set(path3, [fileTask]);
        return;
      }
      const filtered = files.filter((file) => file.projectName !== project.config.name);
      if (!filtered.length) this.filesMap.set(path3, [fileTask]);
      else this.filesMap.set(path3, [...filtered, fileTask]);
    });
  }
  updateId(task, project) {
    if (this.idMap.get(task.id) !== task) {
      if (task.type === "suite" && "filepath" in task) TestModule.register(task, project);
      else if (task.type === "suite") TestSuite.register(task, project);
      else TestCase.register(task, project);
      if (this.idMap.set(task.id, task), task.type === "suite") task.tasks.forEach((task2) => {
        this.updateId(task2, project);
      });
    }
  }
  getReportedEntity(task) {
    return this.reportedTasksMap.get(task);
  }
  getReportedEntityById(taskId) {
    const task = this.idMap.get(taskId);
    return task ? this.reportedTasksMap.get(task) : void 0;
  }
  updateTasks(packs) {
    for (const [id, result, meta] of packs) {
      const task = this.idMap.get(id);
      if (task) {
        if (task.result = result, task.meta = meta, (result == null ? void 0 : result.state) === "skip") task.mode = "skip";
      }
    }
  }
  updateUserLog(log) {
    const task = log.taskId && this.idMap.get(log.taskId);
    if (task) {
      if (!task.logs) task.logs = [];
      task.logs.push(log);
    }
  }
  getCountOfFailedTests() {
    return Array.from(this.idMap.values()).filter((t) => {
      var _a2;
      return ((_a2 = t.result) == null ? void 0 : _a2.state) === "fail";
    }).length;
  }
  cancelFiles(files, project) {
    const nonRegisteredFiles = files.filter(({ filepath }) => {
      const relativePath = relative(project.config.root, filepath), id = generateFileHash(relativePath, project.name);
      return !this.idMap.has(id);
    });
    this.collectFiles(project, nonRegisteredFiles.map((file) => createFileTask(file.filepath, project.config.root, project.config.name)));
  }
};
var types = {
  "application/andrew-inset": ["ez"],
  "application/appinstaller": ["appinstaller"],
  "application/applixware": ["aw"],
  "application/appx": ["appx"],
  "application/appxbundle": ["appxbundle"],
  "application/atom+xml": ["atom"],
  "application/atomcat+xml": ["atomcat"],
  "application/atomdeleted+xml": ["atomdeleted"],
  "application/atomsvc+xml": ["atomsvc"],
  "application/atsc-dwd+xml": ["dwd"],
  "application/atsc-held+xml": ["held"],
  "application/atsc-rsat+xml": ["rsat"],
  "application/automationml-aml+xml": ["aml"],
  "application/automationml-amlx+zip": ["amlx"],
  "application/bdoc": ["bdoc"],
  "application/calendar+xml": ["xcs"],
  "application/ccxml+xml": ["ccxml"],
  "application/cdfx+xml": ["cdfx"],
  "application/cdmi-capability": ["cdmia"],
  "application/cdmi-container": ["cdmic"],
  "application/cdmi-domain": ["cdmid"],
  "application/cdmi-object": ["cdmio"],
  "application/cdmi-queue": ["cdmiq"],
  "application/cpl+xml": ["cpl"],
  "application/cu-seeme": ["cu"],
  "application/cwl": ["cwl"],
  "application/dash+xml": ["mpd"],
  "application/dash-patch+xml": ["mpp"],
  "application/davmount+xml": ["davmount"],
  "application/dicom": ["dcm"],
  "application/docbook+xml": ["dbk"],
  "application/dssc+der": ["dssc"],
  "application/dssc+xml": ["xdssc"],
  "application/ecmascript": ["ecma"],
  "application/emma+xml": ["emma"],
  "application/emotionml+xml": ["emotionml"],
  "application/epub+zip": ["epub"],
  "application/exi": ["exi"],
  "application/express": ["exp"],
  "application/fdf": ["fdf"],
  "application/fdt+xml": ["fdt"],
  "application/font-tdpfr": ["pfr"],
  "application/geo+json": ["geojson"],
  "application/gml+xml": ["gml"],
  "application/gpx+xml": ["gpx"],
  "application/gxf": ["gxf"],
  "application/gzip": ["gz"],
  "application/hjson": ["hjson"],
  "application/hyperstudio": ["stk"],
  "application/inkml+xml": ["ink", "inkml"],
  "application/ipfix": ["ipfix"],
  "application/its+xml": ["its"],
  "application/java-archive": ["jar", "war", "ear"],
  "application/java-serialized-object": ["ser"],
  "application/java-vm": ["class"],
  "application/javascript": ["*js"],
  "application/json": ["json", "map"],
  "application/json5": ["json5"],
  "application/jsonml+json": ["jsonml"],
  "application/ld+json": ["jsonld"],
  "application/lgr+xml": ["lgr"],
  "application/lost+xml": ["lostxml"],
  "application/mac-binhex40": ["hqx"],
  "application/mac-compactpro": ["cpt"],
  "application/mads+xml": ["mads"],
  "application/manifest+json": ["webmanifest"],
  "application/marc": ["mrc"],
  "application/marcxml+xml": ["mrcx"],
  "application/mathematica": ["ma", "nb", "mb"],
  "application/mathml+xml": ["mathml"],
  "application/mbox": ["mbox"],
  "application/media-policy-dataset+xml": ["mpf"],
  "application/mediaservercontrol+xml": ["mscml"],
  "application/metalink+xml": ["metalink"],
  "application/metalink4+xml": ["meta4"],
  "application/mets+xml": ["mets"],
  "application/mmt-aei+xml": ["maei"],
  "application/mmt-usd+xml": ["musd"],
  "application/mods+xml": ["mods"],
  "application/mp21": ["m21", "mp21"],
  "application/mp4": ["*mp4", "*mpg4", "mp4s", "m4p"],
  "application/msix": ["msix"],
  "application/msixbundle": ["msixbundle"],
  "application/msword": ["doc", "dot"],
  "application/mxf": ["mxf"],
  "application/n-quads": ["nq"],
  "application/n-triples": ["nt"],
  "application/node": ["cjs"],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer"
  ],
  "application/oda": ["oda"],
  "application/oebps-package+xml": ["opf"],
  "application/ogg": ["ogx"],
  "application/omdoc+xml": ["omdoc"],
  "application/onenote": [
    "onetoc",
    "onetoc2",
    "onetmp",
    "onepkg",
    "one",
    "onea"
  ],
  "application/oxps": ["oxps"],
  "application/p2p-overlay+xml": ["relo"],
  "application/patch-ops-error+xml": ["xer"],
  "application/pdf": ["pdf"],
  "application/pgp-encrypted": ["pgp"],
  "application/pgp-keys": ["asc"],
  "application/pgp-signature": ["sig", "*asc"],
  "application/pics-rules": ["prf"],
  "application/pkcs10": ["p10"],
  "application/pkcs7-mime": ["p7m", "p7c"],
  "application/pkcs7-signature": ["p7s"],
  "application/pkcs8": ["p8"],
  "application/pkix-attr-cert": ["ac"],
  "application/pkix-cert": ["cer"],
  "application/pkix-crl": ["crl"],
  "application/pkix-pkipath": ["pkipath"],
  "application/pkixcmp": ["pki"],
  "application/pls+xml": ["pls"],
  "application/postscript": ["ai", "eps", "ps"],
  "application/provenance+xml": ["provx"],
  "application/pskc+xml": ["pskcxml"],
  "application/raml+yaml": ["raml"],
  "application/rdf+xml": ["rdf", "owl"],
  "application/reginfo+xml": ["rif"],
  "application/relax-ng-compact-syntax": ["rnc"],
  "application/resource-lists+xml": ["rl"],
  "application/resource-lists-diff+xml": ["rld"],
  "application/rls-services+xml": ["rs"],
  "application/route-apd+xml": ["rapd"],
  "application/route-s-tsid+xml": ["sls"],
  "application/route-usd+xml": ["rusd"],
  "application/rpki-ghostbusters": ["gbr"],
  "application/rpki-manifest": ["mft"],
  "application/rpki-roa": ["roa"],
  "application/rsd+xml": ["rsd"],
  "application/rss+xml": ["rss"],
  "application/rtf": ["rtf"],
  "application/sbml+xml": ["sbml"],
  "application/scvp-cv-request": ["scq"],
  "application/scvp-cv-response": ["scs"],
  "application/scvp-vp-request": ["spq"],
  "application/scvp-vp-response": ["spp"],
  "application/sdp": ["sdp"],
  "application/senml+xml": ["senmlx"],
  "application/sensml+xml": ["sensmlx"],
  "application/set-payment-initiation": ["setpay"],
  "application/set-registration-initiation": ["setreg"],
  "application/shf+xml": ["shf"],
  "application/sieve": ["siv", "sieve"],
  "application/smil+xml": ["smi", "smil"],
  "application/sparql-query": ["rq"],
  "application/sparql-results+xml": ["srx"],
  "application/sql": ["sql"],
  "application/srgs": ["gram"],
  "application/srgs+xml": ["grxml"],
  "application/sru+xml": ["sru"],
  "application/ssdl+xml": ["ssdl"],
  "application/ssml+xml": ["ssml"],
  "application/swid+xml": ["swidtag"],
  "application/tei+xml": ["tei", "teicorpus"],
  "application/thraud+xml": ["tfi"],
  "application/timestamped-data": ["tsd"],
  "application/toml": ["toml"],
  "application/trig": ["trig"],
  "application/ttml+xml": ["ttml"],
  "application/ubjson": ["ubj"],
  "application/urc-ressheet+xml": ["rsheet"],
  "application/urc-targetdesc+xml": ["td"],
  "application/voicexml+xml": ["vxml"],
  "application/wasm": ["wasm"],
  "application/watcherinfo+xml": ["wif"],
  "application/widget": ["wgt"],
  "application/winhlp": ["hlp"],
  "application/wsdl+xml": ["wsdl"],
  "application/wspolicy+xml": ["wspolicy"],
  "application/xaml+xml": ["xaml"],
  "application/xcap-att+xml": ["xav"],
  "application/xcap-caps+xml": ["xca"],
  "application/xcap-diff+xml": ["xdf"],
  "application/xcap-el+xml": ["xel"],
  "application/xcap-ns+xml": ["xns"],
  "application/xenc+xml": ["xenc"],
  "application/xfdf": ["xfdf"],
  "application/xhtml+xml": ["xhtml", "xht"],
  "application/xliff+xml": ["xlf"],
  "application/xml": ["xml", "xsl", "xsd", "rng"],
  "application/xml-dtd": ["dtd"],
  "application/xop+xml": ["xop"],
  "application/xproc+xml": ["xpl"],
  "application/xslt+xml": ["*xsl", "xslt"],
  "application/xspf+xml": ["xspf"],
  "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
  "application/yang": ["yang"],
  "application/yin+xml": ["yin"],
  "application/zip": ["zip"],
  "application/zip+dotlottie": ["lottie"],
  "audio/3gpp": ["*3gpp"],
  "audio/aac": ["adts", "aac"],
  "audio/adpcm": ["adp"],
  "audio/amr": ["amr"],
  "audio/basic": ["au", "snd"],
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mobile-xmf": ["mxmf"],
  "audio/mp3": ["*mp3"],
  "audio/mp4": ["m4a", "mp4a", "m4b"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx", "opus"],
  "audio/s3m": ["s3m"],
  "audio/silk": ["sil"],
  "audio/wav": ["wav"],
  "audio/wave": ["*wav"],
  "audio/webm": ["weba"],
  "audio/xm": ["xm"],
  "font/collection": ["ttc"],
  "font/otf": ["otf"],
  "font/ttf": ["ttf"],
  "font/woff": ["woff"],
  "font/woff2": ["woff2"],
  "image/aces": ["exr"],
  "image/apng": ["apng"],
  "image/avci": ["avci"],
  "image/avcs": ["avcs"],
  "image/avif": ["avif"],
  "image/bmp": ["bmp", "dib"],
  "image/cgm": ["cgm"],
  "image/dicom-rle": ["drle"],
  "image/dpx": ["dpx"],
  "image/emf": ["emf"],
  "image/fits": ["fits"],
  "image/g3fax": ["g3"],
  "image/gif": ["gif"],
  "image/heic": ["heic"],
  "image/heic-sequence": ["heics"],
  "image/heif": ["heif"],
  "image/heif-sequence": ["heifs"],
  "image/hej2k": ["hej2"],
  "image/ief": ["ief"],
  "image/jaii": ["jaii"],
  "image/jais": ["jais"],
  "image/jls": ["jls"],
  "image/jp2": ["jp2", "jpg2"],
  "image/jpeg": ["jpg", "jpeg", "jpe"],
  "image/jph": ["jph"],
  "image/jphc": ["jhc"],
  "image/jpm": ["jpm", "jpgm"],
  "image/jpx": ["jpx", "jpf"],
  "image/jxl": ["jxl"],
  "image/jxr": ["jxr"],
  "image/jxra": ["jxra"],
  "image/jxrs": ["jxrs"],
  "image/jxs": ["jxs"],
  "image/jxsc": ["jxsc"],
  "image/jxsi": ["jxsi"],
  "image/jxss": ["jxss"],
  "image/ktx": ["ktx"],
  "image/ktx2": ["ktx2"],
  "image/pjpeg": ["jfif"],
  "image/png": ["png"],
  "image/sgi": ["sgi"],
  "image/svg+xml": ["svg", "svgz"],
  "image/t38": ["t38"],
  "image/tiff": ["tif", "tiff"],
  "image/tiff-fx": ["tfx"],
  "image/webp": ["webp"],
  "image/wmf": ["wmf"],
  "message/disposition-notification": ["disposition-notification"],
  "message/global": ["u8msg"],
  "message/global-delivery-status": ["u8dsn"],
  "message/global-disposition-notification": ["u8mdn"],
  "message/global-headers": ["u8hdr"],
  "message/rfc822": ["eml", "mime", "mht", "mhtml"],
  "model/3mf": ["3mf"],
  "model/gltf+json": ["gltf"],
  "model/gltf-binary": ["glb"],
  "model/iges": ["igs", "iges"],
  "model/jt": ["jt"],
  "model/mesh": ["msh", "mesh", "silo"],
  "model/mtl": ["mtl"],
  "model/obj": ["obj"],
  "model/prc": ["prc"],
  "model/step": ["step", "stp", "stpnc", "p21", "210"],
  "model/step+xml": ["stpx"],
  "model/step+zip": ["stpz"],
  "model/step-xml+zip": ["stpxz"],
  "model/stl": ["stl"],
  "model/u3d": ["u3d"],
  "model/vrml": ["wrl", "vrml"],
  "model/x3d+binary": ["*x3db", "x3dbz"],
  "model/x3d+fastinfoset": ["x3db"],
  "model/x3d+vrml": ["*x3dv", "x3dvz"],
  "model/x3d+xml": ["x3d", "x3dz"],
  "model/x3d-vrml": ["x3dv"],
  "text/cache-manifest": ["appcache", "manifest"],
  "text/calendar": ["ics", "ifb"],
  "text/coffeescript": ["coffee", "litcoffee"],
  "text/css": ["css"],
  "text/csv": ["csv"],
  "text/html": ["html", "htm", "shtml"],
  "text/jade": ["jade"],
  "text/javascript": ["js", "mjs"],
  "text/jsx": ["jsx"],
  "text/less": ["less"],
  "text/markdown": ["md", "markdown"],
  "text/mathml": ["mml"],
  "text/mdx": ["mdx"],
  "text/n3": ["n3"],
  "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  "text/richtext": ["rtx"],
  "text/rtf": ["*rtf"],
  "text/sgml": ["sgml", "sgm"],
  "text/shex": ["shex"],
  "text/slim": ["slim", "slm"],
  "text/spdx": ["spdx"],
  "text/stylus": ["stylus", "styl"],
  "text/tab-separated-values": ["tsv"],
  "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
  "text/turtle": ["ttl"],
  "text/uri-list": ["uri", "uris", "urls"],
  "text/vcard": ["vcard"],
  "text/vtt": ["vtt"],
  "text/wgsl": ["wgsl"],
  "text/xml": ["*xml"],
  "text/yaml": ["yaml", "yml"],
  "video/3gpp": ["3gp", "3gpp"],
  "video/3gpp2": ["3g2"],
  "video/h261": ["h261"],
  "video/h263": ["h263"],
  "video/h264": ["h264"],
  "video/iso.segment": ["m4s"],
  "video/jpeg": ["jpgv"],
  "video/jpm": ["*jpm", "*jpgm"],
  "video/mj2": ["mj2", "mjp2"],
  "video/mp2t": ["ts", "m2t", "m2ts", "mts"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/webm": ["webm"]
};
Object.freeze(types);
var __classPrivateFieldGet = {} && {}.__classPrivateFieldGet || function(receiver2, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver2 !== state || !f : !state.has(receiver2)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver2) : f ? f.value : state.get(receiver2);
};
var _Mime_extensionToType;
var _Mime_typeToExtension;
var _Mime_typeToExtensions;
var Mime = class {
  constructor(...args) {
    _Mime_extensionToType.set(this, /* @__PURE__ */ new Map());
    _Mime_typeToExtension.set(this, /* @__PURE__ */ new Map());
    _Mime_typeToExtensions.set(this, /* @__PURE__ */ new Map());
    for (const arg of args) {
      this.define(arg);
    }
  }
  define(typeMap, force = false) {
    for (let [type, extensions] of Object.entries(typeMap)) {
      type = type.toLowerCase();
      extensions = extensions.map((ext) => ext.toLowerCase());
      if (!__classPrivateFieldGet(this, _Mime_typeToExtensions, "f").has(type)) {
        __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").set(type, /* @__PURE__ */ new Set());
      }
      const allExtensions = __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type);
      let first = true;
      for (let extension2 of extensions) {
        const starred = extension2.startsWith("*");
        extension2 = starred ? extension2.slice(1) : extension2;
        allExtensions == null ? void 0 : allExtensions.add(extension2);
        if (first) {
          __classPrivateFieldGet(this, _Mime_typeToExtension, "f").set(type, extension2);
        }
        first = false;
        if (starred)
          continue;
        const currentType = __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(extension2);
        if (currentType && currentType != type && !force) {
          throw new Error(`"${type} -> ${extension2}" conflicts with "${currentType} -> ${extension2}". Pass \`force=true\` to override this definition.`);
        }
        __classPrivateFieldGet(this, _Mime_extensionToType, "f").set(extension2, type);
      }
    }
    return this;
  }
  getType(path3) {
    if (typeof path3 !== "string")
      return null;
    const last = path3.replace(/^.*[/\\]/s, "").toLowerCase();
    const ext = last.replace(/^.*\./s, "").toLowerCase();
    const hasPath = last.length < path3.length;
    const hasDot = ext.length < last.length - 1;
    if (!hasDot && hasPath)
      return null;
    return __classPrivateFieldGet(this, _Mime_extensionToType, "f").get(ext) ?? null;
  }
  getExtension(type) {
    var _a2;
    if (typeof type !== "string")
      return null;
    type = (_a2 = type == null ? void 0 : type.split) == null ? void 0 : _a2.call(type, ";")[0];
    return (type && __classPrivateFieldGet(this, _Mime_typeToExtension, "f").get(type.trim().toLowerCase())) ?? null;
  }
  getAllExtensions(type) {
    if (typeof type !== "string")
      return null;
    return __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").get(type.toLowerCase()) ?? null;
  }
  _freeze() {
    this.define = () => {
      throw new Error("define() not allowed for built-in Mime objects. See https://github.com/broofa/mime/blob/main/README.md#custom-mime-instances");
    };
    Object.freeze(this);
    for (const extensions of __classPrivateFieldGet(this, _Mime_typeToExtensions, "f").values()) {
      Object.freeze(extensions);
    }
    return this;
  }
  _getTestState() {
    return {
      types: __classPrivateFieldGet(this, _Mime_extensionToType, "f"),
      extensions: __classPrivateFieldGet(this, _Mime_typeToExtension, "f")
    };
  }
};
_Mime_extensionToType = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtension = /* @__PURE__ */ new WeakMap(), _Mime_typeToExtensions = /* @__PURE__ */ new WeakMap();
var mime = new Mime(types)._freeze();
var TestRun = class {
  constructor(vitest) {
    this.vitest = vitest;
  }
  async start(specifications) {
    const filepaths = specifications.map((spec) => spec.moduleId);
    this.vitest.state.collectPaths(filepaths), await this.vitest.report("onTestRunStart", [...specifications]);
  }
  async enqueued(project, file) {
    this.vitest.state.collectFiles(project, [file]);
    const testModule = this.vitest.state.getReportedEntity(file);
    await this.vitest.report("onTestModuleQueued", testModule);
  }
  async collected(project, files) {
    this.vitest.state.collectFiles(project, files), await Promise.all(files.map((file) => {
      const testModule = this.vitest.state.getReportedEntity(file);
      return this.vitest.report("onTestModuleCollected", testModule);
    }));
  }
  async log(log) {
    this.vitest.state.updateUserLog(log), await this.vitest.report("onUserConsoleLog", log);
  }
  async annotate(testId, annotation) {
    const task = this.vitest.state.idMap.get(testId), entity = task && this.vitest.state.getReportedEntity(task);
    return (0, import_node_assert2.default)(task && entity, `Entity must be found for task ${(task == null ? void 0 : task.name) || testId}`), (0, import_node_assert2.default)(entity.type === "test", `Annotation can only be added to a test, instead got ${entity.type}`), await this.resolveTestAttachment(entity, annotation), entity.task.annotations.push(annotation), await this.vitest.report("onTestCaseAnnotate", entity, annotation), annotation;
  }
  async updated(update, events) {
    this.syncUpdateStacks(update), this.vitest.state.updateTasks(update);
    for (const [id, event, data] of events) await this.reportEvent(id, event, data).catch((error) => {
      this.vitest.state.catchError(serializeValue(error), "Unhandled Reporter Error");
    });
    await this.vitest.report("onTaskUpdate", update, events);
  }
  async end(specifications, errors, coverage) {
    if (coverage) await this.vitest.report("onCoverage", coverage);
    const modules = specifications.map((spec) => spec.testModule).filter((s) => s != null), state = this.vitest.isCancelling ? "interrupted" : this.hasFailed(modules) ? "failed" : "passed";
    if (state !== "passed") process.exitCode = 1;
    for (const project in await this.vitest.report("onTestRunEnd", modules, [...errors], state), this.vitest.state.metadata) {
      const meta = this.vitest.state.metadata[project];
      if (!(meta == null ? void 0 : meta.dumpDir)) continue;
      const path3 = resolve(meta.dumpDir, "vitest-metadata.json");
      meta.outline = {
        externalized: Object.keys(meta.externalized).length,
        inlined: Object.keys(meta.tmps).length
      }, await (0, import_promises3.writeFile)(path3, JSON.stringify(meta, null, 2), "utf-8"), this.vitest.logger.log(`Metadata written to ${path3}`);
    }
  }
  hasFailed(modules) {
    return modules.length ? modules.some((m) => !m.ok()) : !this.vitest.config.passWithNoTests;
  }
  // make sure the error always has a "stacks" property
  syncUpdateStacks(update) {
    update.forEach(([taskId, result]) => {
      var _a2;
      const task = this.vitest.state.idMap.get(taskId), isBrowser = task && task.file.pool === "browser";
      (_a2 = result == null ? void 0 : result.errors) == null ? void 0 : _a2.forEach((error) => {
        var _a3;
        if (isPrimitive(error)) return;
        const project = this.vitest.getProjectByName(task.file.projectName || "");
        if (isBrowser) error.stacks = ((_a3 = project.browser) == null ? void 0 : _a3.parseErrorStacktrace(error, { frameFilter: project.config.onStackTrace })) || [];
        else error.stacks = parseErrorStacktrace(error, { frameFilter: project.config.onStackTrace });
      });
    });
  }
  async reportEvent(id, event, data) {
    const task = this.vitest.state.idMap.get(id), entity = task && this.vitest.state.getReportedEntity(task);
    if ((0, import_node_assert2.default)(task && entity, `Entity must be found for task ${(task == null ? void 0 : task.name) || id}`), event === "suite-prepare" && entity.type === "suite") return await this.vitest.report("onTestSuiteReady", entity);
    if (event === "suite-prepare" && entity.type === "module") return await this.vitest.report("onTestModuleStart", entity);
    if (event === "suite-finished") {
      if ((0, import_node_assert2.default)(entity.type === "suite" || entity.type === "module", "Entity type must be suite or module"), entity.state() === "skipped")
        await this.reportChildren(entity.children);
      if (entity.type === "module") await this.vitest.report("onTestModuleEnd", entity);
      else await this.vitest.report("onTestSuiteResult", entity);
      return;
    }
    if (event === "test-prepare" && entity.type === "test") return await this.vitest.report("onTestCaseReady", entity);
    if (event === "test-finished" && entity.type === "test") return await this.vitest.report("onTestCaseResult", entity);
    if (event.startsWith("before-hook") || event.startsWith("after-hook")) {
      const isBefore = event.startsWith("before-hook"), hook = entity.type === "test" ? {
        name: isBefore ? "beforeEach" : "afterEach",
        entity
      } : {
        name: isBefore ? "beforeAll" : "afterAll",
        entity
      };
      if (event.endsWith("-start")) await this.vitest.report("onHookStart", hook);
      else await this.vitest.report("onHookEnd", hook);
      if (event === "test-annotation") {
        const annotation = data == null ? void 0 : data.annotation;
        (0, import_node_assert2.default)(annotation && entity.type === "test"), await this.vitest.report("onTestCaseAnnotate", entity, annotation);
      }
    }
  }
  async resolveTestAttachment(test, annotation) {
    const project = test.project, attachment = annotation.attachment;
    if (!attachment) return attachment;
    const path3 = attachment.path;
    if (path3 && !path3.startsWith("http://") && !path3.startsWith("https://")) {
      const currentPath = resolve(project.config.root, path3), hash2 = (0, import_node_crypto2.createHash)("sha1").update(currentPath).digest("hex"), newPath = resolve(project.config.attachmentsDir, `${sanitizeFilePath(annotation.message)}-${hash2}${extname(currentPath)}`);
      if (!(0, import_node_fs6.existsSync)(project.config.attachmentsDir)) await (0, import_promises3.mkdir)(project.config.attachmentsDir, { recursive: true });
      await (0, import_promises3.copyFile)(currentPath, newPath), attachment.path = newPath, attachment.contentType = (attachment.contentType ?? mime.getType(basename(currentPath))) || void 0;
    }
    return attachment;
  }
  async reportChildren(children) {
    for (const child of children) if (child.type === "test") await this.vitest.report("onTestCaseReady", child), await this.vitest.report("onTestCaseResult", child);
    else await this.vitest.report("onTestSuiteReady", child), await this.reportChildren(child.children), await this.vitest.report("onTestSuiteResult", child);
  }
};
function sanitizeFilePath(s) {
  return s.replace(/[\x00-\x2C\x2E\x2F\x3A-\x40\x5B-\x60\x7B-\x7F]+/g, "-");
}
var VitestWatcher = class {
  constructor(vitest) {
    /**
    * Modules that will be invalidated on the next run.
    */
    __publicField(this, "invalidates", /* @__PURE__ */ new Set());
    /**
    * Test files that have changed and need to be rerun.
    */
    __publicField(this, "changedTests", /* @__PURE__ */ new Set());
    __publicField(this, "_onRerun", []);
    __publicField(this, "unregisterWatcher", noop);
    __publicField(this, "onFileChange", (id) => {
      if (id = slash(id), this.vitest.logger.clearHighlightCache(id), this.vitest.invalidateFile(id), this.getTestFilesFromWatcherTrigger(id)) this.scheduleRerun(id);
      else if (this.handleFileChanged(id)) this.scheduleRerun(id);
    });
    __publicField(this, "onFileDelete", (id) => {
      if (id = slash(id), this.vitest.logger.clearHighlightCache(id), this.invalidates.add(id), this.vitest.state.filesMap.has(id)) this.vitest.projects.forEach((project) => project._removeCachedTestFile(id)), this.vitest.state.filesMap.delete(id), this.vitest.cache.results.removeFromCache(id), this.vitest.cache.stats.removeStats(id), this.changedTests.delete(id), this.vitest.report("onTestRemoved", id);
    });
    __publicField(this, "onFileCreate", (id) => {
      if (id = slash(id), this.vitest.invalidateFile(id), this.getTestFilesFromWatcherTrigger(id)) {
        this.scheduleRerun(id);
        return;
      }
      let fileContent;
      const matchingProjects = [];
      if (this.vitest.projects.forEach((project) => {
        if (project.matchesTestGlob(id, () => fileContent ?? (fileContent = (0, import_node_fs6.readFileSync)(id, "utf-8")))) matchingProjects.push(project);
      }), matchingProjects.length > 0) this.changedTests.add(id), this.scheduleRerun(id);
      else if (this.handleFileChanged(id)) this.scheduleRerun(id);
    });
    this.vitest = vitest;
  }
  /**
  * Register a handler that will be called when test files need to be rerun.
  * The callback can receive several files in case the changed file is imported by several test files.
  * Several invocations of this method will add multiple handlers.
  * @internal
  */
  onWatcherRerun(cb) {
    return this._onRerun.push(cb), this;
  }
  registerWatcher() {
    const watcher = this.vitest.vite.watcher;
    if (this.vitest.config.forceRerunTriggers.length) watcher.add(this.vitest.config.forceRerunTriggers);
    return watcher.on("change", this.onFileChange), watcher.on("unlink", this.onFileDelete), watcher.on("add", this.onFileCreate), this.unregisterWatcher = () => {
      watcher.off("change", this.onFileChange), watcher.off("unlink", this.onFileDelete), watcher.off("add", this.onFileCreate), this.unregisterWatcher = noop;
    }, this;
  }
  scheduleRerun(file) {
    this._onRerun.forEach((cb) => cb(file));
  }
  getTestFilesFromWatcherTrigger(id) {
    if (!this.vitest.config.watchTriggerPatterns) return false;
    let triggered = false;
    return this.vitest.config.watchTriggerPatterns.forEach((definition) => {
      const exec = definition.pattern.exec(id);
      if (exec) {
        const files = definition.testsToRun(id, exec);
        if (Array.isArray(files)) triggered = true, files.forEach((file) => this.changedTests.add(resolve(this.vitest.config.root, file)));
        else if (typeof files === "string") triggered = true, this.changedTests.add(resolve(this.vitest.config.root, files));
      }
    }), triggered;
  }
  handleSetupFile(filepath) {
    let isSetupFile = false;
    return this.vitest.projects.forEach((project) => {
      project.config.setupFiles.includes(filepath) && this.vitest.state.filesMap.forEach((files) => {
        files.forEach((file) => {
          if (file.projectName === project.name) isSetupFile = true, this.changedTests.add(file.filepath);
        });
      });
    }), isSetupFile;
  }
  /**
  * @returns A value indicating whether rerun is needed (changedTests was mutated)
  */
  handleFileChanged(filepath) {
    var _a2;
    if (this.changedTests.has(filepath) || this.invalidates.has(filepath)) return false;
    if (import_picomatch2.default.isMatch(filepath, this.vitest.config.forceRerunTriggers)) return this.vitest.state.getFilepaths().forEach((file) => this.changedTests.add(file)), true;
    if (this.handleSetupFile(filepath)) return true;
    const projects = this.vitest.projects.filter((project) => {
      var _a3, _b2;
      return (_b2 = (((_a3 = project.browser) == null ? void 0 : _a3.vite.moduleGraph) || project.vite.moduleGraph).getModulesByFile(filepath)) == null ? void 0 : _b2.size;
    });
    if (!projects.length) return this.vitest.state.filesMap.has(filepath) || this.vitest.projects.some((project) => project._isCachedTestFile(filepath)) ? (this.changedTests.add(filepath), true) : false;
    const files = [];
    for (const project of projects) {
      const mods = ((_a2 = project.browser) == null ? void 0 : _a2.vite.moduleGraph.getModulesByFile(filepath)) || project.vite.moduleGraph.getModulesByFile(filepath);
      if (!mods || !mods.size) continue;
      if (this.invalidates.add(filepath), this.vitest.state.filesMap.has(filepath) || project._isCachedTestFile(filepath)) {
        this.changedTests.add(filepath), files.push(filepath);
        continue;
      }
      let rerun = false;
      for (const mod of mods) mod.importers.forEach((i) => {
        if (i.file && this.handleFileChanged(i.file)) rerun = true;
      });
      if (rerun) files.push(filepath);
    }
    return !!files.length;
  }
};
var WATCHER_DEBOUNCE = 100;
var Vitest = class {
  constructor(mode, cliOptions, options = {}) {
    /**
    * Current Vitest version.
    * @example '2.0.0'
    */
    __publicField(this, "version", version);
    /**
    * The logger instance used to log messages. It's recommended to use this logger instead of `console`.
    * It's possible to override stdout and stderr streams when initiating Vitest.
    * @example
    * new Vitest('test', {
    *   stdout: new Writable(),
    * })
    */
    __publicField(this, "logger");
    /**
    * The package installer instance used to install Vitest packages.
    * @example
    * await vitest.packageInstaller.ensureInstalled('@vitest/browser', process.cwd())
    */
    __publicField(this, "packageInstaller");
    /**
    * A path to the built Vitest directory. This is usually a folder in `node_modules`.
    */
    __publicField(this, "distPath", distDir);
    /**
    * A list of projects that are currently running.
    * If projects were filtered with `--project` flag, they won't appear here.
    */
    __publicField(this, "projects", []);
    /**
    * A watcher handler. This is not the file system watcher. The handler only
    * exposes methods to handle changed files.
    *
    * If you have your own watcher, you can use these methods to replicate
    * Vitest behaviour.
    */
    __publicField(this, "watcher");
    /** @internal */
    __publicField(this, "configOverride", {});
    /** @internal */
    __publicField(this, "filenamePattern");
    /** @internal */
    __publicField(this, "runningPromise");
    /** @internal */
    __publicField(this, "closingPromise");
    /** @internal */
    __publicField(this, "isCancelling", false);
    /** @internal */
    __publicField(this, "coreWorkspaceProject");
    /** @internal */
    __publicField(this, "_browserSessions", new BrowserSessions());
    /** @internal */
    __publicField(this, "_cliOptions", {});
    /** @internal */
    __publicField(this, "reporters", []);
    /** @internal */
    __publicField(this, "runner");
    /** @internal */
    __publicField(this, "_testRun");
    /** @internal */
    __publicField(this, "_resolver");
    /** @internal */
    __publicField(this, "_fetcher");
    /** @internal */
    __publicField(this, "_tmpDir", join((0, import_node_os3.tmpdir)(), nanoid()));
    __publicField(this, "isFirstRun", true);
    __publicField(this, "restartsCount", 0);
    __publicField(this, "specifications");
    __publicField(this, "pool");
    __publicField(this, "_config");
    __publicField(this, "_vite");
    __publicField(this, "_state");
    __publicField(this, "_cache");
    __publicField(this, "_snapshot");
    __publicField(this, "_coverageProvider");
    __publicField(this, "_onRestartListeners", []);
    __publicField(this, "_onClose", []);
    __publicField(this, "_onSetServer", []);
    __publicField(this, "_onCancelListeners", []);
    __publicField(this, "_onUserTestsRerun", []);
    __publicField(this, "_onFilterWatchedSpecification", []);
    __publicField(this, "_coverageOverrideCache", /* @__PURE__ */ new WeakMap());
    /**
    * Inject new test projects into the workspace.
    * @param config Glob, config path or a custom config options.
    * @returns An array of new test projects. Can be empty if the name was filtered out.
    */
    __publicField(this, "injectTestProject", async (config) => {
      const currentNames = new Set(this.projects.map((p2) => p2.name)), projects = await resolveProjects(this, this._cliOptions, void 0, Array.isArray(config) ? config : [config], currentNames);
      return this.projects.push(...projects), projects;
    });
    /**
    * Provide a value to the test context. This value will be available to all tests with `inject`.
    */
    __publicField(this, "provide", (key, value) => {
      this.getRootProject().provide(key, value);
    });
    __publicField(this, "_rerunTimer");
    this.mode = mode, this._cliOptions = cliOptions, this.logger = new Logger(this, options.stdout, options.stderr), this.packageInstaller = options.packageInstaller || new VitestPackageInstaller(), this.specifications = new VitestSpecifications(this), this.watcher = new VitestWatcher(this).onWatcherRerun((file) => this.scheduleRerun(file));
  }
  /**
  * The global config.
  */
  get config() {
    return assert2(this._config, "config"), this._config;
  }
  /**
  * Global Vite's dev server instance.
  */
  get vite() {
    return assert2(this._vite, "vite", "server"), this._vite;
  }
  /**
  * The global test state manager.
  * @experimental The State API is experimental and not subject to semver.
  */
  get state() {
    return assert2(this._state, "state"), this._state;
  }
  /**
  * The global snapshot manager. You can access the current state on `snapshot.summary`.
  */
  get snapshot() {
    return assert2(this._snapshot, "snapshot", "snapshot manager"), this._snapshot;
  }
  /**
  * Test results and test file stats cache. Primarily used by the sequencer to sort tests.
  */
  get cache() {
    return assert2(this._cache, "cache"), this._cache;
  }
  /** @internal */
  async _setServer(options, server) {
    var _a2, _b2, _c, _d, _e, _f;
    this.watcher.unregisterWatcher(), clearTimeout(this._rerunTimer), this.restartsCount += 1, (_b2 = (_a2 = this.pool) == null ? void 0 : _a2.close) == null ? void 0 : _b2.call(_a2), this.pool = void 0, this.closingPromise = void 0, this.projects = [], this.runningPromise = void 0, this.coreWorkspaceProject = void 0, this.specifications.clearCache(), this._coverageProvider = void 0, this._onUserTestsRerun = [], this._vite = server;
    const resolved = resolveConfig$1(this, options, server.config);
    if (this._config = resolved, this._state = new StateManager({ onUnhandledError: resolved.onUnhandledError }), this._cache = new VitestCache(this.version), this._snapshot = new SnapshotManager({ ...resolved.snapshotOptions }), this._testRun = new TestRun(this), this.config.watch) this.watcher.registerWatcher();
    this._resolver = new VitestResolver(server.config.cacheDir, resolved), this._fetcher = createFetchModuleFunction(this._resolver, this._tmpDir, {
      dumpFolder: this.config.dumpDir,
      readFromDump: ((_c = this.config.server.debug) == null ? void 0 : _c.load) ?? process.env.VITEST_DEBUG_LOAD_DUMP != null
    });
    const environment = server.environments.__vitest__;
    if (this.runner = new ServerModuleRunner(environment, this._fetcher, resolved), this.config.watch) {
      const serverRestart = server.restart;
      server.restart = async (...args) => {
        await Promise.all(this._onRestartListeners.map((fn) => fn())), this.report("onServerRestart"), await this.close(), await serverRestart(...args);
      }, server.watcher.on("change", async (file) => {
        if (file = normalize(file), file === server.config.configFile || this.projects.some((p2) => p2.vite.config.configFile === file)) await Promise.all(this._onRestartListeners.map((fn) => fn("config"))), this.report("onServerRestart", "config"), await this.close(), await serverRestart();
      });
    }
    this.cache.results.setConfig(resolved.root, resolved.cache);
    try {
      await this.cache.results.readFromCache();
    } catch {
    }
    const projects = await this.resolveProjects(this._cliOptions);
    if (this.projects = projects, await Promise.all(projects.flatMap((project) => {
      return project.vite.config.getSortedPluginHooks("configureVitest").map((hook) => hook({
        project,
        vitest: this,
        injectTestProjects: this.injectTestProject
      }));
    })), (_d = this._cliOptions.browser) == null ? void 0 : _d.enabled) {
      if (!this.projects.filter((p2) => p2.config.browser.enabled).length) throw new Error(`Vitest received --browser flag, but no project had a browser configuration.`);
    }
    if (!this.projects.length) {
      const filter = toArray(resolved.project).join('", "');
      if (filter) throw new Error(`No projects matched the filter "${filter}".`);
      {
        let error = `Vitest wasn't able to resolve any project.`;
        if (this.config.browser.enabled && !((_e = this.config.browser.instances) == null ? void 0 : _e.length)) error += ` Please, check that you specified the "browser.instances" option.`;
        throw new Error(error);
      }
    }
    if (!this.coreWorkspaceProject) this.coreWorkspaceProject = TestProject._createBasicProject(this);
    if (this.config.testNamePattern) this.configOverride.testNamePattern = this.config.testNamePattern;
    this.reporters = resolved.mode === "benchmark" ? await createBenchmarkReporters(toArray((_f = resolved.benchmark) == null ? void 0 : _f.reporters), this.runner) : await createReporters(resolved.reporters, this), await Promise.all(this._onSetServer.map((fn) => fn()));
  }
  /** @internal */
  get coverageProvider() {
    var _a2;
    return ((_a2 = this.configOverride.coverage) == null ? void 0 : _a2.enabled) === false ? null : this._coverageProvider;
  }
  async enableCoverage() {
    var _a2, _b2;
    this.configOverride.coverage = {}, this.configOverride.coverage.enabled = true, await this.createCoverageProvider(), await ((_b2 = (_a2 = this.coverageProvider) == null ? void 0 : _a2.onEnabled) == null ? void 0 : _b2.call(_a2));
  }
  disableCoverage() {
    var _a2;
    (_a2 = this.configOverride).coverage ?? (_a2.coverage = {}), this.configOverride.coverage.enabled = false;
  }
  /** @internal */
  get _coverageOptions() {
    if (!this.configOverride.coverage) return this.config.coverage;
    if (!this._coverageOverrideCache.has(this.configOverride.coverage)) {
      const coverage = deepClone(this.config.coverage), options = deepMerge(coverage, this.configOverride.coverage);
      this._coverageOverrideCache.set(this.configOverride.coverage, options);
    }
    return this._coverageOverrideCache.get(this.configOverride.coverage);
  }
  /**
  * Get global provided context.
  */
  getProvidedContext() {
    return this.getRootProject().getProvidedContext();
  }
  /** @internal */
  _ensureRootProject() {
    return this.coreWorkspaceProject || (this.coreWorkspaceProject = TestProject._createBasicProject(this)), this.coreWorkspaceProject;
  }
  /**
  * Return project that has the root (or "global") config.
  */
  getRootProject() {
    if (!this.coreWorkspaceProject) throw new Error(`Root project is not initialized. This means that the Vite server was not established yet and the the workspace config is not resolved.`);
    return this.coreWorkspaceProject;
  }
  getProjectByName(name) {
    const project = this.projects.find((p2) => p2.name === name) || this.coreWorkspaceProject || this.projects[0];
    if (!project) throw new Error(`Project "${name}" was not found.`);
    return project;
  }
  /**
  * Import a file using Vite module runner. The file will be transformed by Vite and executed in a separate context.
  * @param moduleId The ID of the module in Vite module graph
  */
  import(moduleId) {
    return this.runner.import(moduleId);
  }
  /**
  * Creates a coverage provider if `coverage` is enabled in the config.
  */
  async createCoverageProvider() {
    if (this._coverageProvider) return this._coverageProvider;
    const coverageProvider = await this.initCoverageProvider();
    if (coverageProvider) await coverageProvider.clean(this._coverageOptions.clean);
    return coverageProvider || null;
  }
  async resolveProjects(cliOptions) {
    const names = /* @__PURE__ */ new Set();
    if (this.config.projects) return resolveProjects(this, cliOptions, void 0, this.config.projects, names);
    if ("workspace" in this.config) throw new Error("The `test.workspace` option was removed in Vitest 4. Please, migrate to `test.projects` instead. See https://vitest.dev/guide/projects for examples.");
    const project = getDefaultTestProject(this);
    return project ? resolveBrowserProjects(this, /* @__PURE__ */ new Set([project.name]), [project]) : [];
  }
  /**
  * Glob test files in every project and create a TestSpecification for each file and pool.
  * @param filters String filters to match the test files.
  */
  async globTestSpecifications(filters = []) {
    return this.specifications.globTestSpecifications(filters);
  }
  async initCoverageProvider() {
    if (this._coverageProvider != null) return;
    const coverageConfig = this.configOverride.coverage ? this.getRootProject().serializedConfig.coverage : this.config.coverage;
    if (this._coverageProvider = await getCoverageProvider(coverageConfig, this.runner), this._coverageProvider) await this._coverageProvider.initialize(this), this.config.coverage = this._coverageProvider.resolveOptions();
    return this._coverageProvider;
  }
  /**
  * Merge reports from multiple runs located in the specified directory (value from `--merge-reports` if not specified).
  */
  async mergeReports(directory) {
    var _a2, _b2;
    if (this.reporters.some((r) => r instanceof BlobReporter)) throw new Error("Cannot merge reports when `--reporter=blob` is used. Remove blob reporter from the config first.");
    const { files, errors, coverages, executionTimes } = await readBlobs(this.version, directory || this.config.mergeReports, this.projects);
    this.state.blobs = {
      files,
      errors,
      coverages,
      executionTimes
    }, await this.report("onInit", this);
    const specifications = [];
    for (const file of files) {
      const specification = this.getProjectByName(file.projectName || "").createSpecification(file.filepath, void 0, file.pool);
      specifications.push(specification);
    }
    await this._testRun.start(specifications).catch(noop);
    for (const file of files) await this._reportFileTask(file);
    return this._checkUnhandledErrors(errors), await this._testRun.end(specifications, errors).catch(noop), await this.initCoverageProvider(), await ((_b2 = (_a2 = this.coverageProvider) == null ? void 0 : _a2.mergeReports) == null ? void 0 : _b2.call(_a2, coverages)), {
      testModules: this.state.getTestModules(),
      unhandledErrors: this.state.getUnhandledErrors()
    };
  }
  /**
  * Returns the seed, if tests are running in a random order.
  */
  getSeed() {
    return this.config.sequence.seed ?? null;
  }
  /** @internal */
  async _reportFileTask(file) {
    const project = this.getProjectByName(file.projectName || "");
    await this._testRun.enqueued(project, file).catch(noop), await this._testRun.collected(project, [file]).catch(noop);
    const logs = [], { packs, events } = convertTasksToEvents(file, (task) => {
      if (task.logs) logs.push(...task.logs);
    });
    logs.sort((log1, log2) => log1.time - log2.time);
    for (const log of logs) await this._testRun.log(log).catch(noop);
    await this._testRun.updated(packs, events).catch(noop);
  }
  async collect(filters) {
    const files = await this.specifications.getRelevantTestSpecifications(filters);
    return files.length ? this.collectTests(files) : {
      testModules: [],
      unhandledErrors: []
    };
  }
  /**
  * Returns the list of test files that match the config and filters.
  * @param filters String filters to match the test files
  */
  getRelevantTestSpecifications(filters) {
    return this.specifications.getRelevantTestSpecifications(filters);
  }
  /**
  * Initialize reporters, the coverage provider, and run tests.
  * This method can throw an error:
  *   - `FilesNotFoundError` if no tests are found
  *   - `GitNotFoundError` if `--related` flag is used, but git repository is not initialized
  *   - `Error` from the user reporters
  * @param filters String filters to match the test files
  */
  async start(filters) {
    var _a2, _b2, _c, _d;
    try {
      await this.initCoverageProvider(), await ((_a2 = this.coverageProvider) == null ? void 0 : _a2.clean(this._coverageOptions.clean));
    } finally {
      await this.report("onInit", this);
    }
    this.filenamePattern = filters && (filters == null ? void 0 : filters.length) > 0 ? filters : void 0;
    const files = await this.specifications.getRelevantTestSpecifications(filters);
    if (!files.length) {
      await this._testRun.start([]);
      const coverage = await ((_c = (_b2 = this.coverageProvider) == null ? void 0 : _b2.generateCoverage) == null ? void 0 : _c.call(_b2, { allTestsRun: true }));
      if (await this._testRun.end([], [], coverage), await this.reportCoverage(coverage, true), !this.config.watch || !(this.config.changed || ((_d = this.config.related) == null ? void 0 : _d.length))) throw new FilesNotFoundError(this.mode);
    }
    let testModules = {
      testModules: [],
      unhandledErrors: []
    };
    if (files.length) await this.cache.stats.populateStats(this.config.root, files), testModules = await this.runFiles(files, true);
    if (this.config.watch) await this.report("onWatcherStart");
    return testModules;
  }
  /**
  * Initialize reporters and the coverage provider. This method doesn't run any tests.
  * If the `--watch` flag is provided, Vitest will still run changed tests even if this method was not called.
  */
  async init() {
    var _a2;
    try {
      await this.initCoverageProvider(), await ((_a2 = this.coverageProvider) == null ? void 0 : _a2.clean(this._coverageOptions.clean));
    } finally {
      await this.report("onInit", this);
    }
    if (await this.globTestSpecifications(), this.config.watch) await this.report("onWatcherStart");
  }
  /**
  * If there is a test run happening, returns a promise that will
  * resolve when the test run is finished.
  */
  async waitForTestRunEnd() {
    this.runningPromise && await this.runningPromise;
  }
  /**
  * Get test specifications associated with the given module. If module is not a test file, an empty array is returned.
  *
  * **Note:** this method relies on a cache generated by `globTestSpecifications`. If the file was not processed yet, use `project.matchesGlobPattern` instead.
  * @param moduleId The module ID to get test specifications for.
  */
  getModuleSpecifications(moduleId) {
    return this.specifications.getModuleSpecifications(moduleId);
  }
  /**
  * Vitest automatically caches test specifications for each file. This method clears the cache for the given file or the whole cache altogether.
  */
  clearSpecificationsCache(moduleId) {
    if (this.specifications.clearCache(moduleId), !moduleId) this.projects.forEach((project) => {
      project.testFilesList = null;
    });
  }
  /**
  * Run tests for the given test specifications. This does not trigger `onWatcher*` events.
  * @param specifications A list of specifications to run.
  * @param allTestsRun Indicates whether all tests were run. This only matters for coverage.
  */
  runTestSpecifications(specifications, allTestsRun = false) {
    return specifications.forEach((spec) => this.specifications.ensureSpecificationCached(spec)), this.runFiles(specifications, allTestsRun);
  }
  /**
  * Rerun files and trigger `onWatcherRerun`, `onWatcherStart` and `onTestsRerun` events.
  * @param specifications A list of specifications to run.
  * @param allTestsRun Indicates whether all tests were run. This only matters for coverage.
  */
  async rerunTestSpecifications(specifications, allTestsRun = false) {
    const files = specifications.map((spec) => spec.moduleId);
    await Promise.all([this.report("onWatcherRerun", files, "rerun test"), ...this._onUserTestsRerun.map((fn) => fn(specifications))]);
    const result = await this.runTestSpecifications(specifications, allTestsRun);
    return await this.report("onWatcherStart", this.state.getFiles(files)), result;
  }
  async runFiles(specs, allTestsRun) {
    return await this._testRun.start(specs), await this.runningPromise, this._onCancelListeners = [], this.isCancelling = false, this.runningPromise = (async () => {
      var _a2, _b2;
      try {
        if (!this.pool) this.pool = createPool(this);
        const invalidates = Array.from(this.watcher.invalidates);
        if (this.watcher.invalidates.clear(), this.snapshot.clear(), this.state.clearErrors(), !this.isFirstRun && this._coverageOptions.cleanOnRerun) await ((_a2 = this.coverageProvider) == null ? void 0 : _a2.clean());
        await this.initializeGlobalSetup(specs);
        try {
          await this.pool.runTests(specs, invalidates);
        } catch (err) {
          this.state.catchError(err, "Unhandled Error");
        }
        const files = this.state.getFiles();
        this.cache.results.updateResults(files);
        try {
          await this.cache.results.writeToCache();
        } catch {
        }
        return {
          testModules: this.state.getTestModules(),
          unhandledErrors: this.state.getUnhandledErrors()
        };
      } finally {
        const coverage = await ((_b2 = this.coverageProvider) == null ? void 0 : _b2.generateCoverage({ allTestsRun })), errors = this.state.getUnhandledErrors();
        this._checkUnhandledErrors(errors), await this._testRun.end(specs, errors, coverage), await this.reportCoverage(coverage, allTestsRun);
      }
    })().finally(() => {
      this.runningPromise = void 0, this.isFirstRun = false, this.config.changed = false, this.config.related = void 0;
    }), await this.runningPromise;
  }
  async experimental_parseSpecifications(specifications, options) {
    if (this.mode !== "test") throw new Error(`The \`experimental_parseSpecifications\` does not support "${this.mode}" mode.`);
    const concurrency = (options == null ? void 0 : options.concurrency) ?? (typeof import_node_os3.default.availableParallelism === "function" ? import_node_os3.default.availableParallelism() : import_node_os3.default.cpus().length), limit = limitConcurrency(concurrency), promises3 = specifications.map((specification) => limit(() => this.experimental_parseSpecification(specification)));
    return Promise.all(promises3);
  }
  async experimental_parseSpecification(specification) {
    if (this.mode !== "test") throw new Error(`The \`experimental_parseSpecification\` does not support "${this.mode}" mode.`);
    const file = await astCollectTests(specification.project, specification.moduleId).catch((error) => {
      return createFailedFileTask(specification.project, specification.moduleId, error);
    });
    return this.state.collectFiles(specification.project, [file]), this.state.getReportedEntity(file);
  }
  /**
  * Collect tests in specified modules. Vitest will run the files to collect tests.
  * @param specifications A list of specifications to run.
  */
  async collectTests(specifications) {
    const filepaths = specifications.map((spec) => spec.moduleId);
    return this.state.collectPaths(filepaths), await this.runningPromise, this._onCancelListeners = [], this.isCancelling = false, this.runningPromise = (async () => {
      if (!this.pool) this.pool = createPool(this);
      const invalidates = Array.from(this.watcher.invalidates);
      this.watcher.invalidates.clear(), this.snapshot.clear(), this.state.clearErrors(), await this.initializeGlobalSetup(specifications);
      try {
        await this.pool.collectTests(specifications, invalidates);
      } catch (err) {
        this.state.catchError(err, "Unhandled Error");
      }
      const files = this.state.getFiles();
      if (hasFailed(files)) process.exitCode = 1;
      return {
        testModules: this.state.getTestModules(),
        unhandledErrors: this.state.getUnhandledErrors()
      };
    })().finally(() => {
      this.runningPromise = void 0, this.config.changed = false, this.config.related = void 0;
    }), await this.runningPromise;
  }
  /**
  * Gracefully cancel the current test run. Vitest will wait until all running tests are finished before cancelling.
  */
  async cancelCurrentRun(reason) {
    this.isCancelling = true, await Promise.all(this._onCancelListeners.splice(0).map((listener) => listener(reason))), await this.runningPromise;
  }
  /** @internal */
  async _initBrowserServers() {
    await Promise.all(this.projects.map((p2) => p2._initBrowserServer()));
  }
  async initializeGlobalSetup(paths) {
    const projects = new Set(paths.map((spec) => spec.project)), coreProject = this.getRootProject();
    if (!projects.has(coreProject)) projects.add(coreProject);
    for (const project of projects) await project._initializeGlobalSetup();
  }
  /** @internal */
  async rerunFiles(files = this.state.getFilepaths(), trigger, allTestsRun = true, resetTestNamePattern = false) {
    if (resetTestNamePattern) this.configOverride.testNamePattern = void 0;
    if (this.filenamePattern) {
      const filteredFiles = await this.globTestSpecifications(this.filenamePattern);
      files = files.filter((file) => filteredFiles.some((f) => f.moduleId === file));
    }
    const specifications = files.flatMap((file) => this.getModuleSpecifications(file));
    await Promise.all([this.report("onWatcherRerun", files, trigger), ...this._onUserTestsRerun.map((fn) => fn(specifications))]);
    const testResult = await this.runFiles(specifications, allTestsRun);
    return await this.report("onWatcherStart", this.state.getFiles(files)), testResult;
  }
  /** @internal */
  async rerunTask(id) {
    const task = this.state.idMap.get(id);
    if (!task) throw new Error(`Task ${id} was not found`);
    const taskNamePattern = task.name.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    await this.changeNamePattern(taskNamePattern, [task.file.filepath], "tasks" in task ? "rerun suite" : "rerun test");
  }
  /** @internal */
  async changeProjectName(pattern) {
    if (pattern === "") this.configOverride.project = void 0;
    else this.configOverride.project = [pattern];
    await this.vite.restart();
  }
  /** @internal */
  async changeNamePattern(pattern, files = this.state.getFilepaths(), trigger) {
    if (pattern === "") this.filenamePattern = void 0;
    const testNamePattern = pattern ? new RegExp(pattern) : void 0;
    if (this.configOverride.testNamePattern = testNamePattern, testNamePattern) files = files.filter((filepath) => {
      const files2 = this.state.getFiles([filepath]);
      return !files2.length || files2.some((file) => {
        const tasks = getTasks(file);
        return !tasks.length || tasks.some((task) => testNamePattern.test(task.name));
      });
    });
    await this.rerunFiles(files, trigger, pattern === "");
  }
  /** @internal */
  async changeFilenamePattern(pattern, files = this.state.getFilepaths()) {
    this.filenamePattern = pattern ? [pattern] : [];
    const trigger = this.filenamePattern.length ? "change filename pattern" : "reset filename pattern";
    await this.rerunFiles(files, trigger, pattern === "");
  }
  /** @internal */
  async rerunFailed() {
    await this.rerunFiles(this.state.getFailedFilepaths(), "rerun failed", false);
  }
  /**
  * Update snapshots in specified files. If no files are provided, it will update files with failed tests and obsolete snapshots.
  * @param files The list of files on the file system
  */
  async updateSnapshot(files) {
    files = files || [...this.state.getFailedFilepaths(), ...this.snapshot.summary.uncheckedKeysByFile.map((s) => s.filePath)], this.enableSnapshotUpdate();
    try {
      return await this.rerunFiles(files, "update snapshot", false);
    } finally {
      this.resetSnapshotUpdate();
    }
  }
  /**
  * Enable the mode that allows updating snapshots when running tests.
  * This method doesn't run any tests.
  *
  * Every test that runs after this method is called will update snapshots.
  * To disable the mode, call `resetSnapshotUpdate`.
  */
  enableSnapshotUpdate() {
    this.configOverride.snapshotOptions = {
      updateSnapshot: "all",
      snapshotEnvironment: null
    }, this.snapshot.options.updateSnapshot = "all";
  }
  /**
  * Disable the mode that allows updating snapshots when running tests.
  */
  resetSnapshotUpdate() {
    delete this.configOverride.snapshotOptions, this.snapshot.options.updateSnapshot = this.config.snapshotOptions.updateSnapshot;
  }
  /**
  * Set the global test name pattern to a regexp.
  * This method doesn't run any tests.
  */
  setGlobalTestNamePattern(pattern) {
    if (pattern instanceof RegExp) this.configOverride.testNamePattern = pattern;
    else this.configOverride.testNamePattern = pattern ? new RegExp(pattern) : void 0;
  }
  /**
  * Returns the regexp used for the global test name pattern.
  */
  getGlobalTestNamePattern() {
    return this.configOverride.testNamePattern == null ? this.config.testNamePattern : this.configOverride.testNamePattern;
  }
  /**
  * Resets the global test name pattern. This method doesn't run any tests.
  */
  resetGlobalTestNamePattern() {
    this.configOverride.testNamePattern = void 0;
  }
  async scheduleRerun(triggerId) {
    const currentCount = this.restartsCount;
    clearTimeout(this._rerunTimer), await this.runningPromise, clearTimeout(this._rerunTimer), this.restartsCount === currentCount && (this._rerunTimer = setTimeout(async () => {
      if (this.watcher.changedTests.size === 0) {
        this.watcher.invalidates.clear();
        return;
      }
      if (this.restartsCount !== currentCount) return;
      this.isFirstRun = false, this.snapshot.clear();
      let files = Array.from(this.watcher.changedTests);
      if (this.filenamePattern) {
        const filteredFiles = await this.globTestSpecifications(this.filenamePattern);
        if (files = files.filter((file) => filteredFiles.some((f) => f.moduleId === file)), files.length === 0) return;
      }
      this.watcher.changedTests.clear();
      const triggerLabel = relative(this.config.root, triggerId), specifications = files.flatMap((file) => this.getModuleSpecifications(file)).filter((specification) => {
        return this._onFilterWatchedSpecification.length === 0 ? true : this._onFilterWatchedSpecification.every((fn) => fn(specification));
      });
      await Promise.all([this.report("onWatcherRerun", files, triggerLabel), ...this._onUserTestsRerun.map((fn) => fn(specifications))]), await this.runFiles(specifications, false), await this.report("onWatcherStart", this.state.getFiles(files));
    }, WATCHER_DEBOUNCE));
  }
  /**
  * Invalidate a file in all projects.
  */
  invalidateFile(filepath) {
    this.projects.forEach(({ vite, browser }) => {
      [...Object.values(vite.environments), ...Object.values((browser == null ? void 0 : browser.vite.environments) || {})].forEach(({ moduleGraph }) => {
        var _a2;
        (_a2 = moduleGraph.getModulesByFile(filepath)) == null ? void 0 : _a2.forEach((module) => moduleGraph.invalidateModule(module));
      });
    });
  }
  /** @internal */
  _checkUnhandledErrors(errors) {
    if (errors.length && !this.config.dangerouslyIgnoreUnhandledErrors) process.exitCode = 1;
  }
  async reportCoverage(coverage, allTestsRun) {
    var _a2, _b2;
    if (this.state.getCountOfFailedTests() > 0) {
      if (await ((_b2 = (_a2 = this.coverageProvider) == null ? void 0 : _a2.onTestFailure) == null ? void 0 : _b2.call(_a2)), !this._coverageOptions.reportOnFailure) return;
    }
    if (this.coverageProvider) {
      await this.coverageProvider.reportCoverage(coverage, { allTestsRun });
      for (const reporter of this.reporters) if (reporter instanceof WebSocketReporter) reporter.onFinishedReportCoverage();
    }
  }
  /**
  * Closes all projects and their associated resources.
  * This can only be called once; the closing promise is cached until the server restarts.
  */
  async close() {
    if (!this.closingPromise) this.closingPromise = (async () => {
      const teardownProjects = [...this.projects];
      if (this.coreWorkspaceProject && !teardownProjects.includes(this.coreWorkspaceProject)) teardownProjects.push(this.coreWorkspaceProject);
      for (const project of teardownProjects.reverse()) await project._teardownGlobalSetup();
      const closePromises = this.projects.map((w) => w.close());
      if (this.coreWorkspaceProject && !this.projects.includes(this.coreWorkspaceProject)) closePromises.push(this.coreWorkspaceProject.close().then(() => this._vite = void 0));
      if (this.pool) closePromises.push((async () => {
        var _a2, _b2;
        await ((_b2 = (_a2 = this.pool) == null ? void 0 : _a2.close) == null ? void 0 : _b2.call(_a2)), this.pool = void 0;
      })());
      return closePromises.push(...this._onClose.map((fn) => fn())), Promise.allSettled(closePromises).then((results) => {
        results.forEach((r) => {
          if (r.status === "rejected") this.logger.error("error during close", r.reason);
        });
      });
    })();
    return this.closingPromise;
  }
  /**
  * Closes all projects and exit the process
  * @param force If true, the process will exit immediately after closing the projects.
  */
  async exit(force = false) {
    if (setTimeout(() => {
      this.report("onProcessTimeout").then(() => {
        if (console.warn(`close timed out after ${this.config.teardownTimeout}ms`), !this.pool) {
          const runningServers = [this._vite, ...this.projects.map((p2) => p2._vite)].filter(Boolean).length;
          if (runningServers === 1) console.warn("Tests closed successfully but something prevents Vite server from exiting");
          else if (runningServers > 1) console.warn(`Tests closed successfully but something prevents ${runningServers} Vite servers from exiting`);
          else console.warn("Tests closed successfully but something prevents the main process from exiting");
          if (!this.reporters.some((r) => r instanceof HangingProcessReporter)) console.warn('You can try to identify the cause by enabling "hanging-process" reporter. See https://vitest.dev/config/#reporters');
        }
        process.exit();
      });
    }, this.config.teardownTimeout).unref(), await this.close(), force) process.exit();
  }
  /** @internal */
  async report(name, ...args) {
    await Promise.all(this.reporters.map((r) => {
      var _a2;
      return (_a2 = r[name]) == null ? void 0 : _a2.call(
        r,
        ...args
      );
    }));
  }
  /** @internal */
  async _globTestFilepaths() {
    const specifications = await this.globTestSpecifications();
    return Array.from(new Set(specifications.map((spec) => spec.moduleId)));
  }
  /**
  * Should the server be kept running after the tests are done.
  */
  shouldKeepServer() {
    var _a2;
    return !!((_a2 = this.config) == null ? void 0 : _a2.watch);
  }
  /**
  * Register a handler that will be called when the server is restarted due to a config change.
  */
  onServerRestart(fn) {
    this._onRestartListeners.push(fn);
  }
  /**
  * Register a handler that will be called when the test run is cancelled with `vitest.cancelCurrentRun`.
  */
  onCancel(fn) {
    this._onCancelListeners.push(fn);
  }
  /**
  * Register a handler that will be called when the server is closed.
  */
  onClose(fn) {
    this._onClose.push(fn);
  }
  /**
  * Register a handler that will be called when the tests are rerunning.
  */
  onTestsRerun(fn) {
    this._onUserTestsRerun.push(fn);
  }
  /**
  * Register a handler that will be called when a file is changed.
  * This callback should return `true` of `false` indicating whether the test file needs to be rerun.
  * @example
  * const testsToRun = [resolve('./test.spec.ts')]
  * vitest.onFilterWatchedSpecification(specification => testsToRun.includes(specification.moduleId))
  */
  onFilterWatchedSpecification(fn) {
    this._onFilterWatchedSpecification.push(fn);
  }
  /** @internal */
  onAfterSetServer(fn) {
    this._onSetServer.push(fn);
  }
  /**
  * Check if the project with a given name should be included.
  */
  matchesProjectFilter(name) {
    var _a2, _b2;
    const projects = ((_a2 = this._config) == null ? void 0 : _a2.project) || ((_b2 = this._cliOptions) == null ? void 0 : _b2.project);
    return !projects || !projects.length ? true : toArray(projects).some((project) => {
      return wildcardPatternToRegExp(project).test(name);
    });
  }
};
__publicField(Vitest, "version", version);
function assert2(condition, property, name = property) {
  if (!condition) throw new Error(`The ${name} was not set. It means that \`vitest.${property}\` was called before the Vite server was established. Await the Vitest promise before accessing \`vitest.${property}\`.`);
}
async function VitestPlugin(options = {}, vitest = new Vitest("test", deepClone(options))) {
  const userConfig = deepMerge({}, options);
  async function UIPlugin() {
    return await vitest.packageInstaller.ensureInstalled("@vitest/ui", options.root || process.cwd(), vitest.version), (await import("./ui_vitest-VOOYQB65.js")).default(vitest);
  }
  return [
    {
      name: "vitest",
      enforce: "pre",
      options() {
        this.meta.watchMode = false;
      },
      async config(viteConfig) {
        var _a2, _b2, _c, _d, _e, _f, _g, _h, _i;
        if (options.watch)
          options = deepMerge({}, userConfig);
        const testConfig = deepMerge({}, configDefaults, removeUndefinedValues(viteConfig.test ?? {}), options);
        testConfig.api = resolveApiServerConfig(testConfig, defaultPort), options.defines = deleteDefineConfig(viteConfig);
        let open = false;
        if (testConfig.ui && testConfig.open) open = testConfig.uiBase ?? "/__vitest__/";
        const resolveOptions2 = getDefaultResolveOptions();
        let config = {
          base: "/",
          root: ((_a2 = viteConfig.test) == null ? void 0 : _a2.root) || options.root,
          define: { "process.env.NODE_ENV": "process.env.NODE_ENV" },
          resolve: {
            ...resolveOptions2,
            alias: testConfig.alias
          },
          server: {
            ...testConfig.api,
            open,
            hmr: false,
            ws: ((_b2 = testConfig.api) == null ? void 0 : _b2.middlewareMode) ? false : void 0,
            preTransformRequests: false,
            fs: { allow: resolveFsAllow(options.root || process.cwd(), testConfig.config) }
          },
          build: {
            outDir: "dummy-non-existing-folder",
            emptyOutDir: false
          },
          environments: {
            ssr: { resolve: resolveOptions2 },
            __vitest__: { dev: {} }
          },
          test: {
            root: testConfig.root ?? ((_c = viteConfig.test) == null ? void 0 : _c.root),
            deps: testConfig.deps ?? ((_d = viteConfig.test) == null ? void 0 : _d.deps)
          }
        };
        if ("rolldownVersion" in node_exports) config = {
          ...config,
          oxc: viteConfig.oxc === false ? false : { target: ((_e = viteConfig.oxc) == null ? void 0 : _e.target) || "node18" }
        };
        else config = {
          ...config,
          esbuild: viteConfig.esbuild === false ? false : {
            target: ((_f = viteConfig.esbuild) == null ? void 0 : _f.target) || "node18",
            sourcemap: "external",
            legalComments: "inline"
          }
        };
        if (options.cache != null) config.test.cache = options.cache;
        if (vitest.configOverride.project)
          options.project = vitest.configOverride.project;
        if (config.customLogger = createViteLogger(vitest.logger, viteConfig.logLevel || "warn", { allowClearScreen: false }), config.customLogger = silenceImportViteIgnoreWarning(config.customLogger), process.platform === "darwin" && false) ;
        const classNameStrategy = typeof testConfig.css !== "boolean" && ((_h = (_g = testConfig.css) == null ? void 0 : _g.modules) == null ? void 0 : _h.classNameStrategy) || "stable";
        if (classNameStrategy !== "scoped") {
          if (config.css ?? (config.css = {}), (_i = config.css).modules ?? (_i.modules = {}), config.css.modules) config.css.modules.generateScopedName = (name, filename) => {
            const root = vitest.config.root || options.root || process.cwd();
            return generateScopedClassName(classNameStrategy, name, relative(root, filename));
          };
        }
        return config;
      },
      async configResolved(viteConfig) {
        var _a2, _b2, _c, _d;
        const viteConfigTest = viteConfig.test || {};
        if (viteConfigTest.watch === false) viteConfigTest.run = true;
        if ("alias" in viteConfigTest) delete viteConfigTest.alias;
        options = deepMerge({}, configDefaults, viteConfigTest, options), options.api = resolveApiServerConfig(options, defaultPort);
        const { PROD, DEV, ...envs } = viteConfig.env;
        for (const name in (_a2 = process.env).PROD ?? (_a2.PROD = PROD ? "1" : ""), (_b2 = process.env).DEV ?? (_b2.DEV = DEV ? "1" : ""), envs) (_c = process.env)[name] ?? (_c[name] = envs[name]);
        if (!options.watch) viteConfig.server.watch = null;
        if (options.ui)
          viteConfig.plugins.push(await UIPlugin());
        Object.defineProperty(viteConfig, "_vitest", {
          value: options,
          enumerable: false,
          configurable: true
        });
        const originalName = options.name;
        if ((_d = options.browser) == null ? void 0 : _d.instances) options.browser.instances.forEach((instance) => {
          instance.name ?? (instance.name = originalName ? `${originalName} (${instance.browser})` : instance.browser);
        });
      },
      configureServer: {
        order: "post",
        async handler(server) {
          if (options.watch && false) ;
          if (await vitest._setServer(options, server), options.api && options.watch) (await Promise.resolve().then(function() {
            return setup$1;
          })).setup(vitest);
          if (!options.watch) await server.watcher.close();
        }
      }
    },
    MetaEnvReplacerPlugin(),
    ...CSSEnablerPlugin(vitest),
    CoverageTransform(vitest),
    VitestCoreResolver(vitest),
    ...MocksPlugins(),
    VitestOptimizer(),
    NormalizeURLPlugin(),
    ModuleRunnerTransform()
  ].filter(notNullish);
}
function removeUndefinedValues(obj) {
  for (const key in Object.keys(obj)) if (obj[key] === void 0) delete obj[key];
  return obj;
}
async function createVitest(mode, options, viteOverrides = {}, vitestOptions = {}) {
  var _a2;
  const ctx = new Vitest(mode, deepClone(options), vitestOptions), root = slash((0, import_node_path2.resolve)(options.root || process.cwd())), configPath = options.config === false ? false : options.config ? resolveModule(options.config, { paths: [root] }) ?? (0, import_node_path2.resolve)(root, options.config) : any(configFiles, { cwd: root });
  options.config = configPath;
  const { browser: _removeBrowser, ...restOptions } = options, config = {
    configFile: configPath,
    configLoader: options.configLoader,
    mode: options.mode || mode,
    plugins: await VitestPlugin(restOptions, ctx)
  }, server = await createViteServer(mergeConfig(config, mergeConfig(viteOverrides, { root: options.root })));
  if ((_a2 = ctx.config.api) == null ? void 0 : _a2.port) await server.listen();
  return ctx;
}
var MAX_RESULT_COUNT = 10;
var SELECTION_MAX_INDEX = 7;
var ESC = "\x1B[";
var WatchFilter = class {
  constructor(message, stdin = process.stdin, stdout$1 = stdout()) {
    __publicField(this, "filterRL");
    __publicField(this, "currentKeyword");
    __publicField(this, "message");
    __publicField(this, "results", []);
    __publicField(this, "selectionIndex", -1);
    __publicField(this, "onKeyPress");
    __publicField(this, "stdin");
    __publicField(this, "stdout");
    if (this.message = message, this.stdin = stdin, this.stdout = stdout$1, this.filterRL = import_node_readline.default.createInterface({
      input: this.stdin,
      escapeCodeTimeout: 50
    }), import_node_readline.default.emitKeypressEvents(this.stdin, this.filterRL), this.stdin.isTTY) this.stdin.setRawMode(true);
  }
  async filter(filterFunc) {
    this.write(this.promptLine());
    const resultPromise = createDefer();
    this.onKeyPress = this.filterHandler(filterFunc, (result) => {
      resultPromise.resolve(result);
    }), this.stdin.on("keypress", this.onKeyPress);
    try {
      return await resultPromise;
    } finally {
      this.close();
    }
  }
  filterHandler(filterFunc, onSubmit) {
    return async (str, key) => {
      var _a2, _b2;
      switch (true) {
        case key.sequence === "":
          if (this.currentKeyword && ((_a2 = this.currentKeyword) == null ? void 0 : _a2.length) > 1) this.currentKeyword = (_b2 = this.currentKeyword) == null ? void 0 : _b2.slice(0, -1);
          else this.currentKeyword = void 0;
          break;
        case ((key == null ? void 0 : key.ctrl) && (key == null ? void 0 : key.name) === "c"):
        case (key == null ? void 0 : key.name) === "escape":
          this.write(`${ESC}1G${ESC}0J`), onSubmit(void 0);
          return;
        case (key == null ? void 0 : key.name) === "enter":
        case (key == null ? void 0 : key.name) === "return": {
          const selection = this.results[this.selectionIndex], result = typeof selection === "string" ? selection : selection == null ? void 0 : selection.key;
          onSubmit(result || this.currentKeyword || ""), this.currentKeyword = void 0;
          break;
        }
        case (key == null ? void 0 : key.name) === "up":
          if (this.selectionIndex && this.selectionIndex > 0) this.selectionIndex--;
          else this.selectionIndex = -1;
          break;
        case (key == null ? void 0 : key.name) === "down":
          if (this.selectionIndex < this.results.length - 1) this.selectionIndex++;
          else if (this.selectionIndex >= this.results.length - 1) this.selectionIndex = this.results.length - 1;
          break;
        case (!(key == null ? void 0 : key.ctrl) && !(key == null ? void 0 : key.meta)):
          if (this.currentKeyword === void 0) this.currentKeyword = str;
          else this.currentKeyword += str || "";
          break;
      }
      if (this.currentKeyword) this.results = await filterFunc(this.currentKeyword);
      this.render();
    };
  }
  render() {
    let printStr = this.promptLine();
    if (!this.currentKeyword) printStr += "\nPlease input filter pattern";
    else if (this.currentKeyword && this.results.length === 0) printStr += "\nPattern matches no results";
    else {
      const resultCountLine = this.results.length === 1 ? `Pattern matches ${this.results.length} result` : `Pattern matches ${this.results.length} results`;
      let resultBody = "";
      if (this.results.length > MAX_RESULT_COUNT) {
        const offset = this.selectionIndex > SELECTION_MAX_INDEX ? this.selectionIndex - SELECTION_MAX_INDEX : 0, displayResults = this.results.slice(offset, MAX_RESULT_COUNT + offset), remainingResultCount = this.results.length - offset - displayResults.length;
        if (resultBody = `${displayResults.map((result, index) => index + offset === this.selectionIndex ? C.green(`  ${result}`) : C.dim(`  ${result}`)).join("\n")}`, remainingResultCount > 0) resultBody += `
${C.dim(`   ...and ${remainingResultCount} more ${remainingResultCount === 1 ? "result" : "results"}`)}`;
      } else resultBody = this.results.map((result, index) => index === this.selectionIndex ? C.green(`  ${result}`) : C.dim(`  ${result}`)).join("\n");
      printStr += `
${resultCountLine}
${resultBody}`;
    }
    this.eraseAndPrint(printStr), this.restoreCursor();
  }
  keywordOffset() {
    return `? ${this.message}  `.length + 1;
  }
  promptLine() {
    return `${C.cyan("?")} ${C.bold(this.message)}  ${this.currentKeyword || ""}`;
  }
  eraseAndPrint(str) {
    let rows = 0;
    const lines = str.split(/\r?\n/);
    for (const line of lines) {
      const columns = "columns" in this.stdout ? this.stdout.columns : 80;
      rows += 1 + Math.floor(Math.max((0, import_node_util3.stripVTControlCharacters)(line).length - 1, 0) / columns);
    }
    this.write(`${ESC}1G`), this.write(`${ESC}J`), this.write(str), this.write(`${ESC}${rows - 1}A`);
  }
  close() {
    if (this.filterRL.close(), this.onKeyPress) this.stdin.removeListener("keypress", this.onKeyPress);
    if (this.stdin.isTTY) this.stdin.setRawMode(false);
  }
  restoreCursor() {
    var _a2;
    const cursortPos = this.keywordOffset() + (((_a2 = this.currentKeyword) == null ? void 0 : _a2.length) || 0);
    this.write(`${ESC}${cursortPos}G`);
  }
  write(data) {
    this.stdout.write(data);
  }
  getLastResults() {
    return this.results.map((r) => typeof r === "string" ? r : r.toString());
  }
};
var keys = [
  [["a", "return"], "rerun all tests"],
  ["r", "rerun current pattern tests"],
  ["f", "rerun only failed tests"],
  ["u", "update snapshot"],
  ["p", "filter by a filename"],
  ["t", "filter by a test name regex pattern"],
  ["w", "filter by a project name"],
  ["b", "start the browser server if not started yet"],
  ["q", "quit"]
];
var cancelKeys = [
  "space",
  "c",
  "h",
  ...keys.map((key) => key[0]).flat()
];
function printShortcutsHelp() {
  stdout().write(`
${C.bold("  Watch Usage")}
${keys.map((i) => C.dim("  press ") + C.reset([i[0]].flat().map(C.bold).join(", ")) + C.dim(` to ${i[1]}`)).join("\n")}
`);
}
function* traverseFilteredTestNames(parentName, filter, t) {
  if (isTestCase(t)) {
    if (t.name.match(filter)) {
      const displayName = `${parentName} > ${t.name}`;
      yield {
        key: t.name,
        toString: () => displayName
      };
    }
  } else {
    parentName = parentName.length ? `${parentName} > ${t.name}` : t.name;
    for (const task of t.tasks) yield* traverseFilteredTestNames(parentName, filter, task);
  }
}
function* getFilteredTestNames(pattern, suite) {
  try {
    const reg = new RegExp(pattern), files = /* @__PURE__ */ new Set();
    for (const file of suite) if (!files.has(file.name)) files.add(file.name), yield* traverseFilteredTestNames("", reg, file);
  } catch {
  }
}
function registerConsoleShortcuts(ctx, stdin = process.stdin, stdout2) {
  let latestFilename = "";
  async function _keypressHandler(str, key) {
    if (str === "" || str === "\x1B" || key && key.ctrl && key.name === "c") {
      if (!ctx.isCancelling) ctx.logger.log(C.red("Cancelling test run. Press CTRL+c again to exit forcefully.\n")), process.exitCode = 130, await ctx.cancelCurrentRun("keyboard-input");
      return ctx.exit(true);
    }
    if (!isWindows && key && key.ctrl && key.name === "z") {
      process.kill(process.ppid, "SIGTSTP"), process.kill(process.pid, "SIGTSTP");
      return;
    }
    const name = key == null ? void 0 : key.name;
    if (ctx.runningPromise) {
      if (cancelKeys.includes(name)) await ctx.cancelCurrentRun("keyboard-input");
      return;
    }
    if (name === "q") return ctx.exit(true);
    if (name === "h") return printShortcutsHelp();
    if (name === "u") return ctx.updateSnapshot();
    if (name === "a" || name === "return") {
      const files = await ctx._globTestFilepaths();
      return ctx.changeNamePattern("", files, "rerun all tests");
    }
    if (name === "r") return ctx.rerunFiles();
    if (name === "f") return ctx.rerunFailed();
    if (name === "w") return inputProjectName();
    if (name === "t") return inputNamePattern();
    if (name === "p") return inputFilePattern();
    if (name === "b") return await ctx._initBrowserServers(), ctx.projects.forEach((project) => {
      ctx.logger.log(), ctx.logger.printBrowserBanner(project);
    }), null;
  }
  async function keypressHandler(str, key) {
    await _keypressHandler(str, key);
  }
  async function inputNamePattern() {
    off();
    const filter = await new WatchFilter("Input test name pattern (RegExp)", stdin, stdout2).filter((str) => {
      return [...getFilteredTestNames(str, ctx.state.getFiles())];
    });
    if (on(), typeof filter === "undefined") return;
    const files = ctx.state.getFilepaths(), cliFiles = ctx.config.standalone && !files.length ? await ctx._globTestFilepaths() : void 0;
    await ctx.changeNamePattern((filter == null ? void 0 : filter.trim()) || "", cliFiles, "change pattern");
  }
  async function inputProjectName() {
    off();
    const { filter = "" } = await prompt([{
      name: "filter",
      type: "text",
      message: "Input a single project name",
      initial: ctx.config.project[0] || ""
    }]);
    on(), await ctx.changeProjectName(filter.trim());
  }
  async function inputFilePattern() {
    off();
    const watchFilter = new WatchFilter("Input filename pattern", stdin, stdout2), filter = await watchFilter.filter(async (str) => {
      return (await ctx.globTestSpecifications([str])).map((specification) => relative(ctx.config.root, specification.moduleId)).filter((file, index, all) => all.indexOf(file) === index);
    });
    if (on(), typeof filter === "undefined") return;
    latestFilename = (filter == null ? void 0 : filter.trim()) || "";
    const lastResults = watchFilter.getLastResults();
    await ctx.changeFilenamePattern(latestFilename, filter && lastResults.length ? lastResults.map((i) => resolve(ctx.config.root, i)) : void 0);
  }
  let rl;
  function on() {
    if (off(), rl = import_node_readline.default.createInterface({
      input: stdin,
      escapeCodeTimeout: 50
    }), import_node_readline.default.emitKeypressEvents(stdin, rl), stdin.isTTY) stdin.setRawMode(true);
    stdin.on("keypress", keypressHandler);
  }
  function off() {
    if (rl == null ? void 0 : rl.close(), rl = void 0, stdin.removeListener("keypress", keypressHandler), stdin.isTTY) stdin.setRawMode(false);
  }
  return on(), function cleanup() {
    off();
  };
}
async function startVitest(mode, cliFilters = [], options = {}, viteOverrides, vitestOptions) {
  const root = resolve(options.root || process.cwd()), ctx = await prepareVitest(mode, options, viteOverrides, vitestOptions, cliFilters);
  if (mode === "test" && ctx._coverageOptions.enabled) {
    const provider = ctx._coverageOptions.provider || "v8", requiredPackages = CoverageProviderMap[provider];
    if (requiredPackages) {
      if (!await ctx.packageInstaller.ensureInstalled(requiredPackages, root, ctx.version)) return process.exitCode = 1, ctx;
    }
  }
  const stdin = (vitestOptions == null ? void 0 : vitestOptions.stdin) || process.stdin, stdout2 = (vitestOptions == null ? void 0 : vitestOptions.stdout) || process.stdout;
  let stdinCleanup;
  if (stdin.isTTY && ctx.config.watch) stdinCleanup = registerConsoleShortcuts(ctx, stdin, stdout2);
  ctx.onAfterSetServer(() => {
    if (ctx.config.standalone) ctx.init();
    else ctx.start(cliFilters);
  });
  try {
    if (ctx.config.mergeReports) await ctx.mergeReports();
    else if (ctx.config.standalone) await ctx.init();
    else await ctx.start(cliFilters);
  } catch (e) {
    return e instanceof FilesNotFoundError ? ctx : e instanceof GitNotFoundError ? (ctx.logger.error(e.message), ctx) : e instanceof IncludeTaskLocationDisabledError || e instanceof RangeLocationFilterProvidedError || e instanceof LocationFilterFileNotFoundError ? (ctx.logger.printError(e, { verbose: false }), ctx) : (process.exitCode = 1, ctx.logger.printError(e, {
      fullStack: true,
      type: "Unhandled Error"
    }), ctx.logger.error("\n\n"), ctx);
  }
  return ctx.shouldKeepServer() ? ctx : (stdinCleanup == null ? void 0 : stdinCleanup(), await ctx.close(), ctx);
}
async function prepareVitest(mode, options = {}, viteOverrides, vitestOptions, cliFilters) {
  var _a2;
  if (process.env.TEST = "true", process.env.VITEST = "true", (_a2 = process.env).NODE_ENV ?? (_a2.NODE_ENV = "test"), options.run) options.watch = false;
  if (options.standalone && ((cliFilters == null ? void 0 : cliFilters.length) || 0) > 0) options.standalone = false;
  const root = resolve(options.root || process.cwd()), ctx = await createVitest(mode, options, viteOverrides, vitestOptions), environmentPackage = getEnvPackageName(ctx.config.environment);
  return environmentPackage && !await ctx.packageInstaller.ensureInstalled(environmentPackage, root) && (process.exitCode = 1), ctx;
}
function processCollected(ctx, files, options) {
  let errorsPrinted = false;
  if (forEachSuite(files, (suite) => {
    suite.errors().forEach((error) => {
      errorsPrinted = true, ctx.logger.printError(error, { project: suite.project });
    });
  }), !errorsPrinted) return typeof options.json === "undefined" ? formatCollectedAsString(files).forEach((test) => console.log(test)) : processJsonOutput(files, options);
}
function outputFileList(files, options) {
  if (typeof options.json !== "undefined") return outputJsonFileList(files, options);
  formatFilesAsString(files, options).map((file) => console.log(file));
}
function outputJsonFileList(files, options) {
  if (typeof options.json === "boolean") return console.log(JSON.stringify(formatFilesAsJSON(files), null, 2));
  if (typeof options.json === "string") {
    const jsonPath = resolve(options.root || process.cwd(), options.json);
    (0, import_node_fs6.mkdirSync)(dirname(jsonPath), { recursive: true }), (0, import_node_fs6.writeFileSync)(jsonPath, JSON.stringify(formatFilesAsJSON(files), null, 2));
  }
}
function formatFilesAsJSON(files) {
  return files.map((file) => {
    const result = { file: file.moduleId };
    if (file.project.name) result.projectName = file.project.name;
    return result;
  });
}
function formatFilesAsString(files, options) {
  return files.map((file) => {
    let name = relative(options.root || process.cwd(), file.moduleId);
    if (file.project.name) name = `[${file.project.name}] ${name}`;
    return name;
  });
}
function processJsonOutput(files, options) {
  if (typeof options.json === "boolean") return console.log(JSON.stringify(formatCollectedAsJSON(files), null, 2));
  if (typeof options.json === "string") {
    const jsonPath = resolve(options.root || process.cwd(), options.json);
    (0, import_node_fs6.mkdirSync)(dirname(jsonPath), { recursive: true }), (0, import_node_fs6.writeFileSync)(jsonPath, JSON.stringify(formatCollectedAsJSON(files), null, 2));
  }
}
function forEachSuite(modules, callback) {
  modules.forEach((testModule) => {
    callback(testModule);
    for (const suite of testModule.children.allSuites()) callback(suite);
  });
}
function formatCollectedAsJSON(files) {
  const results = [];
  return files.forEach((file) => {
    for (const test of file.children.allTests()) {
      if (test.result().state === "skipped") continue;
      const result = {
        name: test.fullName,
        file: test.module.moduleId
      };
      if (test.project.name) result.projectName = test.project.name;
      if (test.location) result.location = test.location;
      results.push(result);
    }
  }), results;
}
function formatCollectedAsString(testModules) {
  const results = [];
  return testModules.forEach((testModule) => {
    for (const test of testModule.children.allTests()) {
      if (test.result().state === "skipped") continue;
      const fullName = `${test.module.task.name} > ${test.fullName}`;
      results.push((test.project.name ? `[${test.project.name}] ` : "") + fullName);
    }
  }), results;
}
var envPackageNames = {
  "jsdom": "jsdom",
  "happy-dom": "happy-dom",
  "edge-runtime": "@edge-runtime/vm"
};
function getEnvPackageName(env) {
  return env === "node" ? null : env in envPackageNames ? envPackageNames[env] : env[0] === "." || isAbsolute(env) ? null : `vitest-environment-${env}`;
}
var cliApi = Object.freeze({
  __proto__: null,
  formatCollectedAsJSON,
  formatCollectedAsString,
  outputFileList,
  prepareVitest,
  processCollected,
  startVitest
});

export {
  BaseSequencer,
  resolveApiServerConfig,
  resolveConfig$1,
  parseCLI,
  require_https,
  require_http,
  require_net,
  require_tls,
  require_buffer,
  require_browser,
  require_node_tty,
  isValidApiRequest,
  createDebugger,
  escapeTestName,
  FilesNotFoundError,
  GitNotFoundError,
  VitestPackageInstaller,
  createMethodsRPC,
  ForksPoolWorker,
  ThreadsPoolWorker,
  TypecheckPoolWorker,
  VmForksPoolWorker,
  VmThreadsPoolWorker,
  getFilePoolName,
  createViteLogger,
  resolveFsAllow,
  experimental_getRunnerTask,
  Vitest,
  VitestPlugin,
  createVitest,
  registerConsoleShortcuts,
  startVitest,
  cliApi
};
//# sourceMappingURL=chunk-RJXX256H.js.map
