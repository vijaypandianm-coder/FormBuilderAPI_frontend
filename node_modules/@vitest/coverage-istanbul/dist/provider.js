import { promises } from 'node:fs';
import { defaults } from '@istanbuljs/schema';
import createDebug from 'debug';
import libCoverage from 'istanbul-lib-coverage';
import { createInstrumenter } from 'istanbul-lib-instrument';
import libReport from 'istanbul-lib-report';
import libSourceMaps from 'istanbul-lib-source-maps';
import reports from 'istanbul-reports';
import { parseModule } from 'magicast';
import c from 'tinyrainbow';
import { BaseCoverageProvider } from 'vitest/coverage';
import { isCSSRequest } from 'vitest/node';
import { C as COVERAGE_STORE_KEY } from './constants-BCJfMgEg.js';

var version = "4.0.5";

const debug = createDebug("vitest:coverage");
class IstanbulCoverageProvider extends BaseCoverageProvider {
	name = "istanbul";
	version = version;
	instrumenter;
	transformedModuleIds = new Set();
	initialize(ctx) {
		this._initialize(ctx);
		this.instrumenter = createInstrumenter({
			produceSourceMap: true,
			autoWrap: false,
			esModules: true,
			compact: false,
			coverageVariable: COVERAGE_STORE_KEY,
			coverageGlobalScope: "globalThis",
			coverageGlobalScopeFunc: false,
			ignoreClassMethods: this.options.ignoreClassMethods,
			parserPlugins: [...defaults.instrumenter.parserPlugins, ["importAttributes", { deprecatedAssertSyntax: true }]],
			generatorOpts: { importAttributesKeyword: "with" }
		});
	}
	onFileTransform(sourceCode, id, pluginCtx) {
		// Istanbul/babel cannot instrument CSS - e.g. Vue imports end up here.
		// File extension itself is .vue, but it contains CSS.
		// e.g. "Example.vue?vue&type=style&index=0&scoped=f7f04e08&lang.css"
		if (isCSSRequest(id)) {
			return;
		}
		if (!this.isIncluded(removeQueryParameters(id))) {
			return;
		}
		const sourceMap = pluginCtx.getCombinedSourcemap();
		sourceMap.sources = sourceMap.sources.map(removeQueryParameters);
		sourceCode = sourceCode.replaceAll("_ts_decorate", "/* istanbul ignore next */_ts_decorate").replaceAll(/(if +\(import\.meta\.vitest\))/g, "/* istanbul ignore next */ $1");
		const code = this.instrumenter.instrumentSync(sourceCode, id, sourceMap);
		const map = this.instrumenter.lastSourceMap();
		this.transformedModuleIds.add(id);
		return {
			code,
			map
		};
	}
	createCoverageMap() {
		return libCoverage.createCoverageMap({});
	}
	async generateCoverage({ allTestsRun }) {
		const start = debug.enabled ? performance.now() : 0;
		const coverageMap = this.createCoverageMap();
		let coverageMapByEnvironment = this.createCoverageMap();
		await this.readCoverageFiles({
			onFileRead(coverage) {
				coverageMapByEnvironment.merge(coverage);
			},
			onFinished: async () => {
				// Source maps can change based on projectName and transform mode.
				// Coverage transform re-uses source maps so we need to separate transforms from each other.
				const transformedCoverage = await transformCoverage(coverageMapByEnvironment);
				coverageMap.merge(transformedCoverage);
				coverageMapByEnvironment = this.createCoverageMap();
			},
			onDebug: debug
		});
		// Include untested files when all tests were run (not a single file re-run)
		// or if previous results are preserved by "cleanOnRerun: false"
		if (this.options.include != null && (allTestsRun || !this.options.cleanOnRerun)) {
			const coveredFiles = coverageMap.files();
			const uncoveredCoverage = await this.getCoverageMapForUncoveredFiles(coveredFiles);
			coverageMap.merge(await transformCoverage(uncoveredCoverage));
		}
		if (this.options.excludeAfterRemap) {
			coverageMap.filter((filename) => this.isIncluded(filename));
		}
		if (debug.enabled) {
			debug("Generate coverage total time %d ms", (performance.now() - start).toFixed());
		}
		return coverageMap;
	}
	async generateReports(coverageMap, allTestsRun) {
		const context = libReport.createContext({
			dir: this.options.reportsDirectory,
			coverageMap,
			watermarks: this.options.watermarks
		});
		if (this.hasTerminalReporter(this.options.reporter)) {
			this.ctx.logger.log(c.blue(" % ") + c.dim("Coverage report from ") + c.yellow(this.name));
		}
		for (const reporter of this.options.reporter) {
			// Type assertion required for custom reporters
			reports.create(reporter[0], {
				skipFull: this.options.skipFull,
				projectRoot: this.ctx.config.root,
				...reporter[1]
			}).execute(context);
		}
		if (this.options.thresholds) {
			await this.reportThresholds(coverageMap, allTestsRun);
		}
	}
	async parseConfigModule(configFilePath) {
		return parseModule(await promises.readFile(configFilePath, "utf8"));
	}
	async getCoverageMapForUncoveredFiles(coveredFiles) {
		const uncoveredFiles = await this.getUntestedFiles(coveredFiles);
		const cacheKey = new Date().getTime();
		const coverageMap = this.createCoverageMap();
		const transform = this.createUncoveredFileTransformer(this.ctx);
		// Note that these cannot be run parallel as synchronous instrumenter.lastFileCoverage
		// returns the coverage of the last transformed file
		for (const [index, filename] of uncoveredFiles.entries()) {
			let timeout;
			let start;
			if (debug.enabled) {
				start = performance.now();
				timeout = setTimeout(() => debug(c.bgRed(`File "${filename}" is taking longer than 3s`)), 3e3);
				debug("Uncovered file %d/%d", index, uncoveredFiles.length);
			}
			// Make sure file is not served from cache so that instrumenter loads up requested file coverage
			await transform(`${filename}?cache=${cacheKey}`);
			const lastCoverage = this.instrumenter.lastFileCoverage();
			coverageMap.addFileCoverage(lastCoverage);
			if (debug.enabled) {
				clearTimeout(timeout);
				const diff = performance.now() - start;
				const color = diff > 500 ? c.bgRed : c.bgGreen;
				debug(`${color(` ${diff.toFixed()} ms `)} ${filename}`);
			}
		}
		return coverageMap;
	}
	// the coverage can be enabled after the tests are run
	// this means the coverage will not be injected because the modules are cached,
	// so we are invalidating all modules that don't have the istanbul coverage injected
	onEnabled() {
		const environments = this.ctx.projects.flatMap((project) => [...Object.values(project.vite.environments), ...Object.values(project.browser?.vite.environments || {})]);
		const seen = new Set();
		environments.forEach((environment) => {
			environment.moduleGraph.idToModuleMap.forEach((node) => {
				this.invalidateTree(node, environment.moduleGraph, seen);
			});
		});
	}
	invalidateTree(node, moduleGraph, seen) {
		if (seen.has(node)) {
			return;
		}
		if (node.id && !this.transformedModuleIds.has(node.id)) {
			moduleGraph.invalidateModule(node, seen);
		}
		node.importedModules.forEach((mod) => {
			this.invalidateTree(mod, moduleGraph, seen);
		});
	}
}
async function transformCoverage(coverageMap) {
	const sourceMapStore = libSourceMaps.createSourceMapStore();
	return await sourceMapStore.transformCoverage(coverageMap);
}
/**
* Remove possible query parameters from filenames
* - From `/src/components/Header.component.ts?vue&type=script&src=true&lang.ts`
* - To `/src/components/Header.component.ts`
*/
function removeQueryParameters(filename) {
	return filename.split("?")[0];
}

export { IstanbulCoverageProvider };
