{"version":3,"sources":["../../src/utils/emitAsync.ts","../../src/utils/isObject.ts","../../src/utils/isPropertyAccessible.ts","../../src/utils/responseUtils.ts","../../src/utils/handleRequest.ts","../../src/utils/isNodeLikeError.ts"],"sourcesContent":["import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listeners = emitter.listeners(eventName)\n\n  if (listeners.length === 0) {\n    return\n  }\n\n  for (const listener of listeners) {\n    await listener.apply(emitter, data)\n  }\n}\n","/**\n * Determines if a given value is an instance of object.\n */\nexport function isObject<T>(value: any, loose = false): value is T {\n  return loose\n    ? Object.prototype.toString.call(value).startsWith('[object ')\n    : Object.prototype.toString.call(value) === '[object Object]'\n}\n","/**\n * A function that validates if property access is possible on an object\n * without throwing. It returns `true` if the property access is possible\n * and `false` otherwise.\n *\n * Environments like miniflare will throw on property access on certain objects\n * like Request and Response, for unimplemented properties.\n */\nexport function isPropertyAccessible<Obj extends Record<string, any>>(\n  obj: Obj,\n  key: keyof Obj\n) {\n  try {\n    obj[key]\n    return true\n  } catch {\n    return false\n  }\n}\n","import { isObject } from './isObject'\nimport { isPropertyAccessible } from './isPropertyAccessible'\n\n/**\n * Creates a generic 500 Unhandled Exception response.\n */\nexport function createServerErrorResponse(body: unknown): Response {\n  return new Response(\n    JSON.stringify(\n      body instanceof Error\n        ? {\n            name: body.name,\n            message: body.message,\n            stack: body.stack,\n          }\n        : body\n    ),\n    {\n      status: 500,\n      statusText: 'Unhandled Exception',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    }\n  )\n}\n\nexport type ResponseError = Response & { type: 'error' }\n\n/**\n * Check if the given response is a `Response.error()`.\n *\n * @note Some environments, like Miniflare (Cloudflare) do not\n * implement the \"Response.type\" property and throw on its access.\n * Safely check if we can access \"type\" on \"Response\" before continuing.\n * @see https://github.com/mswjs/msw/issues/1834\n */\nexport function isResponseError(response: unknown): response is ResponseError {\n  return (\n    response != null &&\n    response instanceof Response &&\n    isPropertyAccessible(response, 'type') &&\n    response.type === 'error'\n  )\n}\n\n/**\n * Check if the given value is a `Response` or a Response-like object.\n * This is different from `value instanceof Response` because it supports\n * custom `Response` constructors, like the one when using Undici directly.\n */\nexport function isResponseLike(value: unknown): value is Response {\n  return (\n    isObject<Record<string, any>>(value, true) &&\n    isPropertyAccessible(value, 'status') &&\n    isPropertyAccessible(value, 'statusText') &&\n    isPropertyAccessible(value, 'bodyUsed')\n  )\n}\n","import type { Emitter } from 'strict-event-emitter'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport type { HttpRequestEventMap } from '../glossary'\nimport { emitAsync } from './emitAsync'\nimport { RequestController } from '../RequestController'\nimport {\n  createServerErrorResponse,\n  isResponseError,\n  isResponseLike,\n} from './responseUtils'\nimport { InterceptorError } from '../InterceptorError'\nimport { isNodeLikeError } from './isNodeLikeError'\nimport { isObject } from './isObject'\n\ninterface HandleRequestOptions {\n  requestId: string\n  request: Request\n  emitter: Emitter<HttpRequestEventMap>\n  controller: RequestController\n}\n\nexport async function handleRequest(\n  options: HandleRequestOptions\n): Promise<void> {\n  const handleResponse = async (\n    response: Response | Error | Record<string, any>\n  ) => {\n    if (response instanceof Error) {\n      await options.controller.errorWith(response)\n      return true\n    }\n\n    // Handle \"Response.error()\" instances.\n    if (isResponseError(response)) {\n      await options.controller.respondWith(response)\n      return true\n    }\n\n    /**\n     * Handle normal responses or response-like objects.\n     * @note This must come before the arbitrary object check\n     * since Response instances are, in fact, objects.\n     */\n    if (isResponseLike(response)) {\n      await options.controller.respondWith(response)\n      return true\n    }\n\n    // Handle arbitrary objects provided to `.errorWith(reason)`.\n    if (isObject(response)) {\n      await options.controller.errorWith(response)\n      return true\n    }\n\n    return false\n  }\n\n  const handleResponseError = async (error: unknown): Promise<boolean> => {\n    // Forward the special interceptor error instances\n    // to the developer. These must not be handled in any way.\n    if (error instanceof InterceptorError) {\n      throw result.error\n    }\n\n    // Support mocking Node.js-like errors.\n    if (isNodeLikeError(error)) {\n      await options.controller.errorWith(error)\n      return true\n    }\n\n    // Handle thrown responses.\n    if (error instanceof Response) {\n      return await handleResponse(error)\n    }\n\n    return false\n  }\n\n  // Add the last \"request\" listener to check if the request\n  // has been handled in any way. If it hasn't, resolve the\n  // response promise with undefined.\n  // options.emitter.once('request', async ({ requestId: pendingRequestId }) => {\n  //   if (\n  //     pendingRequestId === options.requestId &&\n  //     options.controller.readyState === RequestController.PENDING\n  //   ) {\n  //     await options.controller.passthrough()\n  //   }\n  // })\n\n  const requestAbortPromise = new DeferredPromise<void, unknown>()\n\n  /**\n   * @note `signal` is not always defined in React Native.\n   */\n  if (options.request.signal) {\n    if (options.request.signal.aborted) {\n      await options.controller.errorWith(options.request.signal.reason)\n      return\n    }\n\n    options.request.signal.addEventListener(\n      'abort',\n      () => {\n        requestAbortPromise.reject(options.request.signal.reason)\n      },\n      { once: true }\n    )\n  }\n\n  const result = await until(async () => {\n    // Emit the \"request\" event and wait until all the listeners\n    // for that event are finished (e.g. async listeners awaited).\n    // By the end of this promise, the developer cannot affect the\n    // request anymore.\n    const requestListenersPromise = emitAsync(options.emitter, 'request', {\n      requestId: options.requestId,\n      request: options.request,\n      controller: options.controller,\n    })\n\n    await Promise.race([\n      // Short-circuit the request handling promise if the request gets aborted.\n      requestAbortPromise,\n      requestListenersPromise,\n      options.controller.handled,\n    ])\n  })\n\n  // Handle the request being aborted while waiting for the request listeners.\n  if (requestAbortPromise.state === 'rejected') {\n    await options.controller.errorWith(requestAbortPromise.rejectionReason)\n    return\n  }\n\n  if (result.error) {\n    // Handle the error during the request listener execution.\n    // These can be thrown responses or request errors.\n    if (await handleResponseError(result.error)) {\n      return\n    }\n\n    // If the developer has added \"unhandledException\" listeners,\n    // allow them to handle the error. They can translate it to a\n    // mocked response, network error, or forward it as-is.\n    if (options.emitter.listenerCount('unhandledException') > 0) {\n      // Create a new request controller just for the unhandled exception case.\n      // This is needed because the original controller might have been already\n      // interacted with (e.g. \"respondWith\" or \"errorWith\" called on it).\n      const unhandledExceptionController = new RequestController(\n        options.request,\n        {\n          /**\n           * @note Intentionally empty passthrough handle.\n           * This controller is created within another controller and we only need\n           * to know if `unhandledException` listeners handled the request.\n           */\n          passthrough() {},\n          async respondWith(response) {\n            await handleResponse(response)\n          },\n          async errorWith(reason) {\n            /**\n             * @note Handle the result of the unhandled controller\n             * in the same way as the original request controller.\n             * The exception here is that thrown errors within the\n             * \"unhandledException\" event do NOT result in another\n             * emit of the same event. They are forwarded as-is.\n             */\n            await options.controller.errorWith(reason)\n          },\n        }\n      )\n\n      await emitAsync(options.emitter, 'unhandledException', {\n        error: result.error,\n        request: options.request,\n        requestId: options.requestId,\n        controller: unhandledExceptionController,\n      })\n\n      // If all the \"unhandledException\" listeners have finished\n      // but have not handled the request in any way, passthrough.\n      if (\n        unhandledExceptionController.readyState !== RequestController.PENDING\n      ) {\n        return\n      }\n    }\n\n    // Otherwise, coerce unhandled exceptions to a 500 Internal Server Error response.\n    await options.controller.respondWith(\n      createServerErrorResponse(result.error)\n    )\n    return\n  }\n\n  // If the request hasn't been handled by this point, passthrough.\n  if (options.controller.readyState === RequestController.PENDING) {\n    return await options.controller.passthrough()\n  }\n\n  return options.controller.handled\n}\n","export function isNodeLikeError(\n  error: unknown\n): error is NodeJS.ErrnoException {\n  if (error == null) {\n    return false\n  }\n\n  if (!(error instanceof Error)) {\n    return false\n  }\n\n  return 'code' in error && 'errno' in error\n}\n"],"mappings":"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","names":[]}